(set-info :smt-lib-version 2.5)
(set-info :license |https://www.gnu.org/licenses/gpl-3.0.html|)
(set-logic AUFDTLIRA)
(set-info :source |Benchmarks generated by Florian Schanda from the public SPARK 2014 testsuite and post-processed with a script to set more precise logics.|)
(set-info :category industrial)
(set-info :status unknown)

(declare-datatypes () ((tuple0 (Tuple0))))
(declare-sort us_private 0)
(declare-fun private__bool_eq (us_private us_private) Bool)
(declare-const us_null_ext__ us_private)
(declare-sort us_type_of_heap 0)
(declare-datatypes () ((us_type_of_heap__ref (mk___type_of_heap__ref (us_type_of_heap__content us_type_of_heap)))))
(declare-sort us_image 0)
(declare-datatypes () ((int__ref (mk_int__ref (int__content Int)))))
(declare-datatypes () ((bool__ref (mk_bool__ref (bool__content Bool)))))
(declare-datatypes () ((real__ref (mk_real__ref (real__content Real)))))
(declare-datatypes () ((us_private__ref (mk___private__ref (us_private__content us_private)))))
(define-fun int__ref___projection ((a int__ref)) Int (int__content a))
(define-fun bool__ref___projection ((a bool__ref)) Bool (bool__content a))
(define-fun real__ref___projection ((a real__ref)) Real (real__content a))
(define-fun us_private__ref___projection ((a us_private__ref)) us_private (us_private__content a))
(define-fun in_range ((x Int)) Bool (or (= x 0) (= x 1)))
(declare-fun attr__ATTRIBUTE_IMAGE (Bool) us_image)
(declare-fun attr__ATTRIBUTE_VALUE__pre_check (us_image) Bool)
(declare-fun attr__ATTRIBUTE_VALUE (us_image) Bool)
(declare-const attr__ATTRIBUTE_ADDRESS Int)
(declare-fun get_state (Int) Int)
(declare-fun get_state__function_guard (Int Int) Bool)
(declare-sort states_t 0)
(define-fun in_range1 ((x Int)) Bool (and (<= 0 x) (<= x 3)))
(declare-fun attr__ATTRIBUTE_IMAGE1 (Int) us_image)
(declare-fun attr__ATTRIBUTE_VALUE__pre_check1 (us_image) Bool)
(declare-fun attr__ATTRIBUTE_VALUE1 (us_image) Int)
(declare-fun user_eq (states_t states_t) Bool)
(declare-const dummy states_t)
(declare-datatypes () ((states_t__ref (mk_states_t__ref (states_t__content states_t)))))
(define-fun states_t__ref___projection ((a states_t__ref)) states_t (states_t__content a))
(define-fun dynamic_invariant ((temp___expr_170 Int) (temp___is_init_166 Bool) (temp___skip_constant_167 Bool) (temp___do_toplevel_168 Bool) (temp___do_typ_inv_169 Bool)) Bool (=> (or (= temp___is_init_166 true) (<= 0 3)) (in_range1 temp___expr_170)))
(assert (forall ((sm_using_case_expression__state Int)) (! (=> (dynamic_invariant sm_using_case_expression__state true true true true) (dynamic_invariant (get_state sm_using_case_expression__state) true false true true)) :pattern ((get_state sm_using_case_expression__state)))))
(assert (forall ((sm_using_case_expression__state Int)) (! (=> (dynamic_invariant sm_using_case_expression__state true true true true) (= (get_state sm_using_case_expression__state) sm_using_case_expression__state)) :pattern ((get_state sm_using_case_expression__state)))))
(declare-fun my_sm (Int Int) Int)
(declare-fun my_sm__function_guard (Int Int Int) Bool)
(declare-sort triggers_t 0)
(define-fun in_range2 ((x Int)) Bool (and (<= 0 x) (<= x 4)))
(declare-fun attr__ATTRIBUTE_IMAGE2 (Int) us_image)
(declare-fun attr__ATTRIBUTE_VALUE__pre_check2 (us_image) Bool)
(declare-fun attr__ATTRIBUTE_VALUE2 (us_image) Int)
(declare-fun user_eq1 (triggers_t triggers_t) Bool)
(declare-const dummy1 triggers_t)
(declare-datatypes () ((triggers_t__ref (mk_triggers_t__ref (triggers_t__content triggers_t)))))
(define-fun triggers_t__ref___projection ((a triggers_t__ref)) triggers_t (triggers_t__content a))
(define-fun dynamic_invariant1 ((temp___expr_177 Int) (temp___is_init_173 Bool) (temp___skip_constant_174 Bool) (temp___do_toplevel_175 Bool) (temp___do_typ_inv_176 Bool)) Bool (=> (or (= temp___is_init_173 true) (<= 0 4)) (in_range2 temp___expr_177)))
(assert (forall ((state Int) (trigger Int)) (! (=> (and (dynamic_invariant state true true true true) (dynamic_invariant1 trigger true true true true)) (dynamic_invariant (my_sm state trigger) true false true true)) :pattern ((my_sm state trigger)))))
(assert (forall ((state Int) (trigger Int)) (! (=> (and (dynamic_invariant state true true true true) (dynamic_invariant1 trigger true true true true)) (= (my_sm state trigger) (ite (= state 0) (ite (= trigger 2) 0 (ite (= trigger 3) 2 (ite (= trigger 0) 1 (ite (= trigger 1) 0 3)))) (ite (= state 1) (ite (= trigger 2) 0 (ite (= trigger 3) 2 (ite (= trigger 0) 2 (ite (= trigger 1) 1 3)))) (ite (= state 2) (ite (= trigger 2) 0 (ite (= trigger 3) 2 (ite (= trigger 0) 2 (ite (= trigger 1) 2 3)))) (ite (= trigger 2) 0 (ite (= trigger 3) 2 3))))))) :pattern ((my_sm state trigger)))))
(declare-fun to_rep (states_t) Int)
(declare-fun of_rep (Int) states_t)
(assert (forall ((x states_t)) (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)))))
(assert (forall ((x states_t)) (! (in_range1 (to_rep x)) :pattern ((to_rep x)))))
(assert (forall ((x Int)) (! (=> (in_range1 x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep (of_rep x))))))
(declare-fun to_rep1 (triggers_t) Int)
(declare-fun of_rep1 (Int) triggers_t)
(assert (forall ((x triggers_t)) (! (= (of_rep1 (to_rep1 x)) x) :pattern ((to_rep1 x)))))
(assert (forall ((x triggers_t)) (! (in_range2 (to_rep1 x)) :pattern ((to_rep1 x)))))
(assert (forall ((x Int)) (! (=> (in_range2 x) (= (to_rep1 (of_rep1 x)) x)) :pattern ((to_rep1 (of_rep1 x))))))
(declare-datatypes () ((us_split_fields (mk___split_fields (rec__sm_using_case_expression__invalid_transition_record_t__initial_state states_t) (rec__sm_using_case_expression__invalid_transition_record_t__trigger triggers_t)))))
(define-fun us_split_fields_Initial_State__projection ((a us_split_fields)) states_t (rec__sm_using_case_expression__invalid_transition_record_t__initial_state a))
(define-fun us_split_fields_Trigger__projection ((a us_split_fields)) triggers_t (rec__sm_using_case_expression__invalid_transition_record_t__trigger a))
(declare-datatypes () ((us_split_fields__ref (mk___split_fields__ref (us_split_fields__content us_split_fields)))))
(define-fun us_split_fields__ref___projection ((a us_split_fields__ref)) us_split_fields (us_split_fields__content a))
(declare-datatypes () ((us_rep (mk___rep (us_split_fields1 us_split_fields)))))
(define-fun us_rep___projection ((a us_rep)) us_split_fields (us_split_fields1 a))
(define-fun bool_eq ((a us_rep) (b us_rep)) Bool (ite (and (= (to_rep (rec__sm_using_case_expression__invalid_transition_record_t__initial_state (us_split_fields1 a))) (to_rep (rec__sm_using_case_expression__invalid_transition_record_t__initial_state (us_split_fields1 b)))) (= (to_rep1 (rec__sm_using_case_expression__invalid_transition_record_t__trigger (us_split_fields1 a))) (to_rep1 (rec__sm_using_case_expression__invalid_transition_record_t__trigger (us_split_fields1 b))))) true false))
(declare-const value__size Int)
(declare-fun object__size (us_rep) Int)
(declare-const value__alignment Int)
(declare-fun object__alignment (us_rep) Int)
(assert (<= 0 value__size))
(assert (forall ((a us_rep)) (<= 0 (object__size a))))
(assert (<= 0 value__alignment))
(assert (forall ((a us_rep)) (<= 0 (object__alignment a))))
(declare-const sm_using_case_expression__invalid_transition_record_t__initial_state__first__bit Int)
(declare-const sm_using_case_expression__invalid_transition_record_t__initial_state__last__bit Int)
(declare-const sm_using_case_expression__invalid_transition_record_t__initial_state__position Int)
(assert (<= 0 sm_using_case_expression__invalid_transition_record_t__initial_state__first__bit))
(assert (< sm_using_case_expression__invalid_transition_record_t__initial_state__first__bit sm_using_case_expression__invalid_transition_record_t__initial_state__last__bit))
(assert (<= 0 sm_using_case_expression__invalid_transition_record_t__initial_state__position))
(declare-const sm_using_case_expression__invalid_transition_record_t__trigger__first__bit Int)
(declare-const sm_using_case_expression__invalid_transition_record_t__trigger__last__bit Int)
(declare-const sm_using_case_expression__invalid_transition_record_t__trigger__position Int)
(assert (<= 0 sm_using_case_expression__invalid_transition_record_t__trigger__first__bit))
(assert (< sm_using_case_expression__invalid_transition_record_t__trigger__first__bit sm_using_case_expression__invalid_transition_record_t__trigger__last__bit))
(assert (<= 0 sm_using_case_expression__invalid_transition_record_t__trigger__position))
(declare-fun user_eq2 (us_rep us_rep) Bool)
(declare-const dummy2 us_rep)
(declare-datatypes () ((invalid_transition_record_t__ref (mk_invalid_transition_record_t__ref (invalid_transition_record_t__content us_rep)))))
(define-fun invalid_transition_record_t__ref___projection ((a invalid_transition_record_t__ref)) us_rep (invalid_transition_record_t__content a))
(declare-datatypes () ((map__ref (mk_map__ref (map__content (Array Int us_rep))))))
(declare-fun slide ((Array Int us_rep) Int Int) (Array Int us_rep))
(assert (forall ((a (Array Int us_rep))) (forall ((first Int)) (! (= (slide a first first) a) :pattern ((slide a first first))))))
(assert (forall ((a (Array Int us_rep))) (forall ((old_first Int)) (forall ((new_first Int)) (forall ((i Int)) (! (= (select (slide a old_first new_first) i) (select a (- i (- new_first old_first)))) :pattern ((select (slide a old_first new_first) i))))))))
(define-fun bool_eq1 ((a (Array Int us_rep)) (a__first Int) (a__last Int) (b (Array Int us_rep)) (b__first Int) (b__last Int)) Bool (ite (and (ite (<= a__first a__last) (and (<= b__first b__last) (= (- a__last a__first) (- b__last b__first))) (< b__last b__first)) (forall ((temp___idx_154 Int)) (=> (and (<= a__first temp___idx_154) (<= temp___idx_154 a__last)) (= (bool_eq (select a temp___idx_154) (select b (+ (- b__first a__first) temp___idx_154))) true)))) true false))
(assert (forall ((a (Array Int us_rep)) (b (Array Int us_rep))) (forall ((a__first Int) (a__last Int) (b__first Int) (b__last Int)) (=> (= (bool_eq1 b b__first b__last a a__first a__last) true) (and (ite (<= a__first a__last) (and (<= b__first b__last) (= (- a__last a__first) (- b__last b__first))) (< b__last b__first)) (forall ((temp___idx_154 Int)) (=> (and (<= a__first temp___idx_154) (<= temp___idx_154 a__last)) (= (bool_eq (select a temp___idx_154) (select b (+ (- b__first a__first) temp___idx_154))) true))))))))
(declare-const invalid_transition_array (Array Int us_rep))
(declare-const attr__ATTRIBUTE_ADDRESS1 Int)
(declare-fun sm_using_case_expression__invalid_transition_array__aggregate_def (us_rep us_rep us_rep us_rep us_rep us_rep us_rep us_rep us_rep) (Array Int us_rep))
(declare-const trigger Int)
(declare-const attr__ATTRIBUTE_ADDRESS2 Int)
(declare-const old_state Int)
(declare-const attr__ATTRIBUTE_ADDRESS3 Int)
(assert (= invalid_transition_array (sm_using_case_expression__invalid_transition_array__aggregate_def (mk___rep (mk___split_fields (of_rep 0) (of_rep1 4))) (mk___rep (mk___split_fields (of_rep 1) (of_rep1 4))) (mk___rep (mk___split_fields (of_rep 2) (of_rep1 4))) (mk___rep (mk___split_fields (of_rep 3) (of_rep1 0))) (mk___rep (mk___split_fields (of_rep 3) (of_rep1 1))) (mk___rep (mk___split_fields (of_rep 3) (of_rep1 2))) (mk___rep (mk___split_fields (of_rep 3) (of_rep1 3))) (mk___rep (mk___split_fields (of_rep 3) (of_rep1 4))) (mk___rep (mk___split_fields (of_rep 3) (of_rep1 4))))))
(assert (forall ((temp___156 us_rep) (temp___157 us_rep) (temp___158 us_rep) (temp___159 us_rep) (temp___160 us_rep) (temp___161 us_rep) (temp___162 us_rep) (temp___163 us_rep) (temp___164 us_rep)) (let ((temp___155 (sm_using_case_expression__invalid_transition_array__aggregate_def temp___156 temp___157 temp___158 temp___159 temp___160 temp___161 temp___162 temp___163 temp___164))) (forall ((temp___165 Int)) (ite (= temp___165 8) (= (select temp___155 temp___165) temp___163) (ite (= temp___165 7) (= (select temp___155 temp___165) temp___162) (ite (= temp___165 6) (= (select temp___155 temp___165) temp___161) (ite (= temp___165 5) (= (select temp___155 temp___165) temp___160) (ite (= temp___165 4) (= (select temp___155 temp___165) temp___159) (ite (= temp___165 3) (= (select temp___155 temp___165) temp___158) (ite (= temp___165 2) (= (select temp___155 temp___165) temp___157) (ite (= temp___165 1) (= (select temp___155 temp___165) temp___156) (= (select temp___155 temp___165) temp___164)))))))))))))
(declare-const state Int)
(declare-const o triggers_t)
(declare-const o1 states_t)
(declare-const o2 states_t)
(declare-const o3 triggers_t)
(declare-const o4 triggers_t)
(declare-const o5 states_t)
(declare-const o6 states_t)
(declare-const o7 triggers_t)
(declare-const o8 triggers_t)
(declare-const o9 states_t)
(declare-const o10 states_t)
(declare-const o11 triggers_t)
(declare-const o12 triggers_t)
(declare-const o13 states_t)
(declare-const o14 states_t)
(declare-const o15 triggers_t)
(declare-const o16 triggers_t)
(declare-const o17 states_t)
(declare-const o18 states_t)
(declare-const o19 triggers_t)
(declare-const o20 triggers_t)
(declare-const o21 states_t)
(declare-const o22 states_t)
(declare-const o23 triggers_t)
(declare-const o24 triggers_t)
(declare-const o25 states_t)
(declare-const o26 states_t)
(declare-const o27 triggers_t)
(declare-const o28 triggers_t)
(declare-const o29 states_t)
(declare-const o30 states_t)
(declare-const o31 triggers_t)
(declare-const o32 triggers_t)
(declare-const o33 states_t)
(declare-const o34 states_t)
(declare-const o35 triggers_t)
(declare-const o36 states_t)
(declare-const o37 triggers_t)
(declare-const o38 states_t)
(declare-const o39 triggers_t)
(declare-const o40 states_t)
(declare-const o41 triggers_t)
(declare-const o42 states_t)
(declare-const o43 triggers_t)
(declare-const o44 states_t)
(declare-const o45 triggers_t)
(declare-const o46 states_t)
(declare-const o47 triggers_t)
(declare-const o48 us_rep)
(declare-const o49 us_rep)
(declare-const o50 us_rep)
(declare-const temp___209 (Array Int us_rep))
(assert (= (to_rep1 o32) 4))
(assert (= (to_rep o33) 3))
(assert (= o33 o34))
(assert (= o32 o35))
(assert (= o36 o34))
(assert (= o37 o35))
(assert (= (to_rep1 o28) 4))
(assert (= (to_rep o29) 3))
(assert (= o29 o30))
(assert (= o28 o31))
(assert (= o38 o30))
(assert (= o39 o31))
(assert (= (to_rep1 o24) 3))
(assert (= (to_rep o25) 3))
(assert (= o25 o26))
(assert (= o24 o27))
(assert (= o40 o26))
(assert (= o41 o27))
(assert (= (to_rep1 o20) 2))
(assert (= (to_rep o21) 3))
(assert (= o21 o22))
(assert (= o20 o23))
(assert (= o42 o22))
(assert (= o43 o23))
(assert (= (to_rep1 o16) 1))
(assert (= (to_rep o17) 3))
(assert (= o17 o18))
(assert (= o16 o19))
(assert (= o44 o18))
(assert (= o45 o19))
(assert (= (to_rep1 o12) 0))
(assert (= (to_rep o13) 3))
(assert (= o13 o14))
(assert (= o12 o15))
(assert (= o46 o14))
(assert (= o47 o15))
(assert (= (to_rep1 o8) 4))
(assert (= (to_rep o9) 2))
(assert (= o9 o10))
(assert (= o8 o11))
(assert (= o48 (mk___rep (mk___split_fields o10 o11))))
(assert (= (to_rep1 o4) 4))
(assert (= (to_rep o5) 1))
(assert (= o5 o6))
(assert (= o4 o7))
(assert (= o49 (mk___rep (mk___split_fields o6 o7))))
(assert (= (to_rep1 o) 4))
(assert (= (to_rep o1) 0))
(assert (= o1 o2))
(assert (= o o3))
(assert (= o50 (mk___rep (mk___split_fields o2 o3))))
(assert (= temp___209 (sm_using_case_expression__invalid_transition_array__aggregate_def o50 o49 o48 (mk___rep (mk___split_fields o46 o47)) (mk___rep (mk___split_fields o44 o45)) (mk___rep (mk___split_fields o42 o43)) (mk___rep (mk___split_fields o40 o41)) (mk___rep (mk___split_fields o38 o39)) (mk___rep (mk___split_fields o36 o37)))))
(assert (= temp___209 invalid_transition_array))
(assert (in_range1 state))
(assert (in_range2 trigger))
(assert (= state old_state))
(assert (in_range1 old_state))
(declare-const final_state Int)
(assert (<= 0 final_state))
(assert (<= final_state 3))
(assert (not (exists ((initial_state Int)) (and (and (<= 0 initial_state) (<= initial_state 3)) (exists ((trigger2 Int)) (and (and (<= 0 trigger2) (<= trigger2 4)) (= final_state (my_sm initial_state trigger2))))))))
(check-sat)
(exit)
