;; produced by cvc4_14.drv ;;
(set-info :smt-lib-version 2.6)
(set-logic AUFBVDTNIRA)
(set-info :source |VC generated by SPARK 2014|)
(set-info :category industrial)
(set-info :status unknown)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
(declare-datatypes ((tuple0 0)) (((Tuple0))))
(declare-sort us_private 0)

(declare-fun private__bool_eq (us_private us_private) Bool)

(declare-const us_null_ext__ us_private)

(declare-sort us_type_of_heap 0)

(declare-datatypes ((us_type_of_heap__ref 0))
(((mk___type_of_heap__ref (us_type_of_heap__content us_type_of_heap)))))
(declare-sort us_image 0)

(declare-datatypes ((int__ref 0)) (((mk_int__ref (int__content Int)))))
(declare-datatypes ((bool__ref 0)) (((mk_bool__ref (bool__content Bool)))))
(declare-datatypes ((real__ref 0)) (((mk_real__ref (real__content Real)))))
(declare-datatypes ((us_private__ref 0))
(((mk___private__ref (us_private__content us_private)))))
(define-fun int__ref___projection ((a int__ref)) Int (int__content a))

(define-fun bool__ref___projection ((a bool__ref)) Bool (bool__content a))

(define-fun real__ref___projection ((a real__ref)) Real (real__content a))

(define-fun us_private__ref___projection ((a us_private__ref)) us_private
  (us_private__content a))

(declare-sort t 0)

(declare-fun tqtreal (t) Real)

(declare-fun tqtisFinite (t) Bool)

;; t'axiom
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (and (<= (- (* 16777215.0 20282409603651670423947251286016.0)) (tqtreal x))
  (<= (tqtreal x) (* 16777215.0 20282409603651670423947251286016.0))))))

(declare-fun pow2 (Int) Int)

(declare-datatypes ((mode 0)) (((RNE1) (RNA1) (RTP1) (RTN1) (RTZ1))))
(define-fun to_nearest ((m mode)) Bool (or (= m RNE1) (= m RNA1)))

(declare-const zeroF t)

(declare-fun add (mode t t) t)

(declare-fun sub (mode t t) t)

(declare-fun mul (mode t t) t)

(declare-fun div1 (mode t t) t)

(declare-fun abs1 (t) t)

(declare-fun neg (t) t)

(declare-fun fma (mode t t t) t)

(declare-fun sqrt (mode t) t)

(declare-fun roundToIntegral (mode t) t)

(declare-fun min (t t) t)

(declare-fun max (t t) t)

(declare-fun le (t t) Bool)

(declare-fun lt (t t) Bool)

(declare-fun eq (t t) Bool)

(declare-fun is_normal (t) Bool)

(declare-fun is_subnormal (t) Bool)

(declare-fun is_zero (t) Bool)

(declare-fun is_infinite (t) Bool)

(declare-fun is_nan (t) Bool)

(declare-fun is_positive (t) Bool)

(declare-fun is_negative (t) Bool)

(define-fun is_plus_infinity ((x t)) Bool (and (is_infinite x) (is_positive
                                          x)))

(define-fun is_minus_infinity ((x t)) Bool (and (is_infinite x) (is_negative
                                           x)))

(define-fun is_plus_zero ((x t)) Bool (and (is_zero x) (is_positive x)))

(define-fun is_minus_zero ((x t)) Bool (and (is_zero x) (is_negative x)))

(define-fun is_not_nan ((x t)) Bool (or (tqtisFinite x) (is_infinite x)))

;; is_not_nan
  (assert (forall ((x t)) (= (is_not_nan x) (not (is_nan x)))))

;; is_not_finite
  (assert
  (forall ((x t)) (= (not (tqtisFinite x)) (or (is_infinite x) (is_nan x)))))

;; zeroF_is_positive
  (assert (is_positive zeroF))

;; zeroF_is_zero
  (assert (is_zero zeroF))

;; zero_to_real
  (assert
  (forall ((x t))
  (! (= (is_zero x) (and (tqtisFinite x) (= (tqtreal x) 0.0))) :pattern ((is_zero
  x)) )))

(declare-fun of_int (mode Int) t)

(declare-fun to_int1 (mode t) Int)

;; zero_of_int
  (assert (forall ((m mode)) (= zeroF (of_int m 0))))

(declare-fun round (mode Real) Real)

(declare-const max_int Int)

;; max_real_int
  (assert
  (= (* 33554430.0 10141204801825835211973625643008.0) (to_real max_int)))

(define-fun in_range ((x Real)) Bool (and
                                     (<= (- (* 33554430.0 10141204801825835211973625643008.0)) x)
                                     (<= x (* 33554430.0 10141204801825835211973625643008.0))))

(define-fun in_int_range ((i Int)) Bool (and (<= (- max_int) i)
                                        (<= i max_int)))

;; is_finite
  (assert (forall ((x t)) (=> (tqtisFinite x) (in_range (tqtreal x)))))

(define-fun no_overflow ((m mode) (x Real)) Bool (in_range (round m x)))

;; Bounded_real_no_overflow
  (assert (forall ((m mode) (x Real)) (=> (in_range x) (no_overflow m x))))

;; Round_monotonic
  (assert
  (forall ((m mode) (x Real) (y Real))
  (=> (<= x y) (<= (round m x) (round m y)))))

;; Round_idempotent
  (assert
  (forall ((m1 mode) (m2 mode) (x Real))
  (= (round m1 (round m2 x)) (round m2 x))))

;; Round_to_real
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x) (= (round m (tqtreal x)) (tqtreal x)))))

;; Round_down_le
  (assert (forall ((x Real)) (<= (round RTN1 x) x)))

;; Round_up_ge
  (assert (forall ((x Real)) (<= x (round RTP1 x))))

;; Round_down_neg
  (assert (forall ((x Real)) (= (round RTN1 (- x)) (- (round RTP1 x)))))

;; Round_up_neg
  (assert (forall ((x Real)) (= (round RTP1 (- x)) (- (round RTN1 x)))))

(define-fun in_safe_int_range ((i Int)) Bool (and (<= (- 16777216) i)
                                             (<= i 16777216)))

;; Exact_rounding_for_integers
  (assert
  (forall ((m mode) (i Int))
  (=> (in_safe_int_range i) (= (round m (to_real i)) (to_real i)))))

(define-fun same_sign ((x t)
  (y t)) Bool (or (and (is_positive x) (is_positive y))
              (and (is_negative x) (is_negative y))))

(define-fun diff_sign ((x t)
  (y t)) Bool (or (and (is_positive x) (is_negative y))
              (and (is_negative x) (is_positive y))))

;; feq_eq
  (assert
  (forall ((x t) (y t))
  (=> (tqtisFinite x)
  (=> (tqtisFinite y) (=> (not (is_zero x)) (=> (eq x y) (= x y)))))))

;; eq_feq
  (assert
  (forall ((x t) (y t))
  (=> (tqtisFinite x) (=> (tqtisFinite y) (=> (= x y) (eq x y))))))

;; eq_refl
  (assert (forall ((x t)) (=> (tqtisFinite x) (eq x x))))

;; eq_sym
  (assert (forall ((x t) (y t)) (=> (eq x y) (eq y x))))

;; eq_trans
  (assert (forall ((x t) (y t) (z t)) (=> (eq x y) (=> (eq y z) (eq x z)))))

;; eq_zero
  (assert (eq zeroF (neg zeroF)))

;; eq_to_real_finite
  (assert
  (forall ((x t) (y t))
  (=> (and (tqtisFinite x) (tqtisFinite y))
  (= (eq x y) (= (tqtreal x) (tqtreal y))))))

;; eq_special
  (assert
  (forall ((x t) (y t))
  (=> (eq x y)
  (and (is_not_nan x)
  (and (is_not_nan y)
  (or (and (tqtisFinite x) (tqtisFinite y))
  (and (is_infinite x) (and (is_infinite y) (same_sign x y)))))))))

;; lt_finite
  (assert
  (forall ((x t) (y t))
  (! (=> (and (tqtisFinite x) (tqtisFinite y))
     (= (lt x y) (< (tqtreal x) (tqtreal y)))) :pattern ((lt
  x y)) )))

;; le_finite
  (assert
  (forall ((x t) (y t))
  (! (=> (and (tqtisFinite x) (tqtisFinite y))
     (= (le x y) (<= (tqtreal x) (tqtreal y)))) :pattern ((le
  x y)) )))

;; le_lt_trans
  (assert (forall ((x t) (y t) (z t)) (=> (and (le x y) (lt y z)) (lt x z))))

;; lt_le_trans
  (assert (forall ((x t) (y t) (z t)) (=> (and (lt x y) (le y z)) (lt x z))))

;; le_ge_asym
  (assert (forall ((x t) (y t)) (=> (and (le x y) (le y x)) (eq x y))))

;; not_lt_ge
  (assert
  (forall ((x t) (y t))
  (=> (and (not (lt x y)) (and (is_not_nan x) (is_not_nan y))) (le y x))))

;; not_gt_le
  (assert
  (forall ((x t) (y t))
  (=> (and (not (lt y x)) (and (is_not_nan x) (is_not_nan y))) (le x y))))

;; le_special
  (assert
  (forall ((x t) (y t))
  (! (=> (le x y)
     (or (and (tqtisFinite x) (tqtisFinite y))
     (or (and (is_minus_infinity x) (is_not_nan y))
     (and (is_not_nan x) (is_plus_infinity y))))) :pattern ((le
  x y)) )))

;; lt_special
  (assert
  (forall ((x t) (y t))
  (! (=> (lt x y)
     (or (and (tqtisFinite x) (tqtisFinite y))
     (or
     (and (is_minus_infinity x)
     (and (is_not_nan y) (not (is_minus_infinity y))))
     (and (is_not_nan x)
     (and (not (is_plus_infinity x)) (is_plus_infinity y)))))) :pattern ((lt
  x y)) )))

;; lt_lt_finite
  (assert
  (forall ((x t) (y t) (z t)) (=> (lt x y) (=> (lt y z) (tqtisFinite y)))))

;; positive_to_real
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (=> (is_positive x) (<= 0.0 (tqtreal x)))) :pattern ((is_positive
  x)) :pattern ((<= 0.0 (tqtreal x))) )))

;; to_real_positive
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (=> (< 0.0 (tqtreal x)) (is_positive x))) :pattern ((is_positive
  x)) )))

;; negative_to_real
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (=> (is_negative x) (<= (tqtreal x) 0.0))) :pattern ((is_negative
  x)) :pattern ((<= (tqtreal x) 0.0)) )))

;; to_real_negative
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (=> (< (tqtreal x) 0.0) (is_negative x))) :pattern ((is_negative
  x)) )))

;; negative_xor_positive
  (assert (forall ((x t)) (not (and (is_positive x) (is_negative x)))))

;; negative_or_positive
  (assert
  (forall ((x t)) (=> (is_not_nan x) (or (is_positive x) (is_negative x)))))

;; diff_sign_trans
  (assert
  (forall ((x t) (y t) (z t))
  (=> (and (diff_sign x y) (diff_sign y z)) (same_sign x z))))

;; diff_sign_product
  (assert
  (forall ((x t) (y t))
  (=>
  (and (tqtisFinite x)
  (and (tqtisFinite y) (< (* (tqtreal x) (tqtreal y)) 0.0))) (diff_sign x y))))

;; same_sign_product
  (assert
  (forall ((x t) (y t))
  (=> (and (tqtisFinite x) (and (tqtisFinite y) (same_sign x y)))
  (<= 0.0 (* (tqtreal x) (tqtreal y))))))

(define-fun product_sign ((z t) (x t)
  (y t)) Bool (and (=> (same_sign x y) (is_positive z))
              (=> (diff_sign x y) (is_negative z))))

(define-fun overflow_value ((m mode)
  (x t)) Bool (ite (is-RTN1 m) (ite (is_positive x)
                               (and (tqtisFinite x)
                               (= (tqtreal x) (* 33554430.0 10141204801825835211973625643008.0)))
                               (is_infinite x)) (ite (is-RTP1 m) (ite (is_positive
                                                                 x)
                                                                 (is_infinite
                                                                 x)
                                                                 (and
                                                                 (tqtisFinite
                                                                 x)
                                                                 (= (tqtreal
                                                                    x) (- (* 33554430.0 10141204801825835211973625643008.0)))))
                                                (ite (is-RTZ1 m) (ite (is_positive
                                                                 x)
                                                                 (and
                                                                 (tqtisFinite
                                                                 x)
                                                                 (= (tqtreal
                                                                    x) (* 33554430.0 10141204801825835211973625643008.0)))
                                                                 (and
                                                                 (tqtisFinite
                                                                 x)
                                                                 (= (tqtreal
                                                                    x) (- (* 33554430.0 10141204801825835211973625643008.0)))))
                                                (ite (is-RNA1 m) (is_infinite
                                                x) (is_infinite x))))))

(define-fun sign_zero_result ((m mode)
  (x t)) Bool (=> (is_zero x)
              (ite (is-RTN1 m) (is_negative x) (is_positive x))))

;; add_finite
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (no_overflow m (+ (tqtreal x) (tqtreal y)))
     (and (tqtisFinite (add m x y))
     (= (tqtreal (add m x y)) (round m (+ (tqtreal x) (tqtreal y)))))))) :pattern (
  (add m x y)) )))

;; add_finite_rev
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite (add m x y)) (and (tqtisFinite x) (tqtisFinite y))) :pattern (
  (add m x y)) )))

;; add_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (add m x y))
     (and (no_overflow m (+ (tqtreal x) (tqtreal y)))
     (= (tqtreal (add m x y)) (round m (+ (tqtreal x) (tqtreal y))))))) :pattern (
  (add m x y)) )))

;; sub_finite
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (no_overflow m (- (tqtreal x) (tqtreal y)))
     (and (tqtisFinite (sub m x y))
     (= (tqtreal (sub m x y)) (round m (- (tqtreal x) (tqtreal y)))))))) :pattern (
  (sub m x y)) )))

;; sub_finite_rev
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite (sub m x y)) (and (tqtisFinite x) (tqtisFinite y))) :pattern (
  (sub m x y)) )))

;; sub_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (sub m x y))
     (and (no_overflow m (- (tqtreal x) (tqtreal y)))
     (= (tqtreal (sub m x y)) (round m (- (tqtreal x) (tqtreal y))))))) :pattern (
  (sub m x y)) )))

;; mul_finite
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (no_overflow m (* (tqtreal x) (tqtreal y)))
     (and (tqtisFinite (mul m x y))
     (= (tqtreal (mul m x y)) (round m (* (tqtreal x) (tqtreal y)))))))) :pattern (
  (mul m x y)) )))

;; mul_finite_rev
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite (mul m x y)) (and (tqtisFinite x) (tqtisFinite y))) :pattern (
  (mul m x y)) )))

;; mul_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (mul m x y))
     (and (no_overflow m (* (tqtreal x) (tqtreal y)))
     (= (tqtreal (mul m x y)) (round m (* (tqtreal x) (tqtreal y))))))) :pattern (
  (mul m x y)) )))

;; div_finite
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (not (is_zero y))
     (=> (no_overflow m (/ (tqtreal x) (tqtreal y)))
     (and (tqtisFinite (div1 m x y))
     (= (tqtreal (div1 m x y)) (round m (/ (tqtreal x) (tqtreal y))))))))) :pattern (
  (div1 m x y)) )))

;; div_finite_rev
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite (div1 m x y))
     (or (and (tqtisFinite x) (and (tqtisFinite y) (not (is_zero y))))
     (and (tqtisFinite x)
     (and (is_infinite y) (= (tqtreal (div1 m x y)) 0.0))))) :pattern (
  (div1 m x y)) )))

;; div_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (div1 m x y))
     (=> (tqtisFinite y)
     (and (no_overflow m (/ (tqtreal x) (tqtreal y)))
     (= (tqtreal (div1 m x y)) (round m (/ (tqtreal x) (tqtreal y)))))))) :pattern (
  (div1 m x y)) )))

;; neg_finite
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x)
     (and (tqtisFinite (neg x)) (= (tqtreal (neg x)) (- (tqtreal x))))) :pattern (
  (neg x)) )))

;; neg_finite_rev
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite (neg x))
     (and (tqtisFinite x) (= (tqtreal (neg x)) (- (tqtreal x))))) :pattern (
  (neg x)) )))

;; abs_finite
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x)
     (and (tqtisFinite (abs1 x))
     (and
     (= (tqtreal (abs1 x)) (ite (>= (tqtreal x) 0.0) (tqtreal x) (- (tqtreal
                                                                    x))))
     (is_positive (abs1 x))))) :pattern ((abs1 x)) )))

;; abs_finite_rev
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite (abs1 x))
     (and (tqtisFinite x)
     (= (tqtreal (abs1 x)) (ite (>= (tqtreal x) 0.0) (tqtreal x) (- (tqtreal
                                                                    x)))))) :pattern (
  (abs1 x)) )))

;; abs_universal
  (assert
  (forall ((x t)) (! (not (is_negative (abs1 x))) :pattern ((abs1 x)) )))

;; fma_finite
  (assert
  (forall ((m mode) (x t) (y t) (z t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (tqtisFinite z)
     (=> (no_overflow m (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)))
     (and (tqtisFinite (fma m x y z))
     (= (tqtreal (fma m x y z)) (round m
                                (+ (* (tqtreal x) (tqtreal y)) (tqtreal z))))))))) :pattern (
  (fma m x y z)) )))

;; fma_finite_rev
  (assert
  (forall ((m mode) (x t) (y t) (z t))
  (! (=> (tqtisFinite (fma m x y z))
     (and (tqtisFinite x) (and (tqtisFinite y) (tqtisFinite z)))) :pattern (
  (fma m x y z)) )))

;; fma_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t) (z t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (fma m x y z))
     (and (no_overflow m (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)))
     (= (tqtreal (fma m x y z)) (round m
                                (+ (* (tqtreal x) (tqtreal y)) (tqtreal z))))))) :pattern (
  (fma m x y z)) )))

(define-fun sqr ((x Real)) Real (* x x))

(declare-fun sqrt1 (Real) Real)

;; Sqrt_positive
  (assert (forall ((x Real)) (=> (<= 0.0 x) (<= 0.0 (sqrt1 x)))))

;; Sqrt_square
  (assert (forall ((x Real)) (=> (<= 0.0 x) (= (sqr (sqrt1 x)) x))))

;; Square_sqrt
  (assert (forall ((x Real)) (=> (<= 0.0 x) (= (sqrt1 (* x x)) x))))

;; Sqrt_mul
  (assert
  (forall ((x Real) (y Real))
  (=> (and (<= 0.0 x) (<= 0.0 y))
  (= (sqrt1 (* x y)) (* (sqrt1 x) (sqrt1 y))))))

;; Sqrt_le
  (assert
  (forall ((x Real) (y Real))
  (=> (and (<= 0.0 x) (<= x y)) (<= (sqrt1 x) (sqrt1 y)))))

;; sqrt_finite
  (assert
  (forall ((m mode) (x t))
  (! (=> (tqtisFinite x)
     (=> (<= 0.0 (tqtreal x))
     (and (tqtisFinite (sqrt m x))
     (= (tqtreal (sqrt m x)) (round m (sqrt1 (tqtreal x))))))) :pattern (
  (sqrt m x)) )))

;; sqrt_finite_rev
  (assert
  (forall ((m mode) (x t))
  (! (=> (tqtisFinite (sqrt m x))
     (and (tqtisFinite x)
     (and (<= 0.0 (tqtreal x))
     (= (tqtreal (sqrt m x)) (round m (sqrt1 (tqtreal x))))))) :pattern (
  (sqrt m x)) )))

(define-fun same_sign_real ((x t)
  (r Real)) Bool (or (and (is_positive x) (< 0.0 r))
                 (and (is_negative x) (< r 0.0))))

;; add_special
  (assert
  (forall ((m mode) (x t) (y t))
  (! (let ((r (add m x y)))
     (and (=> (or (is_nan x) (is_nan y)) (is_nan r))
     (and
     (=> (and (tqtisFinite x) (is_infinite y))
     (and (is_infinite r) (same_sign r y)))
     (and
     (=> (and (is_infinite x) (tqtisFinite y))
     (and (is_infinite r) (same_sign r x)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (same_sign x y)))
     (and (is_infinite r) (same_sign r x)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (diff_sign x y))) (is_nan
     r))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y) (not (no_overflow m (+ (tqtreal x) (tqtreal y))))))
     (and (same_sign_real r (+ (tqtreal x) (tqtreal y))) (overflow_value m
     r)))
     (=> (and (tqtisFinite x) (tqtisFinite y))
     (ite (same_sign x y) (same_sign r x) (sign_zero_result m r)))))))))) :pattern (
  (add m x y)) )))

;; sub_special
  (assert
  (forall ((m mode) (x t) (y t))
  (! (let ((r (sub m x y)))
     (and (=> (or (is_nan x) (is_nan y)) (is_nan r))
     (and
     (=> (and (tqtisFinite x) (is_infinite y))
     (and (is_infinite r) (diff_sign r y)))
     (and
     (=> (and (is_infinite x) (tqtisFinite y))
     (and (is_infinite r) (same_sign r x)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (same_sign x y))) (is_nan
     r))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (diff_sign x y)))
     (and (is_infinite r) (same_sign r x)))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y) (not (no_overflow m (- (tqtreal x) (tqtreal y))))))
     (and (same_sign_real r (- (tqtreal x) (tqtreal y))) (overflow_value m
     r)))
     (=> (and (tqtisFinite x) (tqtisFinite y))
     (ite (diff_sign x y) (same_sign r x) (sign_zero_result m r)))))))))) :pattern (
  (sub m x y)) )))

;; mul_special
  (assert
  (forall ((m mode) (x t) (y t))
  (! (let ((r (mul m x y)))
     (and (=> (or (is_nan x) (is_nan y)) (is_nan r))
     (and (=> (and (is_zero x) (is_infinite y)) (is_nan r))
     (and
     (=> (and (tqtisFinite x) (and (is_infinite y) (not (is_zero x))))
     (is_infinite r))
     (and (=> (and (is_infinite x) (is_zero y)) (is_nan r))
     (and
     (=> (and (is_infinite x) (and (tqtisFinite y) (not (is_zero y))))
     (is_infinite r))
     (and (=> (and (is_infinite x) (is_infinite y)) (is_infinite r))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y) (not (no_overflow m (* (tqtreal x) (tqtreal y))))))
     (overflow_value m r)) (=> (not (is_nan r)) (product_sign r x y)))))))))) :pattern (
  (mul m x y)) )))

;; div_special
  (assert
  (forall ((m mode) (x t) (y t))
  (! (let ((r (div1 m x y)))
     (and (=> (or (is_nan x) (is_nan y)) (is_nan r))
     (and (=> (and (tqtisFinite x) (is_infinite y)) (is_zero r))
     (and (=> (and (is_infinite x) (tqtisFinite y)) (is_infinite r))
     (and (=> (and (is_infinite x) (is_infinite y)) (is_nan r))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y)
     (and (not (is_zero y))
     (not (no_overflow m (/ (tqtreal x) (tqtreal y))))))) (overflow_value m
     r))
     (and
     (=> (and (tqtisFinite x) (and (is_zero y) (not (is_zero x))))
     (is_infinite r))
     (and (=> (and (is_zero x) (is_zero y)) (is_nan r))
     (=> (not (is_nan r)) (product_sign r x y)))))))))) :pattern ((div1 m x
                                                                  y)) )))

;; neg_special
  (assert
  (forall ((x t))
  (! (and (=> (is_nan x) (is_nan (neg x)))
     (and (=> (is_infinite x) (is_infinite (neg x)))
     (=> (not (is_nan x)) (diff_sign x (neg x))))) :pattern ((neg x)) )))

;; abs_special
  (assert
  (forall ((x t))
  (! (and (=> (is_nan x) (is_nan (abs1 x)))
     (and (=> (is_infinite x) (is_infinite (abs1 x)))
     (=> (not (is_nan x)) (is_positive (abs1 x))))) :pattern ((abs1 x)) )))

;; fma_special
  (assert
  (forall ((m mode) (x t) (y t) (z t))
  (! (let ((r (fma m x y z)))
     (and (=> (or (is_nan x) (or (is_nan y) (is_nan z))) (is_nan r))
     (and (=> (and (is_zero x) (is_infinite y)) (is_nan r))
     (and (=> (and (is_infinite x) (is_zero y)) (is_nan r))
     (and
     (=>
     (and (tqtisFinite x)
     (and (not (is_zero x)) (and (is_infinite y) (tqtisFinite z))))
     (and (is_infinite r) (product_sign r x y)))
     (and
     (=>
     (and (tqtisFinite x)
     (and (not (is_zero x)) (and (is_infinite y) (is_infinite z))))
     (ite (product_sign z x y) (and (is_infinite r) (same_sign r z)) (is_nan
     r)))
     (and
     (=>
     (and (is_infinite x)
     (and (tqtisFinite y) (and (not (is_zero y)) (tqtisFinite z))))
     (and (is_infinite r) (product_sign r x y)))
     (and
     (=>
     (and (is_infinite x)
     (and (tqtisFinite y) (and (not (is_zero y)) (is_infinite z))))
     (ite (product_sign z x y) (and (is_infinite r) (same_sign r z)) (is_nan
     r)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (tqtisFinite z)))
     (and (is_infinite r) (product_sign r x y)))
     (and
     (=> (and (tqtisFinite x) (and (tqtisFinite y) (is_infinite z)))
     (and (is_infinite r) (same_sign r z)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (is_infinite z)))
     (ite (product_sign z x y) (and (is_infinite r) (same_sign r z)) (is_nan
     r)))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y)
     (and (tqtisFinite z)
     (not (no_overflow m (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)))))))
     (and (same_sign_real r (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)))
     (overflow_value m r)))
     (=> (and (tqtisFinite x) (and (tqtisFinite y) (tqtisFinite z)))
     (ite (product_sign z x y) (same_sign r z)
     (=> (= (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)) 0.0)
     (ite (= m RTN1) (is_negative r) (is_positive r))))))))))))))))) :pattern (
  (fma m x y z)) )))

;; sqrt_special
  (assert
  (forall ((m mode) (x t))
  (! (let ((r (sqrt m x)))
     (and (=> (is_nan x) (is_nan r))
     (and (=> (is_plus_infinity x) (is_plus_infinity r))
     (and (=> (is_minus_infinity x) (is_nan r))
     (and (=> (and (tqtisFinite x) (< (tqtreal x) 0.0)) (is_nan r))
     (and (=> (is_zero x) (same_sign r x))
     (=> (and (tqtisFinite x) (< 0.0 (tqtreal x))) (is_positive r)))))))) :pattern (
  (sqrt m x)) )))

;; of_int_add_exact
  (assert
  (forall ((m mode) (n mode) (i Int) (j Int))
  (=> (in_safe_int_range i)
  (=> (in_safe_int_range j)
  (=> (in_safe_int_range (+ i j)) (eq (of_int m (+ i j))
  (add n (of_int m i) (of_int m j))))))))

;; of_int_sub_exact
  (assert
  (forall ((m mode) (n mode) (i Int) (j Int))
  (=> (in_safe_int_range i)
  (=> (in_safe_int_range j)
  (=> (in_safe_int_range (- i j)) (eq (of_int m (- i j))
  (sub n (of_int m i) (of_int m j))))))))

;; of_int_mul_exact
  (assert
  (forall ((m mode) (n mode) (i Int) (j Int))
  (=> (in_safe_int_range i)
  (=> (in_safe_int_range j)
  (=> (in_safe_int_range (* i j)) (eq (of_int m (* i j))
  (mul n (of_int m i) (of_int m j))))))))

;; Min_r
  (assert (forall ((x t) (y t)) (=> (le y x) (eq (min x y) y))))

;; Min_l
  (assert (forall ((x t) (y t)) (=> (le x y) (eq (min x y) x))))

;; Max_r
  (assert (forall ((x t) (y t)) (=> (le y x) (eq (max x y) x))))

;; Max_l
  (assert (forall ((x t) (y t)) (=> (le x y) (eq (max x y) y))))

(declare-fun is_int1 (t) Bool)

;; zeroF_is_int
  (assert (is_int1 zeroF))

;; of_int_is_int
  (assert
  (forall ((m mode) (x Int)) (=> (in_int_range x) (is_int1 (of_int m x)))))

;; big_float_is_int
  (assert
  (forall ((m mode) (i t))
  (=> (tqtisFinite i)
  (=> (or (le i (neg (of_int m 16777216))) (le (of_int m 16777216) i))
  (is_int1 i)))))

;; roundToIntegral_is_int
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x) (is_int1 (roundToIntegral m x)))))

;; eq_is_int
  (assert (forall ((x t) (y t)) (=> (eq x y) (=> (is_int1 x) (is_int1 y)))))

;; add_int
  (assert
  (forall ((x t) (y t) (m mode))
  (=> (is_int1 x)
  (=> (is_int1 y) (=> (tqtisFinite (add m x y)) (is_int1 (add m x y)))))))

;; sub_int
  (assert
  (forall ((x t) (y t) (m mode))
  (=> (is_int1 x)
  (=> (is_int1 y) (=> (tqtisFinite (sub m x y)) (is_int1 (sub m x y)))))))

;; mul_int
  (assert
  (forall ((x t) (y t) (m mode))
  (=> (is_int1 x)
  (=> (is_int1 y) (=> (tqtisFinite (mul m x y)) (is_int1 (mul m x y)))))))

;; fma_int
  (assert
  (forall ((x t) (y t) (z t) (m mode))
  (=> (is_int1 x)
  (=> (is_int1 y)
  (=> (is_int1 z) (=> (tqtisFinite (fma m x y z)) (is_int1 (fma m x y z))))))))

;; neg_int
  (assert (forall ((x t)) (=> (is_int1 x) (is_int1 (neg x)))))

;; abs_int
  (assert (forall ((x t)) (=> (is_int1 x) (is_int1 (abs1 x)))))

;; is_int_of_int
  (assert
  (forall ((x t) (m mode) (mqt mode))
  (=> (is_int1 x) (eq x (of_int mqt (to_int1 m x))))))

;; is_int_to_int
  (assert
  (forall ((m mode) (x t)) (=> (is_int1 x) (in_int_range (to_int1 m x)))))

;; is_int_is_finite
  (assert (forall ((x t)) (=> (is_int1 x) (tqtisFinite x))))

;; int_to_real
  (assert
  (forall ((m mode) (x t))
  (=> (is_int1 x) (= (tqtreal x) (to_real (to_int1 m x))))))

;; truncate_int
  (assert
  (forall ((m mode) (i t)) (=> (is_int1 i) (eq (roundToIntegral m i) i))))

;; truncate_neg
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (=> (is_negative x) (= (roundToIntegral RTZ1 x) (roundToIntegral RTP1 x))))))

;; truncate_pos
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (=> (is_positive x) (= (roundToIntegral RTZ1 x) (roundToIntegral RTN1 x))))))

;; ceil_le
  (assert
  (forall ((x t)) (=> (tqtisFinite x) (le x (roundToIntegral RTP1 x)))))

;; ceil_lest
  (assert
  (forall ((x t) (y t))
  (=> (and (le x y) (is_int1 y)) (le (roundToIntegral RTP1 x) y))))

;; ceil_to_real
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (= (tqtreal (roundToIntegral RTP1 x)) (to_real (- 1 (to_int (- 1.0
  (tqtreal x)))))))))

;; ceil_to_int
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x)
  (= (to_int1 m (roundToIntegral RTP1 x)) (- 1 (to_int (- 1.0 (tqtreal x))))))))

;; floor_le
  (assert
  (forall ((x t)) (=> (tqtisFinite x) (le (roundToIntegral RTN1 x) x))))

;; floor_lest
  (assert
  (forall ((x t) (y t))
  (=> (and (le y x) (is_int1 y)) (le y (roundToIntegral RTN1 x)))))

;; floor_to_real
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (= (tqtreal (roundToIntegral RTN1 x)) (to_real (to_int (tqtreal x)))))))

;; floor_to_int
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x)
  (= (to_int1 m (roundToIntegral RTN1 x)) (to_int (tqtreal x))))))

;; RNA_down
  (assert
  (forall ((x t))
  (=> (lt (sub RNE1 x (roundToIntegral RTN1 x))
  (sub RNE1 (roundToIntegral RTP1 x) x))
  (= (roundToIntegral RNA1 x) (roundToIntegral RTN1 x)))))

;; RNA_up
  (assert
  (forall ((x t))
  (=> (lt (sub RNE1 (roundToIntegral RTP1 x) x)
  (sub RNE1 x (roundToIntegral RTN1 x)))
  (= (roundToIntegral RNA1 x) (roundToIntegral RTP1 x)))))

;; RNA_down_tie
  (assert
  (forall ((x t))
  (=> (eq (sub RNE1 x (roundToIntegral RTN1 x))
  (sub RNE1 (roundToIntegral RTP1 x) x))
  (=> (is_negative x) (= (roundToIntegral RNA1 x) (roundToIntegral RTN1 x))))))

;; RNA_up_tie
  (assert
  (forall ((x t))
  (=> (eq (sub RNE1 (roundToIntegral RTP1 x) x)
  (sub RNE1 x (roundToIntegral RTN1 x)))
  (=> (is_positive x) (= (roundToIntegral RNA1 x) (roundToIntegral RTP1 x))))))

;; to_int_roundToIntegral
  (assert
  (forall ((m mode) (x t))
  (= (to_int1 m x) (to_int1 m (roundToIntegral m x)))))

;; to_int_monotonic
  (assert
  (forall ((m mode) (x t) (y t))
  (=> (tqtisFinite x)
  (=> (tqtisFinite y) (=> (le x y) (<= (to_int1 m x) (to_int1 m y)))))))

;; to_int_of_int
  (assert
  (forall ((m mode) (i Int))
  (=> (in_safe_int_range i) (= (to_int1 m (of_int m i)) i))))

;; eq_to_int
  (assert
  (forall ((m mode) (x t) (y t))
  (=> (tqtisFinite x) (=> (eq x y) (= (to_int1 m x) (to_int1 m y))))))

;; neg_to_int
  (assert
  (forall ((m mode) (x t))
  (=> (is_int1 x) (= (to_int1 m (neg x)) (- (to_int1 m x))))))

;; roundToIntegral_is_finite
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x) (tqtisFinite (roundToIntegral m x)))))

;; round_bound_ne
  (assert
  (forall ((x Real))
  (! (=> (no_overflow RNE1 x)
     (and
     (<= (- (- x (* (/ 1.0 16777216.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 1427247692705959881058285969449495136382746624.0))
     (round RNE1 x))
     (<= (round RNE1 x) (+ (+ x (* (/ 1.0 16777216.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 1427247692705959881058285969449495136382746624.0))))) :pattern (
  (round RNE1 x)) )))

;; round_bound
  (assert
  (forall ((m mode) (x Real))
  (! (=> (no_overflow m x)
     (and
     (<= (- (- x (* (/ 1.0 8388608.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 713623846352979940529142984724747568191373312.0))
     (round m x))
     (<= (round m x) (+ (+ x (* (/ 1.0 8388608.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 713623846352979940529142984724747568191373312.0))))) :pattern (
  (round m x)) )))

(define-fun neq ((x t) (y t)) Bool (not (eq x y)))

(define-fun bool_lt ((x t) (y t)) Bool (ite (lt x y) true false))

(define-fun bool_le ((x t) (y t)) Bool (ite (le x y) true false))

(define-fun bool_gt ((x t) (y t)) Bool (ite (lt y x) true false))

(define-fun bool_ge ((x t) (y t)) Bool (ite (le y x) true false))

(define-fun bool_eq ((x t) (y t)) Bool (ite (eq x y) true false))

(define-fun bool_neq ((x t) (y t)) Bool (ite (not (eq x y)) true false))

(declare-fun rem (t t) t)

(declare-const fliteral t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral) (= (tqtreal fliteral) 1.0)))

;; one_is_int
  (assert (is_int1 fliteral))

;; one_of_int
  (assert (= fliteral (of_int RNA1 1)))

(declare-datatypes ((t__ref 0)) (((mk_t__ref (t__content t)))))
(declare-const max_value t)

;; max_value
  (assert
  (= (* 33554430.0 10141204801825835211973625643008.0) (tqtreal max_value)))

(declare-fun next_representable (t) t)

(declare-fun prev_representable (t) t)

;; next_representable_def
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (lt x (next_representable x))) :pattern ((next_representable
                                                                  x)) )))

;; prev_representable_def
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (lt (prev_representable x) x)) :pattern ((prev_representable
                                                                  x)) )))

;; next_representable_def2
  (assert (forall ((x t) (y t)) (=> (lt x y) (le (next_representable x) y))))

;; prev_representable_def2
  (assert (forall ((x t) (y t)) (=> (lt y x) (le y (prev_representable x)))))

;; next_representable_finite
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x)
     (=> (not (eq x max_value)) (tqtisFinite (next_representable x)))) :pattern ((tqtisFinite
  (next_representable x))) )))

;; prev_representable_finite
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x)
     (=> (not (eq x (neg max_value))) (tqtisFinite (prev_representable x)))) :pattern ((tqtisFinite
  (prev_representable x))) )))

(define-fun to_int2 ((b Bool)) Int (ite (= b true) 1 0))

(define-fun of_int1 ((i Int)) Bool (ite (= i 0) false true))

(define-fun in_range1 ((x Int)) Bool (or (= x 0) (= x 1)))

(declare-fun attr__ATTRIBUTE_IMAGE (Bool) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE (us_image) Bool)

(declare-sort integer 0)

(define-fun in_range2 ((x Int)) Bool (and (<= (- 2147483648) x)
                                     (<= x 2147483647)))

(declare-fun attr__ATTRIBUTE_IMAGE1 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check1 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE1 (us_image) Int)

(declare-fun user_eq (integer integer) Bool)

(declare-const dummy integer)

(declare-datatypes ((integer__ref 0))
(((mk_integer__ref (integer__content integer)))))
(define-fun integer__ref___projection ((a integer__ref)) integer (integer__content
                                                                 a))

(declare-sort positive 0)

(define-fun in_range3 ((x Int)) Bool (and (<= 1 x) (<= x 2147483647)))

(declare-fun attr__ATTRIBUTE_IMAGE2 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check2 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE2 (us_image) Int)

(declare-fun user_eq1 (positive positive) Bool)

(declare-const dummy1 positive)

(declare-datatypes ((positive__ref 0))
(((mk_positive__ref (positive__content positive)))))
(define-fun positive__ref___projection ((a positive__ref)) positive (positive__content
                                                                    a))

(declare-sort character 0)

(define-fun in_range4 ((x Int)) Bool (and (<= 0 x) (<= x 255)))

(declare-fun attr__ATTRIBUTE_IMAGE3 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check3 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE3 (us_image) Int)

(declare-fun user_eq2 (character character) Bool)

(declare-const dummy2 character)

(declare-datatypes ((character__ref 0))
(((mk_character__ref (character__content character)))))
(define-fun character__ref___projection ((a character__ref)) character
  (character__content a))

(declare-fun to_rep (character) Int)

(declare-fun of_rep (Int) character)

;; inversion_axiom
  (assert
  (forall ((x character))
  (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; range_axiom
  (assert
  (forall ((x character)) (! (in_range4 (to_rep x)) :pattern ((to_rep x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range4 x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep
                                                            (of_rep x))) )))

(declare-datatypes ((map__ref 0))
(((mk_map__ref (map__content (Array Int character))))))
(declare-fun slide ((Array Int character) Int Int) (Array Int character))

;; slide_eq
  (assert
  (forall ((a (Array Int character)))
  (forall ((first Int))
  (! (= (slide a first first) a) :pattern ((slide a first first)) ))))

;; slide_def
  (assert
  (forall ((a (Array Int character)))
  (forall ((old_first Int))
  (forall ((new_first Int))
  (forall ((i Int))
  (! (= (select (slide a old_first new_first) i) (select a (- i (- new_first old_first)))) :pattern ((select
  (slide a old_first new_first) i)) ))))))

(declare-fun concat1 ((Array Int character) Int Int (Array Int character) Int
  Int) (Array Int character))

;; concat_def
  (assert
  (forall ((a (Array Int character)) (b (Array Int character)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (and
     (=> (and (<= a_first i) (<= i a_last))
     (= (select (concat1 a a_first a_last b b_first b_last) i) (select a i)))
     (=> (< a_last i)
     (= (select (concat1 a a_first a_last b b_first b_last) i) (select b (+ (- i a_last) (- b_first 1)))))) :pattern ((select
  (concat1 a a_first a_last b b_first b_last) i)) )))))

(declare-fun singleton1 (character Int) (Array Int character))

;; singleton_def
  (assert
  (forall ((v character))
  (forall ((i Int))
  (! (= (select (singleton1 v i) i) v) :pattern ((select (singleton1 v i) i)) ))))

(define-fun bool_eq1 ((a (Array Int character)) (a__first Int) (a__last Int)
  (b (Array Int character)) (b__first Int)
  (b__last Int)) Bool (ite (and
                           (ite (<= a__first a__last)
                           (and (<= b__first b__last)
                           (= (- a__last a__first) (- b__last b__first)))
                           (< b__last b__first))
                           (forall ((temp___idx_78 Int))
                           (=>
                           (and (<= a__first temp___idx_78)
                           (<= temp___idx_78 a__last))
                           (= (to_rep (select a temp___idx_78)) (to_rep
                                                                (select b (+ (- b__first a__first) temp___idx_78)))))))
                      true false))

;; bool_eq_rev
  (assert
  (forall ((a (Array Int character)) (b (Array Int character)))
  (forall ((a__first Int) (a__last Int) (b__first Int) (b__last Int))
  (=> (= (bool_eq1 b b__first b__last a a__first a__last) true)
  (and
  (ite (<= a__first a__last)
  (and (<= b__first b__last) (= (- a__last a__first) (- b__last b__first)))
  (< b__last b__first))
  (forall ((temp___idx_78 Int))
  (=> (and (<= a__first temp___idx_78) (<= temp___idx_78 a__last))
  (= (to_rep (select a temp___idx_78)) (to_rep
                                       (select b (+ (- b__first a__first) temp___idx_78)))))))))))

(declare-fun compare ((Array Int character) Int Int (Array Int character) Int
  Int) Int)

;; compare_def_eq
  (assert
  (forall ((a (Array Int character)) (b (Array Int character)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (! (= (= (compare a a_first a_last b b_first b_last) 0)
     (= (bool_eq1 a a_first a_last b b_first b_last) true)) :pattern (
  (compare a a_first a_last b b_first b_last)) ))))

;; compare_def_lt
  (assert
  (forall ((a (Array Int character)) (b (Array Int character)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (! (= (< (compare a a_first a_last b b_first b_last) 0)
     (exists ((i Int) (j Int))
     (and (<= i a_last)
     (and (< j b_last)
     (and (= (bool_eq1 a a_first i b b_first j) true)
     (or (= i a_last)
     (and (< i a_last)
     (< (to_rep (select a (+ i 1))) (to_rep (select b (+ j 1))))))))))) :pattern (
  (compare a a_first a_last b b_first b_last)) ))))

;; compare_def_gt
  (assert
  (forall ((a (Array Int character)) (b (Array Int character)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (! (= (< 0 (compare a a_first a_last b b_first b_last))
     (exists ((i Int) (j Int))
     (and (<= i b_last)
     (and (< j a_last)
     (and (= (bool_eq1 a a_first j b b_first i) true)
     (or (= i b_last)
     (and (< i b_last)
     (< (to_rep (select b (+ i 1))) (to_rep (select a (+ j 1))))))))))) :pattern (
  (compare a a_first a_last b b_first b_last)) ))))

(declare-fun to_rep1 (integer) Int)

(declare-fun of_rep1 (Int) integer)

;; inversion_axiom
  (assert
  (forall ((x integer))
  (! (= (of_rep1 (to_rep1 x)) x) :pattern ((to_rep1 x)) )))

;; range_axiom
  (assert
  (forall ((x integer)) (! (in_range2 (to_rep1 x)) :pattern ((to_rep1 x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range2 x) (= (to_rep1 (of_rep1 x)) x)) :pattern ((to_rep1
                                                              (of_rep1 x))) )))

(declare-sort t1 0)

(declare-fun first (t1) integer)

(declare-fun last (t1) integer)

(declare-fun mk (Int Int) t1)

;; mk_def
  (assert
  (forall ((f Int) (l Int))
  (! (=> (in_range2 f)
     (=> (in_range2 l)
     (and (= (to_rep1 (first (mk f l))) f) (= (to_rep1 (last (mk f l))) l)))) :pattern (
  (mk f l)) )))

(define-fun dynamic_property ((range_first Int) (range_last Int) (low Int)
  (high Int)) Bool (and (in_range2 low)
                   (and (in_range2 high)
                   (=> (<= low high) (and (in_range3 low) (in_range3 high))))))

(declare-datatypes ((us_t 0))
(((mk___t (elts (Array Int character))(rt t1)))))
(define-fun to_array ((a us_t)) (Array Int character) (elts a))

(define-fun of_array ((a (Array Int character)) (f Int)
  (l Int)) us_t (mk___t a (mk f l)))

(define-fun first1 ((a us_t)) Int (to_rep1 (first (rt a))))

(define-fun last1 ((a us_t)) Int (to_rep1 (last (rt a))))

(define-fun length ((a us_t)) Int (ite (<= (first1 a) (last1 a))
                                  (+ (- (last1 a) (first1 a)) 1) 0))

(declare-const value__size Int)

(declare-fun object__size ((Array Int character)) Int)

(declare-const value__component__size Int)

(declare-fun object__component__size ((Array Int character)) Int)

(declare-const value__alignment Int)

(declare-fun object__alignment ((Array Int character)) Int)

;; value__size_axiom
  (assert (<= 0 value__size))

;; object__size_axiom
  (assert (forall ((a (Array Int character))) (<= 0 (object__size a))))

;; value__component__size_axiom
  (assert (<= 0 value__component__size))

;; object__component__size_axiom
  (assert
  (forall ((a (Array Int character))) (<= 0 (object__component__size a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment))

;; object__alignment_axiom
  (assert (forall ((a (Array Int character))) (<= 0 (object__alignment a))))

(define-fun bool_eq2 ((x us_t)
  (y us_t)) Bool (bool_eq1 (elts x) (to_rep1 (first (rt x)))
                 (to_rep1 (last (rt x))) (elts y) (to_rep1 (first (rt y)))
                 (to_rep1 (last (rt y)))))

(declare-fun user_eq3 (us_t us_t) Bool)

(declare-const dummy3 us_t)

(declare-fun to_string (us_image) us_t)

(declare-fun from_string (us_t) us_image)

(declare-datatypes ((string__ref 0))
(((mk_string__ref (string__content us_t)))))
(define-fun string__ref___projection ((a string__ref)) us_t (string__content
                                                            a))

(declare-sort float 0)

(define-fun bool_eq3 ((x t) (y t)) Bool (ite (eq x y) true false))

(declare-fun user_eq4 (float float) Bool)

(declare-fun attr__ATTRIBUTE_IMAGE4 (t) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check4 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE4 (us_image) t)

(declare-const dummy4 float)

(declare-datatypes ((float__ref 0))
(((mk_float__ref (float__content float)))))
(define-fun float__ref___projection ((a float__ref)) float (float__content a))

(declare-const fliteral1 t)

;; fliteral_axiom
  (assert
  (and (tqtisFinite fliteral1)
  (= (tqtreal fliteral1) 340282346638528859811704183484516925440.0)))

(define-fun dynamic_invariant ((temp___expr_51 t) (temp___is_init_48 Bool)
  (temp___skip_constant_49 Bool)
  (temp___do_toplevel_50 Bool)) Bool (=>
                                     (or (= temp___is_init_48 true) (le
                                     (neg fliteral1) fliteral1)) (tqtisFinite
                                     temp___expr_51)))

(declare-fun sin1 (t) t)

(declare-fun sin__function_guard (t t) Bool)

(declare-fun approx_sin (t) t)

(declare-fun approx_sin__function_guard (t t) Bool)

(declare-const fliteral2 t)

;; fliteral_axiom
  (assert
  (and (tqtisFinite fliteral2)
  (= (tqtreal fliteral2) (/ 3000000106112565845251083374023437500.0 1000000000000000000000000000000000000000000.0))))

;; sin__post_axiom
  (assert
  (forall ((x t))
  (! (=>
     (and (dynamic_invariant x true true true)
     (and (le (neg fliteral) x) (le x fliteral)))
     (let ((result (sin1 x)))
     (and (lt (abs1 (sub RNE1 result (approx_sin x))) fliteral2)
     (dynamic_invariant result true false true)))) :pattern ((sin1 x)) )))

(declare-fun cos1 (t) t)

(declare-fun cos__function_guard (t t) Bool)

(declare-fun approx_cos (t) t)

(declare-fun approx_cos__function_guard (t t) Bool)

;; cos__post_axiom
  (assert
  (forall ((x t))
  (! (=>
     (and (dynamic_invariant x true true true)
     (and (le (neg fliteral) x) (le x fliteral)))
     (let ((result (cos1 x)))
     (and (lt (abs1 (sub RNE1 result (approx_cos x))) fliteral2)
     (dynamic_invariant result true false true)))) :pattern ((cos1 x)) )))

(declare-fun tan1 (t) t)

(declare-fun tan__function_guard (t t) Bool)

(declare-fun approx_tan (t) t)

(declare-fun approx_tan__function_guard (t t) Bool)

(declare-const fliteral3 t)

;; fliteral_axiom
  (assert
  (and (tqtisFinite fliteral3)
  (= (tqtreal fliteral3) (/ 500000000000000000000000.0 1000000000000000000000000.0))))

(declare-const fliteral4 t)

;; fliteral_axiom
  (assert
  (and (tqtisFinite fliteral4)
  (= (tqtreal fliteral4) (/ 999999974737875163555145263671875.0 10000000000000000000000000000000000000.0))))

;; tan__post_axiom
  (assert
  (forall ((x t))
  (! (=>
     (and (dynamic_invariant x true true true)
     (and (le (neg fliteral3) x) (le x fliteral3)))
     (let ((result (tan1 x)))
     (and (lt (abs1 (sub RNE1 result (approx_tan x))) fliteral4)
     (dynamic_invariant result true false true)))) :pattern ((tan1 x)) )))

(declare-const attr__ATTRIBUTE_ADDRESS Int)

(declare-const attr__ATTRIBUTE_ADDRESS1 Int)

(declare-fun temp___String_Literal_517 (tuple0) (Array Int character))

;; temp___String_Literal_517__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_517 us_void_param) 1)) 116)
     (= (to_rep (select (temp___String_Literal_517 us_void_param) 2)) 101))
     (= (to_rep (select (temp___String_Literal_517 us_void_param) 3)) 115))
     (= (to_rep (select (temp___String_Literal_517 us_void_param) 4)) 116))
     (= (to_rep (select (temp___String_Literal_517 us_void_param) 5)) 32))
     (= (to_rep (select (temp___String_Literal_517 us_void_param) 6)) 115))
     (= (to_rep (select (temp___String_Literal_517 us_void_param) 7)) 105))
     (= (to_rep (select (temp___String_Literal_517 us_void_param) 8)) 110)) :pattern (
  (temp___String_Literal_517 us_void_param)) )))

(declare-fun temp___String_Literal_520 (tuple0) (Array Int character))

;; temp___String_Literal_520__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_520 us_void_param) 1)) 116)
     (= (to_rep (select (temp___String_Literal_520 us_void_param) 2)) 101))
     (= (to_rep (select (temp___String_Literal_520 us_void_param) 3)) 115))
     (= (to_rep (select (temp___String_Literal_520 us_void_param) 4)) 116))
     (= (to_rep (select (temp___String_Literal_520 us_void_param) 5)) 32))
     (= (to_rep (select (temp___String_Literal_520 us_void_param) 6)) 115))
     (= (to_rep (select (temp___String_Literal_520 us_void_param) 7)) 105))
     (= (to_rep (select (temp___String_Literal_520 us_void_param) 8)) 110))
     (= (to_rep (select (temp___String_Literal_520 us_void_param) 9)) 32))
     (= (to_rep (select (temp___String_Literal_520 us_void_param) 10)) 111))
     (= (to_rep (select (temp___String_Literal_520 us_void_param) 11)) 107)) :pattern (
  (temp___String_Literal_520 us_void_param)) )))

(declare-fun temp___String_Literal_521 (tuple0) (Array Int character))

;; temp___String_Literal_521__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_521 us_void_param) 1)) 116)
     (= (to_rep (select (temp___String_Literal_521 us_void_param) 2)) 101))
     (= (to_rep (select (temp___String_Literal_521 us_void_param) 3)) 115))
     (= (to_rep (select (temp___String_Literal_521 us_void_param) 4)) 116))
     (= (to_rep (select (temp___String_Literal_521 us_void_param) 5)) 32))
     (= (to_rep (select (temp___String_Literal_521 us_void_param) 6)) 99))
     (= (to_rep (select (temp___String_Literal_521 us_void_param) 7)) 111))
     (= (to_rep (select (temp___String_Literal_521 us_void_param) 8)) 115)) :pattern (
  (temp___String_Literal_521 us_void_param)) )))

(declare-fun temp___String_Literal_524 (tuple0) (Array Int character))

;; temp___String_Literal_524__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_524 us_void_param) 1)) 116)
     (= (to_rep (select (temp___String_Literal_524 us_void_param) 2)) 101))
     (= (to_rep (select (temp___String_Literal_524 us_void_param) 3)) 115))
     (= (to_rep (select (temp___String_Literal_524 us_void_param) 4)) 116))
     (= (to_rep (select (temp___String_Literal_524 us_void_param) 5)) 32))
     (= (to_rep (select (temp___String_Literal_524 us_void_param) 6)) 99))
     (= (to_rep (select (temp___String_Literal_524 us_void_param) 7)) 111))
     (= (to_rep (select (temp___String_Literal_524 us_void_param) 8)) 115))
     (= (to_rep (select (temp___String_Literal_524 us_void_param) 9)) 32))
     (= (to_rep (select (temp___String_Literal_524 us_void_param) 10)) 111))
     (= (to_rep (select (temp___String_Literal_524 us_void_param) 11)) 107)) :pattern (
  (temp___String_Literal_524 us_void_param)) )))

(declare-fun temp___String_Literal_525 (tuple0) (Array Int character))

;; temp___String_Literal_525__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_525 us_void_param) 1)) 116)
     (= (to_rep (select (temp___String_Literal_525 us_void_param) 2)) 101))
     (= (to_rep (select (temp___String_Literal_525 us_void_param) 3)) 115))
     (= (to_rep (select (temp___String_Literal_525 us_void_param) 4)) 116))
     (= (to_rep (select (temp___String_Literal_525 us_void_param) 5)) 32))
     (= (to_rep (select (temp___String_Literal_525 us_void_param) 6)) 116))
     (= (to_rep (select (temp___String_Literal_525 us_void_param) 7)) 97))
     (= (to_rep (select (temp___String_Literal_525 us_void_param) 8)) 110)) :pattern (
  (temp___String_Literal_525 us_void_param)) )))

(declare-fun temp___String_Literal_528 (tuple0) (Array Int character))

;; temp___String_Literal_528__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_528 us_void_param) 1)) 116)
     (= (to_rep (select (temp___String_Literal_528 us_void_param) 2)) 101))
     (= (to_rep (select (temp___String_Literal_528 us_void_param) 3)) 115))
     (= (to_rep (select (temp___String_Literal_528 us_void_param) 4)) 116))
     (= (to_rep (select (temp___String_Literal_528 us_void_param) 5)) 32))
     (= (to_rep (select (temp___String_Literal_528 us_void_param) 6)) 116))
     (= (to_rep (select (temp___String_Literal_528 us_void_param) 7)) 97))
     (= (to_rep (select (temp___String_Literal_528 us_void_param) 8)) 110))
     (= (to_rep (select (temp___String_Literal_528 us_void_param) 9)) 32))
     (= (to_rep (select (temp___String_Literal_528 us_void_param) 10)) 111))
     (= (to_rep (select (temp___String_Literal_528 us_void_param) 11)) 107)) :pattern (
  (temp___String_Literal_528 us_void_param)) )))

(declare-fun temp___String_Literal_529 (tuple0) (Array Int character))

;; temp___String_Literal_529__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 1)) 116)
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 2)) 101))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 3)) 115))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 4)) 116))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 5)) 32))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 6)) 116))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 7)) 97))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 8)) 110))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 9)) 32))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 10)) 61))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 11)) 32))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 12)) 115))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 13)) 105))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 14)) 110))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 15)) 32))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 16)) 47))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 17)) 32))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 18)) 99))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 19)) 111))
     (= (to_rep (select (temp___String_Literal_529 us_void_param) 20)) 115)) :pattern (
  (temp___String_Literal_529 us_void_param)) )))

(declare-fun temp___String_Literal_531 (tuple0) (Array Int character))

;; temp___String_Literal_531__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 1)) 116)
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 2)) 101))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 3)) 115))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 4)) 116))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 5)) 32))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 6)) 116))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 7)) 97))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 8)) 110))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 9)) 32))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 10)) 61))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 11)) 32))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 12)) 115))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 13)) 105))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 14)) 110))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 15)) 32))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 16)) 47))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 17)) 32))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 18)) 99))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 19)) 111))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 20)) 115))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 21)) 32))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 22)) 111))
     (= (to_rep (select (temp___String_Literal_531 us_void_param) 23)) 107)) :pattern (
  (temp___String_Literal_531 us_void_param)) )))

(define-fun dynamic_invariant1 ((temp___expr_39 Int) (temp___is_init_36 Bool)
  (temp___skip_constant_37 Bool)
  (temp___do_toplevel_38 Bool)) Bool (=>
                                     (or (= temp___is_init_36 true)
                                     (<= 1 2147483647)) (in_range3
                                     temp___expr_39)))

(define-fun dynamic_invariant2 ((temp___expr_63 Int) (temp___is_init_60 Bool)
  (temp___skip_constant_61 Bool)
  (temp___do_toplevel_62 Bool)) Bool (=>
                                     (or (= temp___is_init_60 true)
                                     (<= 0 255)) (in_range4 temp___expr_63)))

(define-fun dynamic_invariant3 ((temp___expr_82 us_t)
  (temp___is_init_79 Bool) (temp___skip_constant_80 Bool)
  (temp___do_toplevel_81 Bool)) Bool (=>
                                     (not (= temp___skip_constant_80 true))
                                     (dynamic_property 1 2147483647
                                     (first1 temp___expr_82)
                                     (last1 temp___expr_82))))

(define-fun dynamic_invariant4 ((temp___expr_15 Int) (temp___is_init_12 Bool)
  (temp___skip_constant_13 Bool)
  (temp___do_toplevel_14 Bool)) Bool (=>
                                     (or (= temp___is_init_12 true)
                                     (<= (- 2147483648) 2147483647))
                                     (in_range2 temp___expr_15)))

(declare-fun pow21 (t) t)

(declare-fun pow2__function_guard (t t) Bool)

;; pow2__post_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true) (dynamic_invariant (pow21 x)
     true false true)) :pattern ((pow21 x)) )))

;; pow2__def_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true) (= (pow21 x) (mul RNE1 x x))) :pattern (
  (pow21 x)) )))

(declare-fun pow3 (t) t)

(declare-fun pow3__function_guard (t t) Bool)

;; pow3__post_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true) (dynamic_invariant (pow3 x)
     true false true)) :pattern ((pow3 x)) )))

;; pow3__def_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true)
     (= (pow3 x) (mul RNE1 (mul RNE1 x x) x))) :pattern ((pow3 x)) )))

(declare-fun pow4 (t) t)

(declare-fun pow4__function_guard (t t) Bool)

;; pow4__post_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true) (dynamic_invariant (pow4 x)
     true false true)) :pattern ((pow4 x)) )))

;; pow4__def_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true)
     (= (pow4 x) (mul RNE1 (mul RNE1 (mul RNE1 x x) x) x))) :pattern (
  (pow4 x)) )))

(declare-fun pow5 (t) t)

(declare-fun pow5__function_guard (t t) Bool)

;; pow5__post_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true) (dynamic_invariant (pow5 x)
     true false true)) :pattern ((pow5 x)) )))

;; pow5__def_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true)
     (= (pow5 x) (mul RNE1 (mul RNE1 (mul RNE1 (mul RNE1 x x) x) x) x))) :pattern (
  (pow5 x)) )))

(declare-fun pow6 (t) t)

(declare-fun pow6__function_guard (t t) Bool)

;; pow6__post_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true) (dynamic_invariant (pow6 x)
     true false true)) :pattern ((pow6 x)) )))

;; pow6__def_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true)
     (= (pow6 x) (mul RNE1
                 (mul RNE1 (mul RNE1 (mul RNE1 (mul RNE1 x x) x) x) x) x))) :pattern (
  (pow6 x)) )))

(declare-fun pow7 (t) t)

(declare-fun pow7__function_guard (t t) Bool)

;; pow7__post_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true) (dynamic_invariant (pow7 x)
     true false true)) :pattern ((pow7 x)) )))

;; pow7__def_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true)
     (= (pow7 x) (mul RNE1
                 (mul RNE1
                 (mul RNE1 (mul RNE1 (mul RNE1 (mul RNE1 x x) x) x) x) x) x))) :pattern (
  (pow7 x)) )))

(declare-fun pow8 (t) t)

(declare-fun pow8__function_guard (t t) Bool)

;; pow8__post_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true) (dynamic_invariant (pow8 x)
     true false true)) :pattern ((pow8 x)) )))

;; pow8__def_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true)
     (= (pow8 x) (mul RNE1
                 (mul RNE1
                 (mul RNE1
                 (mul RNE1 (mul RNE1 (mul RNE1 (mul RNE1 x x) x) x) x) x) x)
                 x))) :pattern ((pow8 x)) )))

(declare-fun pow9 (t) t)

(declare-fun pow9__function_guard (t t) Bool)

;; pow9__post_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true) (dynamic_invariant (pow9 x)
     true false true)) :pattern ((pow9 x)) )))

;; pow9__def_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true)
     (= (pow9 x) (mul RNE1
                 (mul RNE1
                 (mul RNE1
                 (mul RNE1
                 (mul RNE1 (mul RNE1 (mul RNE1 (mul RNE1 x x) x) x) x) x) x)
                 x) x))) :pattern ((pow9 x)) )))

;; approx_sin__post_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true) (dynamic_invariant
     (approx_sin x) true false true)) :pattern ((approx_sin x)) )))

(declare-const fliteral5 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral5) (= (tqtreal fliteral5) 6.0)))

(declare-const fliteral6 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral6) (= (tqtreal fliteral6) 120.0)))

(declare-const fliteral7 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral7) (= (tqtreal fliteral7) 5040.0)))

;; approx_sin__def_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true)
     (= (approx_sin x) (sub RNE1
                       (add RNE1 (sub RNE1 x (div1 RNE1 (pow3 x) fliteral5))
                       (div1 RNE1 (pow5 x) fliteral6))
                       (div1 RNE1 (pow7 x) fliteral7)))) :pattern ((approx_sin
                                                                   x)) )))

;; approx_cos__post_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true) (dynamic_invariant
     (approx_cos x) true false true)) :pattern ((approx_cos x)) )))

(declare-const fliteral8 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral8) (= (tqtreal fliteral8) 2.0)))

(declare-const fliteral9 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral9) (= (tqtreal fliteral9) 24.0)))

(declare-const fliteral10 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral10) (= (tqtreal fliteral10) 720.0)))

(declare-const fliteral11 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral11) (= (tqtreal fliteral11) 40320.0)))

;; approx_cos__def_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true)
     (= (approx_cos x) (add RNE1
                       (sub RNE1
                       (add RNE1
                       (sub RNE1 fliteral (div1 RNE1 (pow21 x) fliteral8))
                       (div1 RNE1 (pow4 x) fliteral9))
                       (div1 RNE1 (pow6 x) fliteral10))
                       (div1 RNE1 (pow8 x) fliteral11)))) :pattern ((approx_cos
                                                                    x)) )))

;; approx_tan__post_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true) (dynamic_invariant
     (approx_tan x) true false true)) :pattern ((approx_tan x)) )))

(declare-const fliteral12 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral12) (= (tqtreal fliteral12) 3.0)))

(declare-const fliteral13 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral13) (= (tqtreal fliteral13) 15.0)))

(declare-const fliteral14 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral14) (= (tqtreal fliteral14) 17.0)))

(declare-const fliteral15 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral15) (= (tqtreal fliteral15) 315.0)))

(declare-const fliteral16 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral16) (= (tqtreal fliteral16) 62.0)))

(declare-const fliteral17 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral17) (= (tqtreal fliteral17) 2835.0)))

;; approx_tan__def_axiom
  (assert
  (forall ((x t))
  (! (=> (dynamic_invariant x true true true)
     (= (approx_tan x) (add RNE1
                       (add RNE1
                       (add RNE1 (add RNE1 x (div1 RNE1 (pow3 x) fliteral12))
                       (div1 RNE1 (mul RNE1 fliteral8 (pow5 x)) fliteral13))
                       (div1 RNE1 (mul RNE1 fliteral14 (pow7 x)) fliteral15))
                       (div1 RNE1 (mul RNE1 fliteral16 (pow9 x)) fliteral17)))) :pattern (
  (approx_tan x)) )))

(declare-const f t)

(declare-const dummy5 t)

(declare-const temp___519 t)

(declare-const temp___518 t)

(declare-const o t)

(declare-const temp___523 t)

(declare-const temp___522 t)

(declare-const o1 t)

(declare-const temp___527 t)

(declare-const temp___526 t)

(declare-const o2 t)

(declare-const o3 t)

(declare-const dummy6 t)

(declare-const result t)

(declare-const f1 t)

(declare-const f2 t)

(declare-const dummy7 t)

(declare-const result1 t)

(declare-const dummy8 t)

(declare-const result2 t)

(declare-const f3 t)

(declare-const f4 t)

(declare-const dummy9 t)

(declare-const f5 t)

(declare-const dummy10 t)

(declare-const f6 t)

(declare-const dummy11 t)

(declare-const f7 t)

(declare-const dummy12 t)

(declare-const result3 t)

(declare-const f8 t)

(declare-const f9 t)

(declare-const dummy13 t)

(declare-const result4 t)

(declare-const dummy14 t)

(declare-const result5 t)

(declare-const f10 t)

(declare-const f11 t)

(declare-const dummy15 t)

(declare-const f12 t)

(declare-const dummy16 t)

(declare-const f13 t)

(declare-const dummy17 t)

(declare-const f14 t)

(declare-const dummy18 t)

(declare-const result6 t)

(declare-const f15 t)

(declare-const f16 t)

(declare-const dummy19 t)

(declare-const result7 t__ref)

(declare-const dummy20 t)

(declare-const result8 t__ref)

(declare-const f17 t)

(declare-const f18 t__ref)

(declare-const dummy21 t__ref)

(declare-const f19 t)

(declare-const dummy22 t)

(declare-const f20 t__ref)

(declare-const dummy23 t__ref)

(declare-const f21 t)

(declare-const dummy24 t)

(declare-const result9 t__ref)

(declare-const f22 t)

(declare-const f23 t)

(define-fun dummy25 () t__ref (mk_t__ref dummy17))

(define-fun dummy26 () t__ref (mk_t__ref dummy11))

;; H
  (assert (=> (le (neg fliteral1) fliteral1) (tqtisFinite f)))

;; H
  (assert (=> (le (neg fliteral1) fliteral1) (tqtisFinite dummy5)))

;; H
  (assert (= result f))

;; H
  (assert (= f1 (neg fliteral)))

;; H
  (assert (=> (le f1 fliteral) (= temp___519 dummy5)))

;; H
  (assert (=> (le f1 fliteral) (= temp___518 f1)))

;; H
  (assert
  (=> (le f1 fliteral)
  (and
  (and (=> (le (neg fliteral1) fliteral1) (tqtisFinite f2))
  (=> (le (neg fliteral1) fliteral1) (tqtisFinite dummy7))) (le f2 fliteral))))

;; H
  (assert
  (=> (le f1 fliteral)
  (and (= o (sin1 f2))
  (and (tqtisFinite o) (lt (abs1 (sub RNE1 o (approx_sin f2))) fliteral2)))))

;; H
  (assert (=> (le f1 fliteral) (= dummy7 result1)))

;; H
  (assert (=> (le f1 fliteral) (= dummy8 o)))

;; H
  (assert (=> (le f1 fliteral) (= result2 f2)))

;; H
  (assert (=> (le f1 fliteral) (= f3 (next_representable f2))))

;; H
  (assert (=> (le f1 fliteral) (not (le f3 fliteral))))

;; H
  (assert (=> (le f1 fliteral) (= dummy8 dummy9)))

;; H
  (assert (=> (le f1 fliteral) (= f3 f4)))

;; H
  (assert (=> (le f1 fliteral) (= dummy10 dummy8)))

;; H
  (assert (=> (le f1 fliteral) (= f5 f3)))

;; H
  (assert (=> (le f1 fliteral) (= dummy26 (mk_t__ref dummy9))))

;; H
  (assert (=> (le f1 fliteral) (= (mk_t__ref f6) (mk_t__ref f4))))

;; H
  (assert (=> (le f1 fliteral) (= dummy12 dummy10)))

;; H
  (assert (=> (le f1 fliteral) (= f7 f5)))

;; H
  (assert (=> (not (le f1 fliteral)) (= dummy26 (mk_t__ref dummy5))))

;; H
  (assert (=> (not (le f1 fliteral)) (= f1 f6)))

;; H
  (assert (=> (not (le f1 fliteral)) (= dummy12 dummy6)))

;; H
  (assert (=> (not (le f1 fliteral)) (= f7 f1)))

;; H
  (assert (= result3 f6))

;; H
  (assert (= f8 (neg fliteral)))

;; H
  (assert (=> (le f8 fliteral) (= temp___523 dummy11)))

;; H
  (assert (=> (le f8 fliteral) (= temp___522 f8)))

;; H
  (assert
  (=> (le f8 fliteral)
  (and
  (and (=> (le (neg fliteral1) fliteral1) (tqtisFinite f9))
  (=> (le (neg fliteral1) fliteral1) (tqtisFinite dummy13))) (le f9
  fliteral))))

;; H
  (assert
  (=> (le f8 fliteral)
  (and (= o1 (cos1 f9))
  (and (tqtisFinite o1) (lt (abs1 (sub RNE1 o1 (approx_cos f9))) fliteral2)))))

;; H
  (assert (=> (le f8 fliteral) (= dummy13 result4)))

;; H
  (assert (=> (le f8 fliteral) (= dummy14 o1)))

;; H
  (assert (=> (le f8 fliteral) (= result5 f9)))

;; H
  (assert (=> (le f8 fliteral) (= f10 (next_representable f9))))

;; H
  (assert (=> (le f8 fliteral) (not (le f10 fliteral))))

;; H
  (assert (=> (le f8 fliteral) (= dummy14 dummy15)))

;; H
  (assert (=> (le f8 fliteral) (= f10 f11)))

;; H
  (assert (=> (le f8 fliteral) (= dummy16 dummy14)))

;; H
  (assert (=> (le f8 fliteral) (= f12 f10)))

;; H
  (assert (=> (le f8 fliteral) (= dummy25 (mk_t__ref dummy15))))

;; H
  (assert (=> (le f8 fliteral) (= (mk_t__ref f13) (mk_t__ref f11))))

;; H
  (assert (=> (le f8 fliteral) (= dummy18 dummy16)))

;; H
  (assert (=> (le f8 fliteral) (= f14 f12)))

;; H
  (assert (=> (not (le f8 fliteral)) (= dummy25 dummy26)))

;; H
  (assert (=> (not (le f8 fliteral)) (= f8 f13)))

;; H
  (assert (=> (not (le f8 fliteral)) (= dummy18 dummy12)))

;; H
  (assert (=> (not (le f8 fliteral)) (= f14 f8)))

;; H
  (assert (= result6 f13))

;; H
  (assert (= f15 (neg fliteral3)))

;; H
  (assert (=> (le f15 fliteral3) (= temp___527 dummy17)))

;; H
  (assert (=> (le f15 fliteral3) (= temp___526 f15)))

;; H
  (assert
  (=> (le f15 fliteral3)
  (and
  (and (=> (le (neg fliteral1) fliteral1) (tqtisFinite f16))
  (=> (le (neg fliteral1) fliteral1) (tqtisFinite dummy19))) (le f16
  fliteral3))))

;; H
  (assert
  (=> (le f15 fliteral3)
  (and (= o2 (tan1 f16))
  (and (tqtisFinite o2) (lt (abs1 (sub RNE1 o2 (approx_tan f16))) fliteral4)))))

;; H
  (assert (=> (le f15 fliteral3) (= result7 (mk_t__ref dummy19))))

;; H
  (assert (=> (le f15 fliteral3) (= dummy20 o2)))

;; H
  (assert (=> (le f15 fliteral3) (= result8 (mk_t__ref f16))))

;; H
  (assert (=> (le f15 fliteral3) (= f17 (next_representable f16))))

;; H
  (assert (=> (le f15 fliteral3) (not (le f17 fliteral3))))

;; H
  (assert (=> (le f15 fliteral3) (= dummy21 (mk_t__ref dummy20))))

;; H
  (assert (=> (le f15 fliteral3) (= f18 (mk_t__ref f17))))

;; H
  (assert (=> (le f15 fliteral3) (= dummy22 dummy20)))

;; H
  (assert (=> (le f15 fliteral3) (= f19 f17)))

;; H
  (assert (=> (le f15 fliteral3) (= dummy23 dummy21)))

;; H
  (assert (=> (le f15 fliteral3) (= f20 f18)))

;; H
  (assert (=> (le f15 fliteral3) (= dummy24 dummy22)))

;; H
  (assert (=> (le f15 fliteral3) (= f21 f19)))

;; H
  (assert (=> (not (le f15 fliteral3)) (= dummy23 dummy25)))

;; H
  (assert (=> (not (le f15 fliteral3)) (= f20 (mk_t__ref f15))))

;; H
  (assert (=> (not (le f15 fliteral3)) (= dummy24 dummy18)))

;; H
  (assert (=> (not (le f15 fliteral3)) (= f21 f15)))

;; H
  (assert (= result9 f20))

;; H
  (assert (= f22 (neg fliteral3)))

;; H
  (assert (le f22 fliteral3))

;; H
  (assert
  (and (=> (le (neg fliteral1) fliteral1) (tqtisFinite f23)) (le f23
  fliteral3)))

;; H
  (assert
  (and (= o3 (cos1 f23))
  (and (tqtisFinite o3) (lt (abs1 (sub RNE1 o3 (approx_cos f23))) fliteral2))))

(assert
;; WP_parameter_def
 ;; File "test_trigo.adb", line 5, characters 0-0
  (not (le (neg fliteral) f23)))
(check-sat)
(exit)
