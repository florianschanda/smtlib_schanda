;; produced by cvc4_16.drv ;;
(set-info :smt-lib-version 2.6)
(set-logic AUFBVFPDTNIRA)
(set-info :source |VC generated by SPARK 2014|)
(set-info :category industrial)
(set-info :status unknown)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
(define-fun fp.isFinite32 ((x Float32)) Bool (not (or (fp.isInfinite x) (fp.isNaN x))))
(declare-datatypes ((tuple0 0)) (((Tuple0))))
(declare-sort us_private 0)

(declare-fun private__bool_eq (us_private us_private) Bool)

(declare-const us_null_ext__ us_private)

(declare-sort us_type_of_heap 0)

(declare-datatypes ((us_type_of_heap__ref 0))
(((mk___type_of_heap__ref (us_type_of_heap__content us_type_of_heap)))))
(declare-sort us_image 0)

(declare-datatypes ((int__ref 0)) (((mk_int__ref (int__content Int)))))
(declare-datatypes ((bool__ref 0)) (((mk_bool__ref (bool__content Bool)))))
(declare-datatypes ((real__ref 0)) (((mk_real__ref (real__content Real)))))
(declare-datatypes ((us_private__ref 0))
(((mk___private__ref (us_private__content us_private)))))
(define-fun int__ref___projection ((a int__ref)) Int (int__content a))

(define-fun bool__ref___projection ((a bool__ref)) Bool (bool__content a))

(define-fun real__ref___projection ((a real__ref)) Real (real__content a))

(define-fun us_private__ref___projection ((a us_private__ref)) us_private
  (us_private__content a))

(declare-sort natural 0)

(define-fun in_range ((x Int)) Bool (and (<= 0 x) (<= x 2147483647)))

(declare-fun attr__ATTRIBUTE_IMAGE (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE (us_image) Int)

(declare-fun user_eq (natural natural) Bool)

(declare-const dummy natural)

(declare-datatypes ((natural__ref 0))
(((mk_natural__ref (natural__content natural)))))
(define-fun natural__ref___projection ((a natural__ref)) natural (natural__content
                                                                 a))

(declare-fun to_rep (natural) Int)

(declare-fun of_rep (Int) natural)

;; inversion_axiom
  (assert
  (forall ((x natural)) (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; range_axiom
  (assert
  (forall ((x natural)) (! (in_range (to_rep x)) :pattern ((to_rep x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep
                                                           (of_rep x))) )))

(declare-sort fibonacci_argument_type 0)

(define-fun in_range1 ((x Int)) Bool (and (<= 0 x) (<= x 46)))

(declare-fun attr__ATTRIBUTE_IMAGE1 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check1 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE1 (us_image) Int)

(declare-fun user_eq1 (fibonacci_argument_type fibonacci_argument_type) Bool)

(declare-const dummy1 fibonacci_argument_type)

(declare-datatypes ((fibonacci_argument_type__ref 0))
(((mk_fibonacci_argument_type__ref
  (fibonacci_argument_type__content fibonacci_argument_type)))))
(define-fun fibonacci_argument_type__ref___projection ((a fibonacci_argument_type__ref)) fibonacci_argument_type
  (fibonacci_argument_type__content a))

(define-fun dynamic_invariant ((temp___expr_185 Int)
  (temp___is_init_182 Bool) (temp___skip_constant_183 Bool)
  (temp___do_toplevel_184 Bool)) Bool (=>
                                      (or (= temp___is_init_182 true)
                                      (<= 0 46)) (in_range1 temp___expr_185)))

(declare-fun fib (Int) Int)

(declare-fun fib__function_guard (Int Int) Bool)

(declare-fun pow2 (Int) Int)

(define-fun is_plus_infinity ((x Float32)) Bool (and (fp.isInfinite  x)
                                                (fp.isPositive  x)))

(define-fun is_minus_infinity ((x Float32)) Bool (and (fp.isInfinite  x)
                                                 (fp.isNegative  x)))

(define-fun is_plus_zero ((x Float32)) Bool (and (fp.isZero      x)
                                            (fp.isPositive  x)))

(define-fun is_minus_zero ((x Float32)) Bool (and (fp.isZero      x)
                                             (fp.isNegative  x)))

(declare-fun of_int (RoundingMode Int) Float32)

(declare-fun to_int1 (RoundingMode Float32) Int)

(declare-fun round (RoundingMode Real) Real)

(declare-const max_int Int)

(define-fun in_range2 ((x Real)) Bool (and
                                      (<= (- (* 33554430.0 10141204801825835211973625643008.0)) x)
                                      (<= x (* 33554430.0 10141204801825835211973625643008.0))))

(define-fun in_int_range ((i Int)) Bool (and (<= (- max_int) i)
                                        (<= i max_int)))

(define-fun no_overflow ((m RoundingMode) (x Real)) Bool (in_range2
  (round m x)))

(define-fun in_safe_int_range ((i Int)) Bool (and (<= (- 16777216) i)
                                             (<= i 16777216)))

(define-fun same_sign ((x Float32)
  (y Float32)) Bool (or (and (fp.isPositive  x) (fp.isPositive  y))
                    (and (fp.isNegative  x) (fp.isNegative  y))))

(define-fun diff_sign ((x Float32)
  (y Float32)) Bool (or (and (fp.isPositive  x) (fp.isNegative  y))
                    (and (fp.isNegative  x) (fp.isPositive  y))))

(define-fun product_sign ((z Float32) (x Float32)
  (y Float32)) Bool (and (=> (same_sign x y) (fp.isPositive  z))
                    (=> (diff_sign x y) (fp.isNegative  z))))

(define-fun sqr ((x Real)) Real (* x x))

(declare-fun sqrt (Real) Real)

(define-fun same_sign_real ((x Float32)
  (r Real)) Bool (or (and (fp.isPositive  x) (< 0.0 r))
                 (and (fp.isNegative  x) (< r 0.0))))

(declare-fun is_int1 (Float32) Bool)

(declare-datatypes ((t__ref 0)) (((mk_t__ref (t__content Float32)))))
(declare-fun power (Float32 Int) Float32)

;; Power_0
  (assert
  (forall ((x Float32))
  (=> (fp.isFinite32 x) (fp.eq (power x 0) (of_int RNE 1)))))

;; Power_1
  (assert
  (forall ((x Float32)) (=> (fp.isFinite32 x) (fp.eq (power x 1) x))))

;; Power_2
  (assert
  (forall ((x Float32))
  (=> (fp.isFinite32 x) (fp.eq (power x 2) (fp.mul RNE x x)))))

;; Power_3
  (assert
  (forall ((x Float32))
  (=> (fp.isFinite32 x) (fp.eq (power x 3) (fp.mul RNE x (fp.mul RNE x x))))))

;; Power_neg1
  (assert
  (forall ((x Float32))
  (=> (fp.isFinite32 x)
  (=> (not (fp.isZero      x))
  (fp.eq (power x (- 1)) (fp.div RNE (of_int RNE 1) x))))))

;; Power_neg2
  (assert
  (forall ((x Float32))
  (=> (fp.isFinite32 x)
  (=> (not (fp.isZero      x))
  (fp.eq (power x (- 2)) (fp.div RNE (of_int RNE 1) (power x 2)))))))

;; Power_neg3
  (assert
  (forall ((x Float32))
  (=> (fp.isFinite32 x)
  (=> (not (fp.isZero      x))
  (fp.eq (power x (- 2)) (fp.div RNE (of_int RNE 1) (power x 3)))))))

(define-fun dynamic_invariant1 ((temp___expr_33 Int) (temp___is_init_30 Bool)
  (temp___skip_constant_31 Bool)
  (temp___do_toplevel_32 Bool)) Bool (=>
                                     (or (= temp___is_init_30 true)
                                     (<= 0 2147483647)) (in_range
                                     temp___expr_33)))

;; fib__def_axiom
  (assert
  (forall ((n Int))
  (! (=> (dynamic_invariant n true true true)
     (= (fib n) (ite (or (= n 0) (= n 1)) n (+ (fib (- n 1)) (fib (- n 2)))))) :pattern (
  (fib n)) )))

(declare-const n Int)

(declare-const attr__ATTRIBUTE_ADDRESS Int)

(declare-datatypes ((map__ref 0))
(((mk_map__ref (map__content (Array Int natural))))))
(declare-fun slide ((Array Int natural) Int Int) (Array Int natural))

;; slide_eq
  (assert
  (forall ((a (Array Int natural)))
  (forall ((first Int))
  (! (= (slide a first first) a) :pattern ((slide a first first)) ))))

;; slide_def
  (assert
  (forall ((a (Array Int natural)))
  (forall ((old_first Int))
  (forall ((new_first Int))
  (forall ((i Int))
  (! (= (select (slide a old_first new_first) i) (select a (- i (- new_first old_first)))) :pattern ((select
  (slide a old_first new_first) i)) ))))))

(declare-fun concat1 ((Array Int natural) Int Int (Array Int natural) Int
  Int) (Array Int natural))

;; concat_def
  (assert
  (forall ((a (Array Int natural)) (b (Array Int natural)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (and
     (=> (and (<= a_first i) (<= i a_last))
     (= (select (concat1 a a_first a_last b b_first b_last) i) (select a i)))
     (=> (< a_last i)
     (= (select (concat1 a a_first a_last b b_first b_last) i) (select b (+ (- i a_last) (- b_first 1)))))) :pattern ((select
  (concat1 a a_first a_last b b_first b_last) i)) )))))

(declare-fun singleton1 (natural Int) (Array Int natural))

;; singleton_def
  (assert
  (forall ((v natural))
  (forall ((i Int))
  (! (= (select (singleton1 v i) i) v) :pattern ((select (singleton1 v i) i)) ))))

(define-fun bool_eq ((a (Array Int natural)) (a__first Int) (a__last Int)
  (b (Array Int natural)) (b__first Int)
  (b__last Int)) Bool (ite (and
                           (ite (<= a__first a__last)
                           (and (<= b__first b__last)
                           (= (- a__last a__first) (- b__last b__first)))
                           (< b__last b__first))
                           (forall ((temp___idx_132 Int))
                           (=>
                           (and (<= a__first temp___idx_132)
                           (<= temp___idx_132 a__last))
                           (= (to_rep (select a temp___idx_132)) (to_rep
                                                                 (select b (+ (- b__first a__first) temp___idx_132)))))))
                      true false))

;; bool_eq_rev
  (assert
  (forall ((a (Array Int natural)) (b (Array Int natural)))
  (forall ((a__first Int) (a__last Int) (b__first Int) (b__last Int))
  (=> (= (bool_eq b b__first b__last a a__first a__last) true)
  (and
  (ite (<= a__first a__last)
  (and (<= b__first b__last) (= (- a__last a__first) (- b__last b__first)))
  (< b__last b__first))
  (forall ((temp___idx_132 Int))
  (=> (and (<= a__first temp___idx_132) (<= temp___idx_132 a__last))
  (= (to_rep (select a temp___idx_132)) (to_rep
                                        (select b (+ (- b__first a__first) temp___idx_132)))))))))))

(declare-fun compare ((Array Int natural) Int Int (Array Int natural) Int
  Int) Int)

;; compare_def_eq
  (assert
  (forall ((a (Array Int natural)) (b (Array Int natural)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (! (= (= (compare a a_first a_last b b_first b_last) 0)
     (= (bool_eq a a_first a_last b b_first b_last) true)) :pattern (
  (compare a a_first a_last b b_first b_last)) ))))

;; compare_def_lt
  (assert
  (forall ((a (Array Int natural)) (b (Array Int natural)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (! (= (< (compare a a_first a_last b b_first b_last) 0)
     (exists ((i Int) (j Int))
     (and (<= i a_last)
     (and (< j b_last)
     (and (= (bool_eq a a_first i b b_first j) true)
     (or (= i a_last)
     (and (< i a_last)
     (< (to_rep (select a (+ i 1))) (to_rep (select b (+ j 1))))))))))) :pattern (
  (compare a a_first a_last b b_first b_last)) ))))

;; compare_def_gt
  (assert
  (forall ((a (Array Int natural)) (b (Array Int natural)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (! (= (< 0 (compare a a_first a_last b b_first b_last))
     (exists ((i Int) (j Int))
     (and (<= i b_last)
     (and (< j a_last)
     (and (= (bool_eq a a_first j b b_first i) true)
     (or (= i b_last)
     (and (< i b_last)
     (< (to_rep (select b (+ i 1))) (to_rep (select a (+ j 1))))))))))) :pattern (
  (compare a a_first a_last b b_first b_last)) ))))

(declare-const lookup_table (Array Int natural))

(declare-const attr__ATTRIBUTE_ADDRESS1 Int)

(declare-fun number_theory__fibonacci2__lookup_table__aggregate_def (Int Int
  Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int
  Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int
  Int Int Int Int Int Int Int) (Array Int natural))

;; def_axiom
  (assert
  (forall ((temp___134 Int) (temp___135 Int) (temp___136 Int)
  (temp___137 Int) (temp___138 Int) (temp___139 Int) (temp___140 Int)
  (temp___141 Int) (temp___142 Int) (temp___143 Int) (temp___144 Int)
  (temp___145 Int) (temp___146 Int) (temp___147 Int) (temp___148 Int)
  (temp___149 Int) (temp___150 Int) (temp___151 Int) (temp___152 Int)
  (temp___153 Int) (temp___154 Int) (temp___155 Int) (temp___156 Int)
  (temp___157 Int) (temp___158 Int) (temp___159 Int) (temp___160 Int)
  (temp___161 Int) (temp___162 Int) (temp___163 Int) (temp___164 Int)
  (temp___165 Int) (temp___166 Int) (temp___167 Int) (temp___168 Int)
  (temp___169 Int) (temp___170 Int) (temp___171 Int) (temp___172 Int)
  (temp___173 Int) (temp___174 Int) (temp___175 Int) (temp___176 Int)
  (temp___177 Int) (temp___178 Int) (temp___179 Int) (temp___180 Int))
  (let ((temp___133 (number_theory__fibonacci2__lookup_table__aggregate_def
                    temp___134 temp___135 temp___136 temp___137 temp___138
                    temp___139 temp___140 temp___141 temp___142 temp___143
                    temp___144 temp___145 temp___146 temp___147 temp___148
                    temp___149 temp___150 temp___151 temp___152 temp___153
                    temp___154 temp___155 temp___156 temp___157 temp___158
                    temp___159 temp___160 temp___161 temp___162 temp___163
                    temp___164 temp___165 temp___166 temp___167 temp___168
                    temp___169 temp___170 temp___171 temp___172 temp___173
                    temp___174 temp___175 temp___176 temp___177 temp___178
                    temp___179 temp___180)))
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and (= (select temp___133 0) (of_rep temp___134))
  (= (select temp___133 1) (of_rep temp___135)))
  (= (select temp___133 2) (of_rep temp___136)))
  (= (select temp___133 3) (of_rep temp___137)))
  (= (select temp___133 4) (of_rep temp___138)))
  (= (select temp___133 5) (of_rep temp___139)))
  (= (select temp___133 6) (of_rep temp___140)))
  (= (select temp___133 7) (of_rep temp___141)))
  (= (select temp___133 8) (of_rep temp___142)))
  (= (select temp___133 9) (of_rep temp___143)))
  (= (select temp___133 10) (of_rep temp___144)))
  (= (select temp___133 11) (of_rep temp___145)))
  (= (select temp___133 12) (of_rep temp___146)))
  (= (select temp___133 13) (of_rep temp___147)))
  (= (select temp___133 14) (of_rep temp___148)))
  (= (select temp___133 15) (of_rep temp___149)))
  (= (select temp___133 16) (of_rep temp___150)))
  (= (select temp___133 17) (of_rep temp___151)))
  (= (select temp___133 18) (of_rep temp___152)))
  (= (select temp___133 19) (of_rep temp___153)))
  (= (select temp___133 20) (of_rep temp___154)))
  (= (select temp___133 21) (of_rep temp___155)))
  (= (select temp___133 22) (of_rep temp___156)))
  (= (select temp___133 23) (of_rep temp___157)))
  (= (select temp___133 24) (of_rep temp___158)))
  (= (select temp___133 25) (of_rep temp___159)))
  (= (select temp___133 26) (of_rep temp___160)))
  (= (select temp___133 27) (of_rep temp___161)))
  (= (select temp___133 28) (of_rep temp___162)))
  (= (select temp___133 29) (of_rep temp___163)))
  (= (select temp___133 30) (of_rep temp___164)))
  (= (select temp___133 31) (of_rep temp___165)))
  (= (select temp___133 32) (of_rep temp___166)))
  (= (select temp___133 33) (of_rep temp___167)))
  (= (select temp___133 34) (of_rep temp___168)))
  (= (select temp___133 35) (of_rep temp___169)))
  (= (select temp___133 36) (of_rep temp___170)))
  (= (select temp___133 37) (of_rep temp___171)))
  (= (select temp___133 38) (of_rep temp___172)))
  (= (select temp___133 39) (of_rep temp___173)))
  (= (select temp___133 40) (of_rep temp___174)))
  (= (select temp___133 41) (of_rep temp___175)))
  (= (select temp___133 42) (of_rep temp___176)))
  (= (select temp___133 43) (of_rep temp___177)))
  (= (select temp___133 44) (of_rep temp___178)))
  (= (select temp___133 45) (of_rep temp___179)))
  (= (select temp___133 46) (of_rep temp___180))))))

;; lookup_table__def_axiom
  (assert
  (= lookup_table (number_theory__fibonacci2__lookup_table__aggregate_def 0 1
                  1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
                  6765 10946 17711 28657 46368 75025 121393 196418 317811
                  514229 832040 1346269 2178309 3524578 5702887 9227465
                  14930352 24157817 39088169 63245986 102334155 165580141
                  267914296 433494437 701408733 1134903170 1836311903)))

(declare-const number_theory__fibonacci2__result Int)

(declare-const result Int)

(declare-const number_theory__fibonacci2__result1 Int)

(declare-const number_theory__fibonacci2__result2 Int)

(declare-const number_theory__fibonacci2__result3 Int)

(declare-const number_theory__fibonacci2__result4 Int)

(declare-const number_theory__fibonacci2__result5 Int)

(declare-const result1 Int)

;; H
  (assert (in_range1 n))

;; H
  (assert
  (= (number_theory__fibonacci2__lookup_table__aggregate_def 0 1 1 2 3 5 8 13
     21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657
     46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578
     5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141
     267914296 433494437 701408733 1134903170 1836311903) lookup_table))

;; H
  (assert
  (= number_theory__fibonacci2__result1 number_theory__fibonacci2__result2))

;; H
  (assert
  (= number_theory__fibonacci2__result3 number_theory__fibonacci2__result1))

;; H
  (assert (= result number_theory__fibonacci2__result))

;; H
  (assert
  (= number_theory__fibonacci2__result1 (to_rep (select lookup_table n))))

;; H
  (assert
  (= (mk_int__ref number_theory__fibonacci2__result4) (mk_int__ref
                                                      number_theory__fibonacci2__result2)))

;; H
  (assert
  (= number_theory__fibonacci2__result5 number_theory__fibonacci2__result3))

;; H
  (assert (= result1 number_theory__fibonacci2__result4))

(assert
;; WP_parameter_def
 ;; File "system.ads", line 1, characters 0-0
  (not (= number_theory__fibonacci2__result4 (fib n))))
(check-sat)
(exit)
