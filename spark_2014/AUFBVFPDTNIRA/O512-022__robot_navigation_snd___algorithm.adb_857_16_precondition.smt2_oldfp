;; produced by cvc4_14.drv ;;
(set-info :smt-lib-version 2.5)
(set-logic AUFBVDTNIRA)
(set-info :source |VC generated by SPARK 2014|)
(set-info :category industrial)
(set-info :status unknown)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
(declare-datatypes () ((tuple0 (Tuple0))))
(declare-sort us_private 0)

(declare-fun private__bool_eq (us_private us_private) Bool)

(declare-const us_null_ext__ us_private)

(declare-sort us_type_of_heap 0)

(declare-datatypes ()
((us_type_of_heap__ref
 (mk___type_of_heap__ref (us_type_of_heap__content us_type_of_heap)))))
(declare-sort us_image 0)

(declare-datatypes () ((int__ref (mk_int__ref (int__content Int)))))
(declare-datatypes () ((bool__ref (mk_bool__ref (bool__content Bool)))))
(declare-datatypes () ((real__ref (mk_real__ref (real__content Real)))))
(declare-datatypes ()
((us_private__ref (mk___private__ref (us_private__content us_private)))))
(define-fun int__ref___projection ((a int__ref)) Int (int__content a))

(define-fun bool__ref___projection ((a bool__ref)) Bool (bool__content a))

(define-fun real__ref___projection ((a real__ref)) Real (real__content a))

(define-fun us_private__ref___projection ((a us_private__ref)) us_private
  (us_private__content a))

(declare-fun div1 (Int Int) Int)

(declare-fun mod1 (Int Int) Int)

;; Div_mod
  (assert
  (forall ((x Int) (y Int))
  (=> (not (= y 0)) (= x (+ (* y (div1 x y)) (mod1 x y))))))

;; Div_bound
  (assert
  (forall ((x Int) (y Int))
  (=> (and (<= 0 x) (< 0 y)) (and (<= 0 (div1 x y)) (<= (div1 x y) x)))))

;; Mod_bound
  (assert
  (forall ((x Int) (y Int))
  (=> (not (= y 0)) (and (< (- (abs y)) (mod1 x y)) (< (mod1 x y) (abs y))))))

;; Div_sign_pos
  (assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; Div_sign_neg
  (assert
  (forall ((x Int) (y Int)) (=> (and (<= x 0) (< 0 y)) (<= (div1 x y) 0))))

;; Mod_sign_pos
  (assert
  (forall ((x Int) (y Int))
  (=> (and (<= 0 x) (not (= y 0))) (<= 0 (mod1 x y)))))

;; Mod_sign_neg
  (assert
  (forall ((x Int) (y Int))
  (=> (and (<= x 0) (not (= y 0))) (<= (mod1 x y) 0))))

;; Rounds_toward_zero
  (assert
  (forall ((x Int) (y Int))
  (=> (not (= y 0)) (<= (abs (* (div1 x y) y)) (abs x)))))

;; Div_1
  (assert (forall ((x Int)) (= (div1 x 1) x)))

;; Mod_1
  (assert (forall ((x Int)) (= (mod1 x 1) 0)))

;; Div_inf
  (assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (div1 x y) 0))))

;; Mod_inf
  (assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (mod1 x y) x))))

;; Div_mult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (! (=> (and (< 0 x) (and (<= 0 y) (<= 0 z)))
     (= (div1 (+ (* x y) z) x) (+ y (div1 z x)))) :pattern ((div1
                                                            (+ (* x y) z) x)) )))

;; Mod_mult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (! (=> (and (< 0 x) (and (<= 0 y) (<= 0 z)))
     (= (mod1 (+ (* x y) z) x) (mod1 z x))) :pattern ((mod1 (+ (* x y) z) x)) )))

(define-fun mod2 ((x Int)
  (y Int)) Int (ite (< 0 y) (mod x y) (+ (mod x y) y)))

(declare-sort t 0)

(declare-fun tqtreal (t) Real)

(declare-fun tqtisFinite (t) Bool)

;; t'axiom
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (and (<= (- (* 16777215.0 20282409603651670423947251286016.0)) (tqtreal x))
  (<= (tqtreal x) (* 16777215.0 20282409603651670423947251286016.0))))))

(declare-fun pow2 (Int) Int)

(declare-datatypes () ((mode (RNE1) (RNA1) (RTP1) (RTN1) (RTZ1))))
(define-fun to_nearest ((m mode)) Bool (or (= m RNE1) (= m RNA1)))

(declare-const zeroF t)

(declare-fun add (mode t t) t)

(declare-fun sub (mode t t) t)

(declare-fun mul (mode t t) t)

(declare-fun div2 (mode t t) t)

(declare-fun abs1 (t) t)

(declare-fun neg (t) t)

(declare-fun fma (mode t t t) t)

(declare-fun sqrt1 (mode t) t)

(declare-fun roundToIntegral (mode t) t)

(declare-fun min (t t) t)

(declare-fun max (t t) t)

(declare-fun le (t t) Bool)

(declare-fun lt (t t) Bool)

(declare-fun eq (t t) Bool)

(declare-fun is_normal (t) Bool)

(declare-fun is_subnormal (t) Bool)

(declare-fun is_zero (t) Bool)

(declare-fun is_infinite (t) Bool)

(declare-fun is_nan (t) Bool)

(declare-fun is_positive (t) Bool)

(declare-fun is_negative (t) Bool)

(define-fun is_plus_infinity ((x t)) Bool (and (is_infinite x) (is_positive
                                          x)))

(define-fun is_minus_infinity ((x t)) Bool (and (is_infinite x) (is_negative
                                           x)))

(define-fun is_plus_zero ((x t)) Bool (and (is_zero x) (is_positive x)))

(define-fun is_minus_zero ((x t)) Bool (and (is_zero x) (is_negative x)))

(define-fun is_not_nan ((x t)) Bool (or (tqtisFinite x) (is_infinite x)))

;; is_not_nan
  (assert (forall ((x t)) (= (is_not_nan x) (not (is_nan x)))))

;; is_not_finite
  (assert
  (forall ((x t)) (= (not (tqtisFinite x)) (or (is_infinite x) (is_nan x)))))

;; zeroF_is_positive
  (assert (is_positive zeroF))

;; zeroF_is_zero
  (assert (is_zero zeroF))

;; zero_to_real
  (assert
  (forall ((x t))
  (! (= (is_zero x) (and (tqtisFinite x) (= (tqtreal x) 0.0))) :pattern ((is_zero
  x)) )))

(declare-fun of_int (mode Int) t)

(declare-fun to_int1 (mode t) Int)

;; zero_of_int
  (assert (forall ((m mode)) (= zeroF (of_int m 0))))

(declare-fun round (mode Real) Real)

(declare-const max_int Int)

;; max_real_int
  (assert
  (= (* 33554430.0 10141204801825835211973625643008.0) (to_real max_int)))

(define-fun in_range ((x Real)) Bool (and
                                     (<= (- (* 33554430.0 10141204801825835211973625643008.0)) x)
                                     (<= x (* 33554430.0 10141204801825835211973625643008.0))))

(define-fun in_int_range ((i Int)) Bool (and (<= (- max_int) i)
                                        (<= i max_int)))

;; is_finite
  (assert (forall ((x t)) (=> (tqtisFinite x) (in_range (tqtreal x)))))

(define-fun no_overflow ((m mode) (x Real)) Bool (in_range (round m x)))

;; Bounded_real_no_overflow
  (assert (forall ((m mode) (x Real)) (=> (in_range x) (no_overflow m x))))

;; Round_monotonic
  (assert
  (forall ((m mode) (x Real) (y Real))
  (=> (<= x y) (<= (round m x) (round m y)))))

;; Round_idempotent
  (assert
  (forall ((m1 mode) (m2 mode) (x Real))
  (= (round m1 (round m2 x)) (round m2 x))))

;; Round_to_real
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x) (= (round m (tqtreal x)) (tqtreal x)))))

;; Round_down_le
  (assert (forall ((x Real)) (<= (round RTN1 x) x)))

;; Round_up_ge
  (assert (forall ((x Real)) (<= x (round RTP1 x))))

;; Round_down_neg
  (assert (forall ((x Real)) (= (round RTN1 (- x)) (- (round RTP1 x)))))

;; Round_up_neg
  (assert (forall ((x Real)) (= (round RTP1 (- x)) (- (round RTN1 x)))))

(define-fun in_safe_int_range ((i Int)) Bool (and (<= (- 16777216) i)
                                             (<= i 16777216)))

;; Exact_rounding_for_integers
  (assert
  (forall ((m mode) (i Int))
  (=> (in_safe_int_range i) (= (round m (to_real i)) (to_real i)))))

(define-fun same_sign ((x t)
  (y t)) Bool (or (and (is_positive x) (is_positive y))
              (and (is_negative x) (is_negative y))))

(define-fun diff_sign ((x t)
  (y t)) Bool (or (and (is_positive x) (is_negative y))
              (and (is_negative x) (is_positive y))))

;; feq_eq
  (assert
  (forall ((x t) (y t))
  (=> (tqtisFinite x)
  (=> (tqtisFinite y) (=> (not (is_zero x)) (=> (eq x y) (= x y)))))))

;; eq_feq
  (assert
  (forall ((x t) (y t))
  (=> (tqtisFinite x) (=> (tqtisFinite y) (=> (= x y) (eq x y))))))

;; eq_refl
  (assert (forall ((x t)) (=> (tqtisFinite x) (eq x x))))

;; eq_sym
  (assert (forall ((x t) (y t)) (=> (eq x y) (eq y x))))

;; eq_trans
  (assert (forall ((x t) (y t) (z t)) (=> (eq x y) (=> (eq y z) (eq x z)))))

;; eq_zero
  (assert (eq zeroF (neg zeroF)))

;; eq_to_real_finite
  (assert
  (forall ((x t) (y t))
  (=> (and (tqtisFinite x) (tqtisFinite y))
  (= (eq x y) (= (tqtreal x) (tqtreal y))))))

;; eq_special
  (assert
  (forall ((x t) (y t))
  (=> (eq x y)
  (and (is_not_nan x)
  (and (is_not_nan y)
  (or (and (tqtisFinite x) (tqtisFinite y))
  (and (is_infinite x) (and (is_infinite y) (same_sign x y)))))))))

;; lt_finite
  (assert
  (forall ((x t) (y t))
  (! (=> (and (tqtisFinite x) (tqtisFinite y))
     (= (lt x y) (< (tqtreal x) (tqtreal y)))) :pattern ((lt
  x y)) )))

;; le_finite
  (assert
  (forall ((x t) (y t))
  (! (=> (and (tqtisFinite x) (tqtisFinite y))
     (= (le x y) (<= (tqtreal x) (tqtreal y)))) :pattern ((le
  x y)) )))

;; le_lt_trans
  (assert (forall ((x t) (y t) (z t)) (=> (and (le x y) (lt y z)) (lt x z))))

;; lt_le_trans
  (assert (forall ((x t) (y t) (z t)) (=> (and (lt x y) (le y z)) (lt x z))))

;; le_ge_asym
  (assert (forall ((x t) (y t)) (=> (and (le x y) (le y x)) (eq x y))))

;; not_lt_ge
  (assert
  (forall ((x t) (y t))
  (=> (and (not (lt x y)) (and (is_not_nan x) (is_not_nan y))) (le y x))))

;; not_gt_le
  (assert
  (forall ((x t) (y t))
  (=> (and (not (lt y x)) (and (is_not_nan x) (is_not_nan y))) (le x y))))

;; le_special
  (assert
  (forall ((x t) (y t))
  (! (=> (le x y)
     (or (and (tqtisFinite x) (tqtisFinite y))
     (or (and (is_minus_infinity x) (is_not_nan y))
     (and (is_not_nan x) (is_plus_infinity y))))) :pattern ((le
  x y)) )))

;; lt_special
  (assert
  (forall ((x t) (y t))
  (! (=> (lt x y)
     (or (and (tqtisFinite x) (tqtisFinite y))
     (or
     (and (is_minus_infinity x)
     (and (is_not_nan y) (not (is_minus_infinity y))))
     (and (is_not_nan x)
     (and (not (is_plus_infinity x)) (is_plus_infinity y)))))) :pattern ((lt
  x y)) )))

;; lt_lt_finite
  (assert
  (forall ((x t) (y t) (z t)) (=> (lt x y) (=> (lt y z) (tqtisFinite y)))))

;; positive_to_real
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (=> (is_positive x) (<= 0.0 (tqtreal x)))) :pattern ((is_positive
  x)) :pattern ((<= 0.0 (tqtreal x))) )))

;; to_real_positive
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (=> (< 0.0 (tqtreal x)) (is_positive x))) :pattern ((is_positive
  x)) )))

;; negative_to_real
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (=> (is_negative x) (<= (tqtreal x) 0.0))) :pattern ((is_negative
  x)) :pattern ((<= (tqtreal x) 0.0)) )))

;; to_real_negative
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (=> (< (tqtreal x) 0.0) (is_negative x))) :pattern ((is_negative
  x)) )))

;; negative_xor_positive
  (assert (forall ((x t)) (not (and (is_positive x) (is_negative x)))))

;; negative_or_positive
  (assert
  (forall ((x t)) (=> (is_not_nan x) (or (is_positive x) (is_negative x)))))

;; diff_sign_trans
  (assert
  (forall ((x t) (y t) (z t))
  (=> (and (diff_sign x y) (diff_sign y z)) (same_sign x z))))

;; diff_sign_product
  (assert
  (forall ((x t) (y t))
  (=>
  (and (tqtisFinite x)
  (and (tqtisFinite y) (< (* (tqtreal x) (tqtreal y)) 0.0))) (diff_sign x y))))

;; same_sign_product
  (assert
  (forall ((x t) (y t))
  (=> (and (tqtisFinite x) (and (tqtisFinite y) (same_sign x y)))
  (<= 0.0 (* (tqtreal x) (tqtreal y))))))

(define-fun product_sign ((z t) (x t)
  (y t)) Bool (and (=> (same_sign x y) (is_positive z))
              (=> (diff_sign x y) (is_negative z))))

(define-fun overflow_value ((m mode)
  (x t)) Bool (ite (is-RTN1 m) (ite (is_positive x)
                               (and (tqtisFinite x)
                               (= (tqtreal x) (* 33554430.0 10141204801825835211973625643008.0)))
                               (is_infinite x)) (ite (is-RTP1 m) (ite (is_positive
                                                                 x)
                                                                 (is_infinite
                                                                 x)
                                                                 (and
                                                                 (tqtisFinite
                                                                 x)
                                                                 (= (tqtreal
                                                                    x) (- (* 33554430.0 10141204801825835211973625643008.0)))))
                                                (ite (is-RTZ1 m) (ite (is_positive
                                                                 x)
                                                                 (and
                                                                 (tqtisFinite
                                                                 x)
                                                                 (= (tqtreal
                                                                    x) (* 33554430.0 10141204801825835211973625643008.0)))
                                                                 (and
                                                                 (tqtisFinite
                                                                 x)
                                                                 (= (tqtreal
                                                                    x) (- (* 33554430.0 10141204801825835211973625643008.0)))))
                                                (ite (is-RNA1 m) (is_infinite
                                                x) (is_infinite x))))))

(define-fun sign_zero_result ((m mode)
  (x t)) Bool (=> (is_zero x)
              (ite (is-RTN1 m) (is_negative x) (is_positive x))))

;; add_finite
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (no_overflow m (+ (tqtreal x) (tqtreal y)))
     (and (tqtisFinite (add m x y))
     (= (tqtreal (add m x y)) (round m (+ (tqtreal x) (tqtreal y)))))))) :pattern (
  (add m x y)) )))

;; add_finite_rev
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite (add m x y)) (and (tqtisFinite x) (tqtisFinite y))) :pattern (
  (add m x y)) )))

;; add_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (add m x y))
     (and (no_overflow m (+ (tqtreal x) (tqtreal y)))
     (= (tqtreal (add m x y)) (round m (+ (tqtreal x) (tqtreal y))))))) :pattern (
  (add m x y)) )))

;; sub_finite
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (no_overflow m (- (tqtreal x) (tqtreal y)))
     (and (tqtisFinite (sub m x y))
     (= (tqtreal (sub m x y)) (round m (- (tqtreal x) (tqtreal y)))))))) :pattern (
  (sub m x y)) )))

;; sub_finite_rev
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite (sub m x y)) (and (tqtisFinite x) (tqtisFinite y))) :pattern (
  (sub m x y)) )))

;; sub_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (sub m x y))
     (and (no_overflow m (- (tqtreal x) (tqtreal y)))
     (= (tqtreal (sub m x y)) (round m (- (tqtreal x) (tqtreal y))))))) :pattern (
  (sub m x y)) )))

;; mul_finite
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (no_overflow m (* (tqtreal x) (tqtreal y)))
     (and (tqtisFinite (mul m x y))
     (= (tqtreal (mul m x y)) (round m (* (tqtreal x) (tqtreal y)))))))) :pattern (
  (mul m x y)) )))

;; mul_finite_rev
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite (mul m x y)) (and (tqtisFinite x) (tqtisFinite y))) :pattern (
  (mul m x y)) )))

;; mul_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (mul m x y))
     (and (no_overflow m (* (tqtreal x) (tqtreal y)))
     (= (tqtreal (mul m x y)) (round m (* (tqtreal x) (tqtreal y))))))) :pattern (
  (mul m x y)) )))

;; div_finite
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (not (is_zero y))
     (=> (no_overflow m (/ (tqtreal x) (tqtreal y)))
     (and (tqtisFinite (div2 m x y))
     (= (tqtreal (div2 m x y)) (round m (/ (tqtreal x) (tqtreal y))))))))) :pattern (
  (div2 m x y)) )))

;; div_finite_rev
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite (div2 m x y))
     (or (and (tqtisFinite x) (and (tqtisFinite y) (not (is_zero y))))
     (and (tqtisFinite x)
     (and (is_infinite y) (= (tqtreal (div2 m x y)) 0.0))))) :pattern (
  (div2 m x y)) )))

;; div_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (div2 m x y))
     (=> (tqtisFinite y)
     (and (no_overflow m (/ (tqtreal x) (tqtreal y)))
     (= (tqtreal (div2 m x y)) (round m (/ (tqtreal x) (tqtreal y)))))))) :pattern (
  (div2 m x y)) )))

;; neg_finite
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x)
     (and (tqtisFinite (neg x)) (= (tqtreal (neg x)) (- (tqtreal x))))) :pattern (
  (neg x)) )))

;; neg_finite_rev
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite (neg x))
     (and (tqtisFinite x) (= (tqtreal (neg x)) (- (tqtreal x))))) :pattern (
  (neg x)) )))

;; abs_finite
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x)
     (and (tqtisFinite (abs1 x))
     (and
     (= (tqtreal (abs1 x)) (ite (>= (tqtreal x) 0.0) (tqtreal x) (- (tqtreal
                                                                    x))))
     (is_positive (abs1 x))))) :pattern ((abs1 x)) )))

;; abs_finite_rev
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite (abs1 x))
     (and (tqtisFinite x)
     (= (tqtreal (abs1 x)) (ite (>= (tqtreal x) 0.0) (tqtreal x) (- (tqtreal
                                                                    x)))))) :pattern (
  (abs1 x)) )))

;; abs_universal
  (assert
  (forall ((x t)) (! (not (is_negative (abs1 x))) :pattern ((abs1 x)) )))

;; fma_finite
  (assert
  (forall ((m mode) (x t) (y t) (z t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (tqtisFinite z)
     (=> (no_overflow m (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)))
     (and (tqtisFinite (fma m x y z))
     (= (tqtreal (fma m x y z)) (round m
                                (+ (* (tqtreal x) (tqtreal y)) (tqtreal z))))))))) :pattern (
  (fma m x y z)) )))

;; fma_finite_rev
  (assert
  (forall ((m mode) (x t) (y t) (z t))
  (! (=> (tqtisFinite (fma m x y z))
     (and (tqtisFinite x) (and (tqtisFinite y) (tqtisFinite z)))) :pattern (
  (fma m x y z)) )))

;; fma_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t) (z t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (fma m x y z))
     (and (no_overflow m (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)))
     (= (tqtreal (fma m x y z)) (round m
                                (+ (* (tqtreal x) (tqtreal y)) (tqtreal z))))))) :pattern (
  (fma m x y z)) )))

(define-fun sqr ((x Real)) Real (* x x))

(declare-fun sqrt2 (Real) Real)

;; Sqrt_positive
  (assert (forall ((x Real)) (=> (<= 0.0 x) (<= 0.0 (sqrt2 x)))))

;; Sqrt_square
  (assert (forall ((x Real)) (=> (<= 0.0 x) (= (sqr (sqrt2 x)) x))))

;; Square_sqrt
  (assert (forall ((x Real)) (=> (<= 0.0 x) (= (sqrt2 (* x x)) x))))

;; Sqrt_mul
  (assert
  (forall ((x Real) (y Real))
  (=> (and (<= 0.0 x) (<= 0.0 y))
  (= (sqrt2 (* x y)) (* (sqrt2 x) (sqrt2 y))))))

;; Sqrt_le
  (assert
  (forall ((x Real) (y Real))
  (=> (and (<= 0.0 x) (<= x y)) (<= (sqrt2 x) (sqrt2 y)))))

;; sqrt_finite
  (assert
  (forall ((m mode) (x t))
  (! (=> (tqtisFinite x)
     (=> (<= 0.0 (tqtreal x))
     (and (tqtisFinite (sqrt1 m x))
     (= (tqtreal (sqrt1 m x)) (round m (sqrt2 (tqtreal x))))))) :pattern (
  (sqrt1 m x)) )))

;; sqrt_finite_rev
  (assert
  (forall ((m mode) (x t))
  (! (=> (tqtisFinite (sqrt1 m x))
     (and (tqtisFinite x)
     (and (<= 0.0 (tqtreal x))
     (= (tqtreal (sqrt1 m x)) (round m (sqrt2 (tqtreal x))))))) :pattern (
  (sqrt1 m x)) )))

(define-fun same_sign_real ((x t)
  (r Real)) Bool (or (and (is_positive x) (< 0.0 r))
                 (and (is_negative x) (< r 0.0))))

;; add_special
  (assert
  (forall ((m mode) (x t) (y t))
  (! (let ((r (add m x y)))
     (and (=> (or (is_nan x) (is_nan y)) (is_nan r))
     (and
     (=> (and (tqtisFinite x) (is_infinite y))
     (and (is_infinite r) (same_sign r y)))
     (and
     (=> (and (is_infinite x) (tqtisFinite y))
     (and (is_infinite r) (same_sign r x)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (same_sign x y)))
     (and (is_infinite r) (same_sign r x)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (diff_sign x y))) (is_nan
     r))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y) (not (no_overflow m (+ (tqtreal x) (tqtreal y))))))
     (and (same_sign_real r (+ (tqtreal x) (tqtreal y))) (overflow_value m
     r)))
     (=> (and (tqtisFinite x) (tqtisFinite y))
     (ite (same_sign x y) (same_sign r x) (sign_zero_result m r)))))))))) :pattern (
  (add m x y)) )))

;; sub_special
  (assert
  (forall ((m mode) (x t) (y t))
  (! (let ((r (sub m x y)))
     (and (=> (or (is_nan x) (is_nan y)) (is_nan r))
     (and
     (=> (and (tqtisFinite x) (is_infinite y))
     (and (is_infinite r) (diff_sign r y)))
     (and
     (=> (and (is_infinite x) (tqtisFinite y))
     (and (is_infinite r) (same_sign r x)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (same_sign x y))) (is_nan
     r))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (diff_sign x y)))
     (and (is_infinite r) (same_sign r x)))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y) (not (no_overflow m (- (tqtreal x) (tqtreal y))))))
     (and (same_sign_real r (- (tqtreal x) (tqtreal y))) (overflow_value m
     r)))
     (=> (and (tqtisFinite x) (tqtisFinite y))
     (ite (diff_sign x y) (same_sign r x) (sign_zero_result m r)))))))))) :pattern (
  (sub m x y)) )))

;; mul_special
  (assert
  (forall ((m mode) (x t) (y t))
  (! (let ((r (mul m x y)))
     (and (=> (or (is_nan x) (is_nan y)) (is_nan r))
     (and (=> (and (is_zero x) (is_infinite y)) (is_nan r))
     (and
     (=> (and (tqtisFinite x) (and (is_infinite y) (not (is_zero x))))
     (is_infinite r))
     (and (=> (and (is_infinite x) (is_zero y)) (is_nan r))
     (and
     (=> (and (is_infinite x) (and (tqtisFinite y) (not (is_zero y))))
     (is_infinite r))
     (and (=> (and (is_infinite x) (is_infinite y)) (is_infinite r))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y) (not (no_overflow m (* (tqtreal x) (tqtreal y))))))
     (overflow_value m r)) (=> (not (is_nan r)) (product_sign r x y)))))))))) :pattern (
  (mul m x y)) )))

;; div_special
  (assert
  (forall ((m mode) (x t) (y t))
  (! (let ((r (div2 m x y)))
     (and (=> (or (is_nan x) (is_nan y)) (is_nan r))
     (and (=> (and (tqtisFinite x) (is_infinite y)) (is_zero r))
     (and (=> (and (is_infinite x) (tqtisFinite y)) (is_infinite r))
     (and (=> (and (is_infinite x) (is_infinite y)) (is_nan r))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y)
     (and (not (is_zero y))
     (not (no_overflow m (/ (tqtreal x) (tqtreal y))))))) (overflow_value m
     r))
     (and
     (=> (and (tqtisFinite x) (and (is_zero y) (not (is_zero x))))
     (is_infinite r))
     (and (=> (and (is_zero x) (is_zero y)) (is_nan r))
     (=> (not (is_nan r)) (product_sign r x y)))))))))) :pattern ((div2 m x
                                                                  y)) )))

;; neg_special
  (assert
  (forall ((x t))
  (! (and (=> (is_nan x) (is_nan (neg x)))
     (and (=> (is_infinite x) (is_infinite (neg x)))
     (=> (not (is_nan x)) (diff_sign x (neg x))))) :pattern ((neg x)) )))

;; abs_special
  (assert
  (forall ((x t))
  (! (and (=> (is_nan x) (is_nan (abs1 x)))
     (and (=> (is_infinite x) (is_infinite (abs1 x)))
     (=> (not (is_nan x)) (is_positive (abs1 x))))) :pattern ((abs1 x)) )))

;; fma_special
  (assert
  (forall ((m mode) (x t) (y t) (z t))
  (! (let ((r (fma m x y z)))
     (and (=> (or (is_nan x) (or (is_nan y) (is_nan z))) (is_nan r))
     (and (=> (and (is_zero x) (is_infinite y)) (is_nan r))
     (and (=> (and (is_infinite x) (is_zero y)) (is_nan r))
     (and
     (=>
     (and (tqtisFinite x)
     (and (not (is_zero x)) (and (is_infinite y) (tqtisFinite z))))
     (and (is_infinite r) (product_sign r x y)))
     (and
     (=>
     (and (tqtisFinite x)
     (and (not (is_zero x)) (and (is_infinite y) (is_infinite z))))
     (ite (product_sign z x y) (and (is_infinite r) (same_sign r z)) (is_nan
     r)))
     (and
     (=>
     (and (is_infinite x)
     (and (tqtisFinite y) (and (not (is_zero y)) (tqtisFinite z))))
     (and (is_infinite r) (product_sign r x y)))
     (and
     (=>
     (and (is_infinite x)
     (and (tqtisFinite y) (and (not (is_zero y)) (is_infinite z))))
     (ite (product_sign z x y) (and (is_infinite r) (same_sign r z)) (is_nan
     r)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (tqtisFinite z)))
     (and (is_infinite r) (product_sign r x y)))
     (and
     (=> (and (tqtisFinite x) (and (tqtisFinite y) (is_infinite z)))
     (and (is_infinite r) (same_sign r z)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (is_infinite z)))
     (ite (product_sign z x y) (and (is_infinite r) (same_sign r z)) (is_nan
     r)))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y)
     (and (tqtisFinite z)
     (not (no_overflow m (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)))))))
     (and (same_sign_real r (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)))
     (overflow_value m r)))
     (=> (and (tqtisFinite x) (and (tqtisFinite y) (tqtisFinite z)))
     (ite (product_sign z x y) (same_sign r z)
     (=> (= (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)) 0.0)
     (ite (= m RTN1) (is_negative r) (is_positive r))))))))))))))))) :pattern (
  (fma m x y z)) )))

;; sqrt_special
  (assert
  (forall ((m mode) (x t))
  (! (let ((r (sqrt1 m x)))
     (and (=> (is_nan x) (is_nan r))
     (and (=> (is_plus_infinity x) (is_plus_infinity r))
     (and (=> (is_minus_infinity x) (is_nan r))
     (and (=> (and (tqtisFinite x) (< (tqtreal x) 0.0)) (is_nan r))
     (and (=> (is_zero x) (same_sign r x))
     (=> (and (tqtisFinite x) (< 0.0 (tqtreal x))) (is_positive r)))))))) :pattern (
  (sqrt1 m x)) )))

;; of_int_add_exact
  (assert
  (forall ((m mode) (n mode) (i Int) (j Int))
  (=> (in_safe_int_range i)
  (=> (in_safe_int_range j)
  (=> (in_safe_int_range (+ i j)) (eq (of_int m (+ i j))
  (add n (of_int m i) (of_int m j))))))))

;; of_int_sub_exact
  (assert
  (forall ((m mode) (n mode) (i Int) (j Int))
  (=> (in_safe_int_range i)
  (=> (in_safe_int_range j)
  (=> (in_safe_int_range (- i j)) (eq (of_int m (- i j))
  (sub n (of_int m i) (of_int m j))))))))

;; of_int_mul_exact
  (assert
  (forall ((m mode) (n mode) (i Int) (j Int))
  (=> (in_safe_int_range i)
  (=> (in_safe_int_range j)
  (=> (in_safe_int_range (* i j)) (eq (of_int m (* i j))
  (mul n (of_int m i) (of_int m j))))))))

;; Min_r
  (assert (forall ((x t) (y t)) (=> (le y x) (eq (min x y) y))))

;; Min_l
  (assert (forall ((x t) (y t)) (=> (le x y) (eq (min x y) x))))

;; Max_r
  (assert (forall ((x t) (y t)) (=> (le y x) (eq (max x y) x))))

;; Max_l
  (assert (forall ((x t) (y t)) (=> (le x y) (eq (max x y) y))))

(declare-fun is_int1 (t) Bool)

;; zeroF_is_int
  (assert (is_int1 zeroF))

;; of_int_is_int
  (assert
  (forall ((m mode) (x Int)) (=> (in_int_range x) (is_int1 (of_int m x)))))

;; big_float_is_int
  (assert
  (forall ((m mode) (i t))
  (=> (tqtisFinite i)
  (=> (or (le i (neg (of_int m 16777216))) (le (of_int m 16777216) i))
  (is_int1 i)))))

;; roundToIntegral_is_int
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x) (is_int1 (roundToIntegral m x)))))

;; eq_is_int
  (assert (forall ((x t) (y t)) (=> (eq x y) (=> (is_int1 x) (is_int1 y)))))

;; add_int
  (assert
  (forall ((x t) (y t) (m mode))
  (=> (is_int1 x)
  (=> (is_int1 y) (=> (tqtisFinite (add m x y)) (is_int1 (add m x y)))))))

;; sub_int
  (assert
  (forall ((x t) (y t) (m mode))
  (=> (is_int1 x)
  (=> (is_int1 y) (=> (tqtisFinite (sub m x y)) (is_int1 (sub m x y)))))))

;; mul_int
  (assert
  (forall ((x t) (y t) (m mode))
  (=> (is_int1 x)
  (=> (is_int1 y) (=> (tqtisFinite (mul m x y)) (is_int1 (mul m x y)))))))

;; fma_int
  (assert
  (forall ((x t) (y t) (z t) (m mode))
  (=> (is_int1 x)
  (=> (is_int1 y)
  (=> (is_int1 z) (=> (tqtisFinite (fma m x y z)) (is_int1 (fma m x y z))))))))

;; neg_int
  (assert (forall ((x t)) (=> (is_int1 x) (is_int1 (neg x)))))

;; abs_int
  (assert (forall ((x t)) (=> (is_int1 x) (is_int1 (abs1 x)))))

;; is_int_of_int
  (assert
  (forall ((x t) (m mode) (mqt mode))
  (=> (is_int1 x) (eq x (of_int mqt (to_int1 m x))))))

;; is_int_to_int
  (assert
  (forall ((m mode) (x t)) (=> (is_int1 x) (in_int_range (to_int1 m x)))))

;; is_int_is_finite
  (assert (forall ((x t)) (=> (is_int1 x) (tqtisFinite x))))

;; int_to_real
  (assert
  (forall ((m mode) (x t))
  (=> (is_int1 x) (= (tqtreal x) (to_real (to_int1 m x))))))

;; truncate_int
  (assert
  (forall ((m mode) (i t)) (=> (is_int1 i) (eq (roundToIntegral m i) i))))

;; truncate_neg
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (=> (is_negative x) (= (roundToIntegral RTZ1 x) (roundToIntegral RTP1 x))))))

;; truncate_pos
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (=> (is_positive x) (= (roundToIntegral RTZ1 x) (roundToIntegral RTN1 x))))))

;; ceil_le
  (assert
  (forall ((x t)) (=> (tqtisFinite x) (le x (roundToIntegral RTP1 x)))))

;; ceil_lest
  (assert
  (forall ((x t) (y t))
  (=> (and (le x y) (is_int1 y)) (le (roundToIntegral RTP1 x) y))))

;; ceil_to_real
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (= (tqtreal (roundToIntegral RTP1 x)) (to_real (- 1 (to_int (- 1.0
  (tqtreal x)))))))))

;; ceil_to_int
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x)
  (= (to_int1 m (roundToIntegral RTP1 x)) (- 1 (to_int (- 1.0 (tqtreal x))))))))

;; floor_le
  (assert
  (forall ((x t)) (=> (tqtisFinite x) (le (roundToIntegral RTN1 x) x))))

;; floor_lest
  (assert
  (forall ((x t) (y t))
  (=> (and (le y x) (is_int1 y)) (le y (roundToIntegral RTN1 x)))))

;; floor_to_real
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (= (tqtreal (roundToIntegral RTN1 x)) (to_real (to_int (tqtreal x)))))))

;; floor_to_int
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x)
  (= (to_int1 m (roundToIntegral RTN1 x)) (to_int (tqtreal x))))))

;; RNA_down
  (assert
  (forall ((x t))
  (=> (lt (sub RNE1 x (roundToIntegral RTN1 x))
  (sub RNE1 (roundToIntegral RTP1 x) x))
  (= (roundToIntegral RNA1 x) (roundToIntegral RTN1 x)))))

;; RNA_up
  (assert
  (forall ((x t))
  (=> (lt (sub RNE1 (roundToIntegral RTP1 x) x)
  (sub RNE1 x (roundToIntegral RTN1 x)))
  (= (roundToIntegral RNA1 x) (roundToIntegral RTP1 x)))))

;; RNA_down_tie
  (assert
  (forall ((x t))
  (=> (eq (sub RNE1 x (roundToIntegral RTN1 x))
  (sub RNE1 (roundToIntegral RTP1 x) x))
  (=> (is_negative x) (= (roundToIntegral RNA1 x) (roundToIntegral RTN1 x))))))

;; RNA_up_tie
  (assert
  (forall ((x t))
  (=> (eq (sub RNE1 (roundToIntegral RTP1 x) x)
  (sub RNE1 x (roundToIntegral RTN1 x)))
  (=> (is_positive x) (= (roundToIntegral RNA1 x) (roundToIntegral RTP1 x))))))

;; to_int_roundToIntegral
  (assert
  (forall ((m mode) (x t))
  (= (to_int1 m x) (to_int1 m (roundToIntegral m x)))))

;; to_int_monotonic
  (assert
  (forall ((m mode) (x t) (y t))
  (=> (tqtisFinite x)
  (=> (tqtisFinite y) (=> (le x y) (<= (to_int1 m x) (to_int1 m y)))))))

;; to_int_of_int
  (assert
  (forall ((m mode) (i Int))
  (=> (in_safe_int_range i) (= (to_int1 m (of_int m i)) i))))

;; eq_to_int
  (assert
  (forall ((m mode) (x t) (y t))
  (=> (tqtisFinite x) (=> (eq x y) (= (to_int1 m x) (to_int1 m y))))))

;; neg_to_int
  (assert
  (forall ((m mode) (x t))
  (=> (is_int1 x) (= (to_int1 m (neg x)) (- (to_int1 m x))))))

;; roundToIntegral_is_finite
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x) (tqtisFinite (roundToIntegral m x)))))

;; round_bound_ne
  (assert
  (forall ((x Real))
  (! (=> (no_overflow RNE1 x)
     (and
     (<= (- (- x (* (/ 1.0 16777216.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 1427247692705959881058285969449495136382746624.0))
     (round RNE1 x))
     (<= (round RNE1 x) (+ (+ x (* (/ 1.0 16777216.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 1427247692705959881058285969449495136382746624.0))))) :pattern (
  (round RNE1 x)) )))

;; round_bound
  (assert
  (forall ((m mode) (x Real))
  (! (=> (no_overflow m x)
     (and
     (<= (- (- x (* (/ 1.0 8388608.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 713623846352979940529142984724747568191373312.0))
     (round m x))
     (<= (round m x) (+ (+ x (* (/ 1.0 8388608.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 713623846352979940529142984724747568191373312.0))))) :pattern (
  (round m x)) )))

(define-fun neq ((x t) (y t)) Bool (not (eq x y)))

(define-fun bool_lt ((x t) (y t)) Bool (ite (lt x y) true false))

(define-fun bool_le ((x t) (y t)) Bool (ite (le x y) true false))

(define-fun bool_gt ((x t) (y t)) Bool (ite (lt y x) true false))

(define-fun bool_ge ((x t) (y t)) Bool (ite (le y x) true false))

(define-fun bool_eq ((x t) (y t)) Bool (ite (eq x y) true false))

(define-fun bool_neq ((x t) (y t)) Bool (ite (not (eq x y)) true false))

(declare-fun rem1 (t t) t)

(declare-const fliteral t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral) (= (tqtreal fliteral) 1.0)))

;; one_is_int
  (assert (is_int1 fliteral))

;; one_of_int
  (assert (= fliteral (of_int RNA1 1)))

(declare-datatypes () ((t__ref (mk_t__ref (t__content t)))))
(define-fun in_range1 ((x Int)) Bool (or (= x 0) (= x 1)))

(declare-fun attr__ATTRIBUTE_IMAGE (Bool) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE (us_image) Bool)

(declare-sort integer 0)

(declare-fun integerqtint (integer) Int)

;; integer'axiom
  (assert
  (forall ((i integer))
  (and (<= (- 2147483648) (integerqtint i)) (<= (integerqtint i) 2147483647))))

(define-fun in_range2 ((x Int)) Bool (and (<= (- 2147483648) x)
                                     (<= x 2147483647)))

(declare-fun attr__ATTRIBUTE_IMAGE1 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check1 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE1 (us_image) Int)

(declare-fun user_eq (integer integer) Bool)

(declare-const dummy integer)

(declare-datatypes ()
((integer__ref (mk_integer__ref (integer__content integer)))))
(define-fun integer__ref___projection ((a integer__ref)) integer (integer__content
                                                                 a))

(declare-sort positive 0)

(declare-fun positiveqtint (positive) Int)

;; positive'axiom
  (assert
  (forall ((i positive))
  (and (<= 1 (positiveqtint i)) (<= (positiveqtint i) 2147483647))))

(define-fun in_range3 ((x Int)) Bool (and (<= 1 x) (<= x 2147483647)))

(declare-fun attr__ATTRIBUTE_IMAGE2 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check2 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE2 (us_image) Int)

(declare-fun user_eq1 (positive positive) Bool)

(declare-const dummy1 positive)

(declare-datatypes ()
((positive__ref (mk_positive__ref (positive__content positive)))))
(define-fun positive__ref___projection ((a positive__ref)) positive (positive__content
                                                                    a))

(declare-sort character 0)

(define-fun in_range4 ((x Int)) Bool (and (<= 0 x) (<= x 255)))

(declare-fun attr__ATTRIBUTE_IMAGE3 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check3 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE3 (us_image) Int)

(declare-fun user_eq2 (character character) Bool)

(declare-const dummy2 character)

(declare-datatypes ()
((character__ref (mk_character__ref (character__content character)))))
(define-fun character__ref___projection ((a character__ref)) character
  (character__content a))

(declare-fun to_rep (character) Int)

(declare-fun of_rep (Int) character)

;; inversion_axiom
  (assert
  (forall ((x character))
  (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; range_axiom
  (assert
  (forall ((x character)) (! (in_range4 (to_rep x)) :pattern ((to_rep x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range4 x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep
                                                            (of_rep x))) )))

(declare-datatypes ()
((map__ref (mk_map__ref (map__content (Array Int character))))))
(declare-fun slide ((Array Int character) Int Int) (Array Int character))

;; slide_eq
  (assert
  (forall ((a (Array Int character)))
  (forall ((first Int))
  (! (= (slide a first first) a) :pattern ((slide a first first)) ))))

;; slide_def
  (assert
  (forall ((a (Array Int character)))
  (forall ((old_first Int))
  (forall ((new_first Int))
  (forall ((i Int))
  (! (= (select (slide a old_first new_first) i) (select a (- i (- new_first old_first)))) :pattern ((select
  (slide a old_first new_first) i)) ))))))

(define-fun bool_eq1 ((a (Array Int character)) (a__first Int) (a__last Int)
  (b (Array Int character)) (b__first Int)
  (b__last Int)) Bool (ite (and
                           (ite (<= a__first a__last)
                           (and (<= b__first b__last)
                           (= (- a__last a__first) (- b__last b__first)))
                           (< b__last b__first))
                           (forall ((temp___idx_91 Int))
                           (=>
                           (and (<= a__first temp___idx_91)
                           (<= temp___idx_91 a__last))
                           (= (to_rep (select a temp___idx_91)) (to_rep
                                                                (select b (+ (- b__first a__first) temp___idx_91)))))))
                      true false))

;; bool_eq_rev
  (assert
  (forall ((a (Array Int character)) (b (Array Int character)))
  (forall ((a__first Int) (a__last Int) (b__first Int) (b__last Int))
  (=> (= (bool_eq1 b b__first b__last a a__first a__last) true)
  (and
  (ite (<= a__first a__last)
  (and (<= b__first b__last) (= (- a__last a__first) (- b__last b__first)))
  (< b__last b__first))
  (forall ((temp___idx_91 Int))
  (=> (and (<= a__first temp___idx_91) (<= temp___idx_91 a__last))
  (= (to_rep (select a temp___idx_91)) (to_rep
                                       (select b (+ (- b__first a__first) temp___idx_91)))))))))))

(define-fun to_rep1 ((x integer)) Int (integerqtint x))

(declare-fun of_rep1 (Int) integer)

;; inversion_axiom
  (assert
  (forall ((x integer))
  (! (= (of_rep1 (to_rep1 x)) x) :pattern ((to_rep1 x)) )))

;; range_axiom
  (assert
  (forall ((x integer)) (! (in_range2 (to_rep1 x)) :pattern ((to_rep1 x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range2 x) (= (to_rep1 (of_rep1 x)) x)) :pattern ((to_rep1
                                                              (of_rep1 x))) )))

(declare-sort t1 0)

(declare-fun first (t1) integer)

(declare-fun last (t1) integer)

(declare-fun mk (Int Int) t1)

;; mk_def
  (assert
  (forall ((f Int) (l Int))
  (! (=> (in_range2 f)
     (=> (in_range2 l)
     (and (= (to_rep1 (first (mk f l))) f) (= (to_rep1 (last (mk f l))) l)))) :pattern (
  (mk f l)) )))

(define-fun dynamic_property ((range_first Int) (range_last Int) (low Int)
  (high Int)) Bool (and (in_range2 low)
                   (and (in_range2 high)
                   (=> (<= low high) (and (in_range3 low) (in_range3 high))))))

(declare-datatypes () ((us_t (mk___t (elts (Array Int character))(rt t1)))))
(define-fun to_array ((a us_t)) (Array Int character) (elts a))

(define-fun of_array ((a (Array Int character)) (f Int)
  (l Int)) us_t (mk___t a (mk f l)))

(define-fun first1 ((a us_t)) Int (to_rep1 (first (rt a))))

(define-fun last1 ((a us_t)) Int (to_rep1 (last (rt a))))

(define-fun length ((a us_t)) Int (ite (<= (first1 a) (last1 a))
                                  (+ (- (last1 a) (first1 a)) 1) 0))

(declare-const value__size Int)

(declare-fun object__size ((Array Int character)) Int)

(declare-const value__component__size Int)

(declare-fun object__component__size ((Array Int character)) Int)

(declare-const value__alignment Int)

(declare-fun object__alignment ((Array Int character)) Int)

;; value__size_axiom
  (assert (<= 0 value__size))

;; object__size_axiom
  (assert (forall ((a (Array Int character))) (<= 0 (object__size a))))

;; value__component__size_axiom
  (assert (<= 0 value__component__size))

;; object__component__size_axiom
  (assert
  (forall ((a (Array Int character))) (<= 0 (object__component__size a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment))

;; object__alignment_axiom
  (assert (forall ((a (Array Int character))) (<= 0 (object__alignment a))))

(define-fun bool_eq2 ((x us_t)
  (y us_t)) Bool (bool_eq1 (elts x) (to_rep1 (first (rt x)))
                 (to_rep1 (last (rt x))) (elts y) (to_rep1 (first (rt y)))
                 (to_rep1 (last (rt y)))))

(declare-fun user_eq3 (us_t us_t) Bool)

(declare-const dummy3 us_t)

(declare-fun to_string (us_image) us_t)

(declare-fun from_string (us_t) us_image)

(declare-datatypes ()
((string__ref (mk_string__ref (string__content us_t)))))
(define-fun string__ref___projection ((a string__ref)) us_t (string__content
                                                            a))

(declare-sort natural 0)

(declare-fun naturalqtint (natural) Int)

;; natural'axiom
  (assert
  (forall ((i natural))
  (and (<= 0 (naturalqtint i)) (<= (naturalqtint i) 2147483647))))

(define-fun in_range5 ((x Int)) Bool (and (<= 0 x) (<= x 2147483647)))

(declare-fun attr__ATTRIBUTE_IMAGE4 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check4 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE4 (us_image) Int)

(declare-fun user_eq4 (natural natural) Bool)

(declare-const dummy4 natural)

(declare-datatypes ()
((natural__ref (mk_natural__ref (natural__content natural)))))
(define-fun natural__ref___projection ((a natural__ref)) natural (natural__content
                                                                 a))

(define-fun dynamic_invariant ((temp___expr_39 Int) (temp___is_init_35 Bool)
  (temp___skip_constant_36 Bool) (temp___do_toplevel_37 Bool)
  (temp___do_typ_inv_38 Bool)) Bool (=>
                                    (or (= temp___is_init_35 true)
                                    (<= 0 2147483647)) (in_range5
                                    temp___expr_39)))

(declare-sort float 0)

(define-fun bool_eq3 ((x t) (y t)) Bool (ite (eq x y) true false))

(declare-fun user_eq5 (float float) Bool)

(declare-fun attr__ATTRIBUTE_IMAGE5 (t) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check5 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE5 (us_image) t)

(declare-const dummy5 float)

(declare-datatypes () ((float__ref (mk_float__ref (float__content float)))))
(define-fun float__ref___projection ((a float__ref)) float (float__content a))

(declare-const fliteral1 t)

;; fliteral_axiom
  (assert
  (and (tqtisFinite fliteral1)
  (= (tqtreal fliteral1) 340282346638528859811704183484516925440.0)))

(define-fun dynamic_invariant1 ((temp___expr_60 t) (temp___is_init_56 Bool)
  (temp___skip_constant_57 Bool) (temp___do_toplevel_58 Bool)
  (temp___do_typ_inv_59 Bool)) Bool (=>
                                    (or (= temp___is_init_56 true) (le
                                    (neg fliteral1) fliteral1)) (tqtisFinite
                                    temp___expr_60)))

(declare-fun to_rep2 (float) t)

(declare-fun of_rep2 (t) float)

;; inversion_axiom
  (assert
  (forall ((x float))
  (! (= (of_rep2 (to_rep2 x)) x) :pattern ((to_rep2 x)) )))

;; range_axiom
  (assert
  (forall ((x float)) (! (tqtisFinite (to_rep2 x)) :pattern ((to_rep2 x)) )))

;; coerce_axiom
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (= (to_rep2 (of_rep2 x)) x)) :pattern ((to_rep2
                                                                (of_rep2 x))) )))

(declare-fun sqrt3 (t) t)

(declare-fun sqrt__function_guard (t t) Bool)

(declare-const fliteral2 t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral2) (= (tqtreal fliteral2) (/ 0.0 10.0))))

;; sqrt__post_axiom
  (assert
  (forall ((x t))
  (! (=> (and (dynamic_invariant1 x true true true true) (le fliteral2 x))
     (let ((result (sqrt3 x)))
     (and
     (and (le fliteral2 result)
     (and (=> (eq x fliteral2) (eq result fliteral2))
     (=> (eq x fliteral) (eq result fliteral)))) (dynamic_invariant1 result
     true false true true)))) :pattern ((sqrt3 x)) )))

(declare-fun arctan1 (t t) t)

(declare-fun arctan__function_guard (t t t) Bool)

;; arctan__post_axiom
  (assert
  (forall ((y t) (x t))
  (! (=>
     (and
     (and (dynamic_invariant1 y true true true true) (dynamic_invariant1 x
     true true true true)) (or (neq x fliteral2) (neq y fliteral2)))
     (let ((result (arctan1 y x)))
     (and (=> (and (lt fliteral2 x) (eq y fliteral2)) (eq result fliteral2))
     (dynamic_invariant1 result true false true true)))) :pattern ((arctan1 y
                                                                   x)) )))

(declare-sort normalized2pi 0)

(declare-const fliteral3 t)

;; fliteral_axiom
  (assert
  (and (tqtisFinite fliteral3)
  (= (tqtreal fliteral3) (/ 6283185482025146484375.0 1000000000000000000000.0))))

(define-fun in_range6 ((x t)) Bool (and (tqtisFinite x)
                                   (and (le fliteral2 x) (le x fliteral3))))

(define-fun bool_eq4 ((x t) (y t)) Bool (ite (eq x y) true false))

(declare-fun user_eq6 (normalized2pi normalized2pi) Bool)

(declare-fun attr__ATTRIBUTE_IMAGE6 (t) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check6 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE6 (us_image) t)

(declare-const dummy6 normalized2pi)

(declare-datatypes ()
((normalized2pi__ref
 (mk_normalized2pi__ref (normalized2pi__content normalized2pi)))))
(define-fun normalized2pi__ref___projection ((a normalized2pi__ref)) normalized2pi
  (normalized2pi__content a))

(declare-fun to_rep3 (normalized2pi) t)

(declare-fun of_rep3 (t) normalized2pi)

;; inversion_axiom
  (assert
  (forall ((x normalized2pi))
  (! (= (of_rep3 (to_rep3 x)) x) :pattern ((to_rep3 x)) )))

;; range_axiom
  (assert
  (forall ((x normalized2pi)) (! (in_range6
  (to_rep3 x)) :pattern ((to_rep3 x)) )))

;; coerce_axiom
  (assert
  (forall ((x t))
  (! (=> (in_range6 x) (= (to_rep3 (of_rep3 x)) x)) :pattern ((to_rep3
                                                              (of_rep3 x))) )))

(declare-datatypes ()
((us_split_fields
 (mk___split_fields (rec__spaces__angles__angle__theta normalized2pi)))))
(define-fun us_split_fields_Theta__projection ((a us_split_fields)) normalized2pi
  (rec__spaces__angles__angle__theta a))

(declare-datatypes ()
((us_split_fields__ref
 (mk___split_fields__ref (us_split_fields__content us_split_fields)))))
(define-fun us_split_fields__ref___projection ((a us_split_fields__ref)) us_split_fields
  (us_split_fields__content a))

(declare-datatypes ()
((us_rep (mk___rep (us_split_fields1 us_split_fields)))))
(define-fun us_rep___projection ((a us_rep)) us_split_fields (us_split_fields1
                                                             a))

(define-fun bool_eq5 ((a us_rep)
  (b us_rep)) Bool (ite (= (to_rep3
                           (rec__spaces__angles__angle__theta
                           (us_split_fields1 a))) (to_rep3
                                                  (rec__spaces__angles__angle__theta
                                                  (us_split_fields1 b))))
                   true false))

(declare-const value__size1 Int)

(declare-fun object__size1 (us_rep) Int)

(declare-const value__alignment1 Int)

(declare-fun object__alignment1 (us_rep) Int)

;; value__size_axiom
  (assert (<= 0 value__size1))

;; object__size_axiom
  (assert (forall ((a us_rep)) (<= 0 (object__size1 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment1))

;; object__alignment_axiom
  (assert (forall ((a us_rep)) (<= 0 (object__alignment1 a))))

(declare-const spaces__angles__angle__theta__first__bit Int)

(declare-const spaces__angles__angle__theta__last__bit Int)

(declare-const spaces__angles__angle__theta__position Int)

;; spaces__angles__angle__theta__first__bit_axiom
  (assert (<= 0 spaces__angles__angle__theta__first__bit))

;; spaces__angles__angle__theta__last__bit_axiom
  (assert
  (< spaces__angles__angle__theta__first__bit spaces__angles__angle__theta__last__bit))

;; spaces__angles__angle__theta__position_axiom
  (assert (<= 0 spaces__angles__angle__theta__position))

(declare-fun user_eq7 (us_rep us_rep) Bool)

(declare-const dummy7 us_rep)

(declare-datatypes () ((angle__ref (mk_angle__ref (angle__content us_rep)))))
(define-fun angle__ref___projection ((a angle__ref)) us_rep (angle__content
                                                            a))

(declare-fun create (tuple0) us_rep)

(declare-fun create__function_guard (us_rep tuple0) Bool)

(declare-fun create__2 (t) us_rep)

(declare-fun create__2__function_guard (us_rep t) Bool)

(declare-fun oadd (us_rep us_rep) us_rep)

(declare-fun oadd__function_guard (us_rep us_rep us_rep) Bool)

(declare-fun osubtract (us_rep us_rep) us_rep)

(declare-fun osubtract__function_guard (us_rep us_rep us_rep) Bool)

(declare-fun dcast (us_rep) t)

(declare-fun dcast__function_guard (t us_rep) Bool)

(declare-fun dcastpi (us_rep) t)

(declare-fun dcastpi__function_guard (t us_rep) Bool)

(declare-fun aldiff (us_rep us_rep) t)

(declare-fun aldiff__function_guard (t us_rep us_rep) Bool)

(declare-fun ccwdiff (us_rep us_rep) t)

(declare-fun ccwdiff__function_guard (t us_rep us_rep) Bool)

(declare-fun cwdiff (us_rep us_rep) t)

(declare-fun cwdiff__function_guard (t us_rep us_rep) Bool)

(declare-fun almostequal (us_rep us_rep t) Bool)

(declare-fun almostequal__function_guard (Bool us_rep us_rep t) Bool)

(declare-fun ccwmean (us_rep us_rep) us_rep)

(declare-fun ccwmean__function_guard (us_rep us_rep us_rep) Bool)

(declare-fun cwmean (us_rep us_rep) us_rep)

(declare-fun cwmean__function_guard (us_rep us_rep us_rep) Bool)

(define-fun dynamic_invariant2 ((temp___expr_96 us_t)
  (temp___is_init_92 Bool) (temp___skip_constant_93 Bool)
  (temp___do_toplevel_94 Bool)
  (temp___do_typ_inv_95 Bool)) Bool (=>
                                    (not (= temp___skip_constant_93 true))
                                    (dynamic_property 1 2147483647
                                    (first1 temp___expr_96)
                                    (last1 temp___expr_96))))

(declare-fun print (us_rep) us_t)

(declare-fun print__function_guard (us_t us_rep) Bool)

(declare-datatypes ()
((us_split_fields2
 (mk___split_fields1
 (rec__spaces__positions__position__x float)(rec__spaces__positions__position__y float)))))
(define-fun us_split_fields_x__projection ((a us_split_fields2)) float
  (rec__spaces__positions__position__x a))

(define-fun us_split_fields_y__projection ((a us_split_fields2)) float
  (rec__spaces__positions__position__y a))

(declare-datatypes ()
((us_split_fields__ref1
 (mk___split_fields__ref1 (us_split_fields__content1 us_split_fields2)))))
(define-fun us_split_fields__ref___2__projection ((a us_split_fields__ref1)) us_split_fields2
  (us_split_fields__content1 a))

(declare-datatypes ()
((us_rep1 (mk___rep1 (us_split_fields3 us_split_fields2)))))
(define-fun us_rep___2__projection ((a us_rep1)) us_split_fields2 (us_split_fields3
                                                                  a))

(define-fun bool_eq6 ((a us_rep1)
  (b us_rep1)) Bool (ite (and
                         (= (to_rep2
                            (rec__spaces__positions__position__x
                            (us_split_fields3 a))) (to_rep2
                                                   (rec__spaces__positions__position__x
                                                   (us_split_fields3 b))))
                         (= (to_rep2
                            (rec__spaces__positions__position__y
                            (us_split_fields3 a))) (to_rep2
                                                   (rec__spaces__positions__position__y
                                                   (us_split_fields3 b)))))
                    true false))

(declare-const value__size2 Int)

(declare-fun object__size2 (us_rep1) Int)

(declare-const value__alignment2 Int)

(declare-fun object__alignment2 (us_rep1) Int)

;; value__size_axiom
  (assert (<= 0 value__size2))

;; object__size_axiom
  (assert (forall ((a us_rep1)) (<= 0 (object__size2 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment2))

;; object__alignment_axiom
  (assert (forall ((a us_rep1)) (<= 0 (object__alignment2 a))))

(declare-const spaces__positions__position__x__first__bit Int)

(declare-const spaces__positions__position__x__last__bit Int)

(declare-const spaces__positions__position__x__position Int)

;; spaces__positions__position__x__first__bit_axiom
  (assert (<= 0 spaces__positions__position__x__first__bit))

;; spaces__positions__position__x__last__bit_axiom
  (assert
  (< spaces__positions__position__x__first__bit spaces__positions__position__x__last__bit))

;; spaces__positions__position__x__position_axiom
  (assert (<= 0 spaces__positions__position__x__position))

(declare-const spaces__positions__position__y__first__bit Int)

(declare-const spaces__positions__position__y__last__bit Int)

(declare-const spaces__positions__position__y__position Int)

;; spaces__positions__position__y__first__bit_axiom
  (assert (<= 0 spaces__positions__position__y__first__bit))

;; spaces__positions__position__y__last__bit_axiom
  (assert
  (< spaces__positions__position__y__first__bit spaces__positions__position__y__last__bit))

;; spaces__positions__position__y__position_axiom
  (assert (<= 0 spaces__positions__position__y__position))

(declare-fun user_eq8 (us_rep1 us_rep1) Bool)

(declare-const dummy8 us_rep1)

(declare-datatypes ()
((position__ref (mk_position__ref (position__content us_rep1)))))
(define-fun position__ref___projection ((a position__ref)) us_rep1 (position__content
                                                                   a))

(declare-fun oeq (us_rep1 us_rep1) Bool)

(declare-fun oeq__function_guard (Bool us_rep1 us_rep1) Bool)

(declare-fun create__4 (t us_rep) us_rep1)

(declare-fun create__4__function_guard (us_rep1 t us_rep) Bool)

(declare-const zero_position us_rep1)

(declare-const attr__ATTRIBUTE_ADDRESS Int)

(declare-fun norm (us_rep1) t)

(declare-fun norm__function_guard (t us_rep1) Bool)

(declare-fun bearing (us_rep1) us_rep)

(declare-fun bearing__function_guard (us_rep us_rep1) Bool)

(declare-fun print1 (us_rep1) us_t)

(declare-fun print__function_guard1 (us_t us_rep1) Bool)

(declare-datatypes ()
((us_split_fields4
 (mk___split_fields2
 (rec__spaces__poses__pose__pos us_rep1)(rec__spaces__poses__pose__ori us_rep)))))
(define-fun us_split_fields_pos__projection ((a us_split_fields4)) us_rep1
  (rec__spaces__poses__pose__pos a))

(define-fun us_split_fields_ori__projection ((a us_split_fields4)) us_rep
  (rec__spaces__poses__pose__ori a))

(declare-datatypes ()
((us_split_fields__ref2
 (mk___split_fields__ref2 (us_split_fields__content2 us_split_fields4)))))
(define-fun us_split_fields__ref___3__projection ((a us_split_fields__ref2)) us_split_fields4
  (us_split_fields__content2 a))

(declare-datatypes ()
((us_rep2 (mk___rep2 (us_split_fields5 us_split_fields4)))))
(define-fun us_rep___3__projection ((a us_rep2)) us_split_fields4 (us_split_fields5
                                                                  a))

(define-fun bool_eq7 ((a us_rep2)
  (b us_rep2)) Bool (ite (and
                         (= (bool_eq6
                            (rec__spaces__poses__pose__pos
                            (us_split_fields5 a))
                            (rec__spaces__poses__pose__pos
                            (us_split_fields5 b))) true)
                         (= (bool_eq5
                            (rec__spaces__poses__pose__ori
                            (us_split_fields5 a))
                            (rec__spaces__poses__pose__ori
                            (us_split_fields5 b))) true))
                    true false))

(declare-const value__size3 Int)

(declare-fun object__size3 (us_rep2) Int)

(declare-const value__alignment3 Int)

(declare-fun object__alignment3 (us_rep2) Int)

;; value__size_axiom
  (assert (<= 0 value__size3))

;; object__size_axiom
  (assert (forall ((a us_rep2)) (<= 0 (object__size3 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment3))

;; object__alignment_axiom
  (assert (forall ((a us_rep2)) (<= 0 (object__alignment3 a))))

(declare-const spaces__poses__pose__pos__first__bit Int)

(declare-const spaces__poses__pose__pos__last__bit Int)

(declare-const spaces__poses__pose__pos__position Int)

;; spaces__poses__pose__pos__first__bit_axiom
  (assert (<= 0 spaces__poses__pose__pos__first__bit))

;; spaces__poses__pose__pos__last__bit_axiom
  (assert
  (< spaces__poses__pose__pos__first__bit spaces__poses__pose__pos__last__bit))

;; spaces__poses__pose__pos__position_axiom
  (assert (<= 0 spaces__poses__pose__pos__position))

(declare-const spaces__poses__pose__ori__first__bit Int)

(declare-const spaces__poses__pose__ori__last__bit Int)

(declare-const spaces__poses__pose__ori__position Int)

;; spaces__poses__pose__ori__first__bit_axiom
  (assert (<= 0 spaces__poses__pose__ori__first__bit))

;; spaces__poses__pose__ori__last__bit_axiom
  (assert
  (< spaces__poses__pose__ori__first__bit spaces__poses__pose__ori__last__bit))

;; spaces__poses__pose__ori__position_axiom
  (assert (<= 0 spaces__poses__pose__ori__position))

(declare-fun user_eq9 (us_rep2 us_rep2) Bool)

(declare-const dummy9 us_rep2)

(declare-datatypes () ((pose__ref (mk_pose__ref (pose__content us_rep2)))))
(define-fun pose__ref___projection ((a pose__ref)) us_rep2 (pose__content a))

(declare-fun create1 (t t us_rep) us_rep2)

(declare-fun create__function_guard1 (us_rep2 t t us_rep) Bool)

(declare-fun osubtract1 (us_rep2 us_rep2) us_rep2)

(declare-fun osubtract__function_guard1 (us_rep2 us_rep2 us_rep2) Bool)

(declare-fun pos (us_rep2) us_rep1)

(declare-fun pos__function_guard (us_rep1 us_rep2) Bool)

(declare-fun ori (us_rep2) us_rep)

(declare-fun ori__function_guard (us_rep us_rep2) Bool)

(declare-fun print2 (us_rep2) us_t)

(declare-fun print__function_guard2 (us_t us_rep2) Bool)

(define-fun to_rep4 ((x natural)) Int (naturalqtint x))

(declare-fun of_rep4 (Int) natural)

;; inversion_axiom
  (assert
  (forall ((x natural))
  (! (= (of_rep4 (to_rep4 x)) x) :pattern ((to_rep4 x)) )))

;; range_axiom
  (assert
  (forall ((x natural)) (! (in_range5 (to_rep4 x)) :pattern ((to_rep4 x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range5 x) (= (to_rep4 (of_rep4 x)) x)) :pattern ((to_rep4
                                                              (of_rep4 x))) )))

(declare-sort positive_float 0)

(define-fun in_range7 ((x t)) Bool (and (tqtisFinite x)
                                   (and (le fliteral2 x) (le x fliteral1))))

(define-fun bool_eq8 ((x t) (y t)) Bool (ite (eq x y) true false))

(declare-fun user_eq10 (positive_float positive_float) Bool)

(declare-fun attr__ATTRIBUTE_IMAGE7 (t) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check7 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE7 (us_image) t)

(declare-const dummy10 positive_float)

(declare-datatypes ()
((positive_float__ref
 (mk_positive_float__ref (positive_float__content positive_float)))))
(define-fun positive_float__ref___projection ((a positive_float__ref)) positive_float
  (positive_float__content a))

(declare-fun to_rep5 (positive_float) t)

(declare-fun of_rep5 (t) positive_float)

;; inversion_axiom
  (assert
  (forall ((x positive_float))
  (! (= (of_rep5 (to_rep5 x)) x) :pattern ((to_rep5 x)) )))

;; range_axiom
  (assert
  (forall ((x positive_float)) (! (in_range7
  (to_rep5 x)) :pattern ((to_rep5 x)) )))

;; coerce_axiom
  (assert
  (forall ((x t))
  (! (=> (in_range7 x) (= (to_rep5 (of_rep5 x)) x)) :pattern ((to_rep5
                                                              (of_rep5 x))) )))

(declare-sort nonnegative_float 0)

(define-fun in_range8 ((x t)) Bool (and (tqtisFinite x)
                                   (and (le fliteral2 x) (le x fliteral1))))

(define-fun bool_eq9 ((x t) (y t)) Bool (ite (eq x y) true false))

(declare-fun user_eq11 (nonnegative_float nonnegative_float) Bool)

(declare-fun attr__ATTRIBUTE_IMAGE8 (t) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check8 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE8 (us_image) t)

(declare-const dummy11 nonnegative_float)

(declare-datatypes ()
((nonnegative_float__ref
 (mk_nonnegative_float__ref (nonnegative_float__content nonnegative_float)))))
(define-fun nonnegative_float__ref___projection ((a nonnegative_float__ref)) nonnegative_float
  (nonnegative_float__content a))

(declare-fun to_rep6 (nonnegative_float) t)

(declare-fun of_rep6 (t) nonnegative_float)

;; inversion_axiom
  (assert
  (forall ((x nonnegative_float))
  (! (= (of_rep6 (to_rep6 x)) x) :pattern ((to_rep6 x)) )))

;; range_axiom
  (assert
  (forall ((x nonnegative_float)) (! (in_range8
  (to_rep6 x)) :pattern ((to_rep6 x)) )))

;; coerce_axiom
  (assert
  (forall ((x t))
  (! (=> (in_range8 x) (= (to_rep6 (of_rep6 x)) x)) :pattern ((to_rep6
                                                              (of_rep6 x))) )))

(declare-sort unbounded_float 0)

(define-fun bool_eq10 ((x t) (y t)) Bool (ite (eq x y) true false))

(declare-fun user_eq12 (unbounded_float unbounded_float) Bool)

(declare-fun attr__ATTRIBUTE_IMAGE9 (t) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check9 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE9 (us_image) t)

(declare-const dummy12 unbounded_float)

(declare-datatypes ()
((unbounded_float__ref
 (mk_unbounded_float__ref (unbounded_float__content unbounded_float)))))
(define-fun unbounded_float__ref___projection ((a unbounded_float__ref)) unbounded_float
  (unbounded_float__content a))

(declare-fun to_rep7 (unbounded_float) t)

(declare-fun of_rep7 (t) unbounded_float)

;; inversion_axiom
  (assert
  (forall ((x unbounded_float))
  (! (= (of_rep7 (to_rep7 x)) x) :pattern ((to_rep7 x)) )))

;; range_axiom
  (assert
  (forall ((x unbounded_float)) (! (tqtisFinite
  (to_rep7 x)) :pattern ((to_rep7 x)) )))

;; coerce_axiom
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (= (to_rep7 (of_rep7 x)) x)) :pattern ((to_rep7
                                                                (of_rep7 x))) )))

(declare-datatypes ()
((map__ref1 (mk_map__ref1 (map__content1 (Array Int nonnegative_float))))))
(declare-fun slide1 ((Array Int nonnegative_float) Int
  Int) (Array Int nonnegative_float))

;; slide_eq
  (assert
  (forall ((a (Array Int nonnegative_float)))
  (forall ((first2 Int))
  (! (= (slide1 a first2 first2) a) :pattern ((slide1 a first2 first2)) ))))

;; slide_def
  (assert
  (forall ((a (Array Int nonnegative_float)))
  (forall ((old_first Int))
  (forall ((new_first Int))
  (forall ((i Int))
  (! (= (select (slide1 a old_first new_first) i) (select a (- i (- new_first old_first)))) :pattern ((select
  (slide1 a old_first new_first) i)) ))))))

(define-fun bool_eq11 ((a (Array Int nonnegative_float)) (a__first Int)
  (a__last Int) (b (Array Int nonnegative_float)) (b__first Int)
  (b__last Int)) Bool (ite (and
                           (ite (<= a__first a__last)
                           (and (<= b__first b__last)
                           (= (- a__last a__first) (- b__last b__first)))
                           (< b__last b__first))
                           (forall ((temp___idx_154 Int))
                           (=>
                           (and (<= a__first temp___idx_154)
                           (<= temp___idx_154 a__last))
                           (= (to_rep6 (select a temp___idx_154)) (to_rep6
                                                                  (select b (+ (- b__first a__first) temp___idx_154)))))))
                      true false))

;; bool_eq_rev
  (assert
  (forall ((a (Array Int nonnegative_float))
  (b (Array Int nonnegative_float)))
  (forall ((a__first Int) (a__last Int) (b__first Int) (b__last Int))
  (=> (= (bool_eq11 b b__first b__last a a__first a__last) true)
  (and
  (ite (<= a__first a__last)
  (and (<= b__first b__last) (= (- a__last a__first) (- b__last b__first)))
  (< b__last b__first))
  (forall ((temp___idx_154 Int))
  (=> (and (<= a__first temp___idx_154) (<= temp___idx_154 a__last))
  (= (to_rep6 (select a temp___idx_154)) (to_rep6
                                         (select b (+ (- b__first a__first) temp___idx_154)))))))))))

(declare-const dummy13 (Array Int nonnegative_float))

(declare-const value__size4 Int)

(declare-fun object__size4 ((Array Int nonnegative_float)) Int)

(declare-const value__component__size1 Int)

(declare-fun object__component__size1 ((Array Int nonnegative_float)) Int)

(declare-const value__alignment4 Int)

(declare-fun object__alignment4 ((Array Int nonnegative_float)) Int)

;; value__size_axiom
  (assert (<= 0 value__size4))

;; object__size_axiom
  (assert
  (forall ((a (Array Int nonnegative_float))) (<= 0 (object__size4 a))))

;; value__component__size_axiom
  (assert (<= 0 value__component__size1))

;; object__component__size_axiom
  (assert
  (forall ((a (Array Int nonnegative_float)))
  (<= 0 (object__component__size1 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment4))

;; object__alignment_axiom
  (assert
  (forall ((a (Array Int nonnegative_float))) (<= 0 (object__alignment4 a))))

(declare-fun user_eq13 ((Array Int nonnegative_float)
  (Array Int nonnegative_float)) Bool)

(declare-sort option 0)

(define-fun in_range9 ((x Int)) Bool (and (<= 0 x) (<= x 1)))

(declare-fun attr__ATTRIBUTE_IMAGE10 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check10 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE10 (us_image) Int)

(declare-fun user_eq14 (option option) Bool)

(declare-const dummy14 option)

(declare-datatypes ()
((option__ref (mk_option__ref (option__content option)))))
(define-fun option__ref___projection ((a option__ref)) option (option__content
                                                              a))

(declare-fun to_rep8 (option) Int)

(declare-fun of_rep8 (Int) option)

;; inversion_axiom
  (assert
  (forall ((x option))
  (! (= (of_rep8 (to_rep8 x)) x) :pattern ((to_rep8 x)) )))

;; range_axiom
  (assert
  (forall ((x option)) (! (in_range9 (to_rep8 x)) :pattern ((to_rep8 x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range9 x) (= (to_rep8 (of_rep8 x)) x)) :pattern ((to_rep8
                                                              (of_rep8 x))) )))

(declare-datatypes ()
((us_split_discrs
 (mk___split_discrs (rec__robot_iface__speed_option__opt option)))))
(define-fun us_split_discrs___projection ((a us_split_discrs)) option
  (rec__robot_iface__speed_option__opt a))

(declare-datatypes ()
((us_split_discrs__ref
 (mk___split_discrs__ref (us_split_discrs__content us_split_discrs)))))
(define-fun us_split_discrs__ref___projection ((a us_split_discrs__ref)) us_split_discrs
  (us_split_discrs__content a))

(declare-datatypes ()
((us_split_fields6
 (mk___split_fields3
 (rec__robot_iface__speed_option__modulus float)(rec__robot_iface__speed_option__angle float)))))
(define-fun us_split_fields_modulus__projection ((a us_split_fields6)) float
  (rec__robot_iface__speed_option__modulus a))

(define-fun us_split_fields_angle__projection ((a us_split_fields6)) float
  (rec__robot_iface__speed_option__angle a))

(declare-datatypes ()
((us_split_fields__ref3
 (mk___split_fields__ref3 (us_split_fields__content3 us_split_fields6)))))
(define-fun us_split_fields__ref___4__projection ((a us_split_fields__ref3)) us_split_fields6
  (us_split_fields__content3 a))

(declare-datatypes ()
((us_rep3
 (mk___rep3
 (us_split_discrs1 us_split_discrs)(us_split_fields7 us_split_fields6)(attr__constrained Bool)))))
(define-fun us_rep___4__projection ((a us_rep3)) us_split_discrs (us_split_discrs1
                                                                 a))

(define-fun us_rep___5__projection ((a us_rep3)) us_split_fields6 (us_split_fields7
                                                                  a))

(define-fun us_rep___6__projection ((a us_rep3)) Bool (attr__constrained a))

(define-fun robot_iface__speed_option__modulus__pred ((a us_rep3)) Bool (=
  (to_rep8 (rec__robot_iface__speed_option__opt (us_split_discrs1 a))) 1))

(define-fun robot_iface__speed_option__angle__pred ((a us_rep3)) Bool (=
  (to_rep8 (rec__robot_iface__speed_option__opt (us_split_discrs1 a))) 1))

(define-fun bool_eq12 ((a us_rep3)
  (b us_rep3)) Bool (ite (and
                         (= (to_rep8
                            (rec__robot_iface__speed_option__opt
                            (us_split_discrs1 a))) (to_rep8
                                                   (rec__robot_iface__speed_option__opt
                                                   (us_split_discrs1 b))))
                         (and
                         (=> (robot_iface__speed_option__modulus__pred a)
                         (= (to_rep2
                            (rec__robot_iface__speed_option__modulus
                            (us_split_fields7 a))) (to_rep2
                                                   (rec__robot_iface__speed_option__modulus
                                                   (us_split_fields7 b)))))
                         (=> (robot_iface__speed_option__angle__pred a)
                         (= (to_rep2
                            (rec__robot_iface__speed_option__angle
                            (us_split_fields7 a))) (to_rep2
                                                   (rec__robot_iface__speed_option__angle
                                                   (us_split_fields7 b)))))))
                    true false))

(declare-const value__size5 Int)

(declare-fun object__size5 (us_rep3) Int)

(declare-const value__alignment5 Int)

(declare-fun object__alignment5 (us_rep3) Int)

;; value__size_axiom
  (assert (<= 0 value__size5))

;; object__size_axiom
  (assert (forall ((a us_rep3)) (<= 0 (object__size5 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment5))

;; object__alignment_axiom
  (assert (forall ((a us_rep3)) (<= 0 (object__alignment5 a))))

(declare-const robot_iface__speed_option__opt__first__bit Int)

(declare-const robot_iface__speed_option__opt__last__bit Int)

(declare-const robot_iface__speed_option__opt__position Int)

;; robot_iface__speed_option__opt__first__bit_axiom
  (assert (<= 0 robot_iface__speed_option__opt__first__bit))

;; robot_iface__speed_option__opt__last__bit_axiom
  (assert
  (< robot_iface__speed_option__opt__first__bit robot_iface__speed_option__opt__last__bit))

;; robot_iface__speed_option__opt__position_axiom
  (assert (<= 0 robot_iface__speed_option__opt__position))

(declare-const robot_iface__speed_option__modulus__first__bit Int)

(declare-const robot_iface__speed_option__modulus__last__bit Int)

(declare-const robot_iface__speed_option__modulus__position Int)

;; robot_iface__speed_option__modulus__first__bit_axiom
  (assert (<= 0 robot_iface__speed_option__modulus__first__bit))

;; robot_iface__speed_option__modulus__last__bit_axiom
  (assert
  (< robot_iface__speed_option__modulus__first__bit robot_iface__speed_option__modulus__last__bit))

;; robot_iface__speed_option__modulus__position_axiom
  (assert (<= 0 robot_iface__speed_option__modulus__position))

(declare-const robot_iface__speed_option__angle__first__bit Int)

(declare-const robot_iface__speed_option__angle__last__bit Int)

(declare-const robot_iface__speed_option__angle__position Int)

;; robot_iface__speed_option__angle__first__bit_axiom
  (assert (<= 0 robot_iface__speed_option__angle__first__bit))

;; robot_iface__speed_option__angle__last__bit_axiom
  (assert
  (< robot_iface__speed_option__angle__first__bit robot_iface__speed_option__angle__last__bit))

;; robot_iface__speed_option__angle__position_axiom
  (assert (<= 0 robot_iface__speed_option__angle__position))

(declare-fun user_eq15 (us_rep3 us_rep3) Bool)

(declare-const dummy15 us_rep3)

(declare-datatypes ()
((speed_option__ref (mk_speed_option__ref (speed_option__content us_rep3)))))
(define-fun speed_option__ref___projection ((a speed_option__ref)) us_rep3
  (speed_option__content a))

(declare-datatypes ()
((us_split_fields8
 (mk___split_fields4
 (rec__robot_iface__proxy__robot_radius positive_float)(rec__robot_iface__proxy__min_gap_width positive_float)(rec__robot_iface__proxy__obstacle_avoid_dist positive_float)(rec__robot_iface__proxy__max_speed positive_float)(rec__robot_iface__proxy__max_turn_rate positive_float)(rec__robot_iface__proxy__goal_position_tol nonnegative_float)(rec__robot_iface__proxy__goal_angle_tol nonnegative_float)(rec__robot_iface__proxy__goalx float)(rec__robot_iface__proxy__goaly float)(rec__robot_iface__proxy__goala float)(rec__robot_iface__proxy__scan_count natural)(rec__robot_iface__proxy__scan_res positive_float)(rec__robot_iface__proxy__max_range positive_float)(rec__robot_iface__proxy__scans (Array Int nonnegative_float))(rec__robot_iface__proxy__x unbounded_float)(rec__robot_iface__proxy__y unbounded_float)(rec__robot_iface__proxy__yaw unbounded_float)(rec__robot_iface__proxy__speed us_rep3)(rec__robot_iface__proxy__goal_reached Bool)))))
(define-fun us_split_fields_robot_radius__projection ((a us_split_fields8)) positive_float
  (rec__robot_iface__proxy__robot_radius a))

(define-fun us_split_fields_min_gap_width__projection ((a us_split_fields8)) positive_float
  (rec__robot_iface__proxy__min_gap_width a))

(define-fun us_split_fields_obstacle_avoid_dist__projection ((a us_split_fields8)) positive_float
  (rec__robot_iface__proxy__obstacle_avoid_dist a))

(define-fun us_split_fields_max_speed__projection ((a us_split_fields8)) positive_float
  (rec__robot_iface__proxy__max_speed a))

(define-fun us_split_fields_max_turn_rate__projection ((a us_split_fields8)) positive_float
  (rec__robot_iface__proxy__max_turn_rate a))

(define-fun us_split_fields_goal_position_tol__projection ((a us_split_fields8)) nonnegative_float
  (rec__robot_iface__proxy__goal_position_tol a))

(define-fun us_split_fields_goal_angle_tol__projection ((a us_split_fields8)) nonnegative_float
  (rec__robot_iface__proxy__goal_angle_tol a))

(define-fun us_split_fields_goalX__projection ((a us_split_fields8)) float
  (rec__robot_iface__proxy__goalx a))

(define-fun us_split_fields_goalY__projection ((a us_split_fields8)) float
  (rec__robot_iface__proxy__goaly a))

(define-fun us_split_fields_goalA__projection ((a us_split_fields8)) float
  (rec__robot_iface__proxy__goala a))

(define-fun us_split_fields_scan_Count__projection ((a us_split_fields8)) natural
  (rec__robot_iface__proxy__scan_count a))

(define-fun us_split_fields_scan_Res__projection ((a us_split_fields8)) positive_float
  (rec__robot_iface__proxy__scan_res a))

(define-fun us_split_fields_max_Range__projection ((a us_split_fields8)) positive_float
  (rec__robot_iface__proxy__max_range a))

(define-fun us_split_fields_scans__projection ((a us_split_fields8)) (Array Int nonnegative_float)
  (rec__robot_iface__proxy__scans a))

(define-fun us_split_fields_X__projection ((a us_split_fields8)) unbounded_float
  (rec__robot_iface__proxy__x a))

(define-fun us_split_fields_Y__projection ((a us_split_fields8)) unbounded_float
  (rec__robot_iface__proxy__y a))

(define-fun us_split_fields_Yaw__projection ((a us_split_fields8)) unbounded_float
  (rec__robot_iface__proxy__yaw a))

(define-fun us_split_fields_speed__projection ((a us_split_fields8)) us_rep3
  (rec__robot_iface__proxy__speed a))

(define-fun us_split_fields_goal_reached__projection ((a us_split_fields8)) Bool
  (rec__robot_iface__proxy__goal_reached a))

(declare-datatypes ()
((us_split_fields__ref4
 (mk___split_fields__ref4 (us_split_fields__content4 us_split_fields8)))))
(define-fun us_split_fields__ref___5__projection ((a us_split_fields__ref4)) us_split_fields8
  (us_split_fields__content4 a))

(declare-datatypes ()
((us_rep4 (mk___rep4 (us_split_fields9 us_split_fields8)))))
(define-fun us_rep___7__projection ((a us_rep4)) us_split_fields8 (us_split_fields9
                                                                  a))

(define-fun bool_eq13 ((a us_rep4)
  (b us_rep4)) Bool (ite (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (and
                         (= (to_rep5
                            (rec__robot_iface__proxy__robot_radius
                            (us_split_fields9 a))) (to_rep5
                                                   (rec__robot_iface__proxy__robot_radius
                                                   (us_split_fields9 b))))
                         (= (to_rep5
                            (rec__robot_iface__proxy__min_gap_width
                            (us_split_fields9 a))) (to_rep5
                                                   (rec__robot_iface__proxy__min_gap_width
                                                   (us_split_fields9 b)))))
                         (= (to_rep5
                            (rec__robot_iface__proxy__obstacle_avoid_dist
                            (us_split_fields9 a))) (to_rep5
                                                   (rec__robot_iface__proxy__obstacle_avoid_dist
                                                   (us_split_fields9 b)))))
                         (= (to_rep5
                            (rec__robot_iface__proxy__max_speed
                            (us_split_fields9 a))) (to_rep5
                                                   (rec__robot_iface__proxy__max_speed
                                                   (us_split_fields9 b)))))
                         (= (to_rep5
                            (rec__robot_iface__proxy__max_turn_rate
                            (us_split_fields9 a))) (to_rep5
                                                   (rec__robot_iface__proxy__max_turn_rate
                                                   (us_split_fields9 b)))))
                         (= (to_rep6
                            (rec__robot_iface__proxy__goal_position_tol
                            (us_split_fields9 a))) (to_rep6
                                                   (rec__robot_iface__proxy__goal_position_tol
                                                   (us_split_fields9 b)))))
                         (= (to_rep6
                            (rec__robot_iface__proxy__goal_angle_tol
                            (us_split_fields9 a))) (to_rep6
                                                   (rec__robot_iface__proxy__goal_angle_tol
                                                   (us_split_fields9 b)))))
                         (= (to_rep2
                            (rec__robot_iface__proxy__goalx
                            (us_split_fields9 a))) (to_rep2
                                                   (rec__robot_iface__proxy__goalx
                                                   (us_split_fields9 b)))))
                         (= (to_rep2
                            (rec__robot_iface__proxy__goaly
                            (us_split_fields9 a))) (to_rep2
                                                   (rec__robot_iface__proxy__goaly
                                                   (us_split_fields9 b)))))
                         (= (to_rep2
                            (rec__robot_iface__proxy__goala
                            (us_split_fields9 a))) (to_rep2
                                                   (rec__robot_iface__proxy__goala
                                                   (us_split_fields9 b)))))
                         (= (to_rep4
                            (rec__robot_iface__proxy__scan_count
                            (us_split_fields9 a))) (to_rep4
                                                   (rec__robot_iface__proxy__scan_count
                                                   (us_split_fields9 b)))))
                         (= (to_rep5
                            (rec__robot_iface__proxy__scan_res
                            (us_split_fields9 a))) (to_rep5
                                                   (rec__robot_iface__proxy__scan_res
                                                   (us_split_fields9 b)))))
                         (= (to_rep5
                            (rec__robot_iface__proxy__max_range
                            (us_split_fields9 a))) (to_rep5
                                                   (rec__robot_iface__proxy__max_range
                                                   (us_split_fields9 b)))))
                         (= (bool_eq11
                            (rec__robot_iface__proxy__scans
                            (us_split_fields9 a)) 1 1000
                            (rec__robot_iface__proxy__scans
                            (us_split_fields9 b)) 1 1000) true))
                         (= (to_rep7
                            (rec__robot_iface__proxy__x (us_split_fields9 a)))
                         (to_rep7
                         (rec__robot_iface__proxy__x (us_split_fields9 b)))))
                         (= (to_rep7
                            (rec__robot_iface__proxy__y (us_split_fields9 a)))
                         (to_rep7
                         (rec__robot_iface__proxy__y (us_split_fields9 b)))))
                         (= (to_rep7
                            (rec__robot_iface__proxy__yaw
                            (us_split_fields9 a))) (to_rep7
                                                   (rec__robot_iface__proxy__yaw
                                                   (us_split_fields9 b)))))
                         (= (bool_eq12
                            (rec__robot_iface__proxy__speed
                            (us_split_fields9 a))
                            (rec__robot_iface__proxy__speed
                            (us_split_fields9 b))) true))
                         (= (rec__robot_iface__proxy__goal_reached
                            (us_split_fields9 a)) (rec__robot_iface__proxy__goal_reached
                                                  (us_split_fields9 b))))
                    true false))

(declare-const value__size6 Int)

(declare-fun object__size6 (us_rep4) Int)

(declare-const value__alignment6 Int)

(declare-fun object__alignment6 (us_rep4) Int)

;; value__size_axiom
  (assert (<= 0 value__size6))

;; object__size_axiom
  (assert (forall ((a us_rep4)) (<= 0 (object__size6 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment6))

;; object__alignment_axiom
  (assert (forall ((a us_rep4)) (<= 0 (object__alignment6 a))))

(declare-const robot_iface__proxy__robot_radius__first__bit Int)

(declare-const robot_iface__proxy__robot_radius__last__bit Int)

(declare-const robot_iface__proxy__robot_radius__position Int)

;; robot_iface__proxy__robot_radius__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__robot_radius__first__bit))

;; robot_iface__proxy__robot_radius__last__bit_axiom
  (assert
  (< robot_iface__proxy__robot_radius__first__bit robot_iface__proxy__robot_radius__last__bit))

;; robot_iface__proxy__robot_radius__position_axiom
  (assert (<= 0 robot_iface__proxy__robot_radius__position))

(declare-const robot_iface__proxy__min_gap_width__first__bit Int)

(declare-const robot_iface__proxy__min_gap_width__last__bit Int)

(declare-const robot_iface__proxy__min_gap_width__position Int)

;; robot_iface__proxy__min_gap_width__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__min_gap_width__first__bit))

;; robot_iface__proxy__min_gap_width__last__bit_axiom
  (assert
  (< robot_iface__proxy__min_gap_width__first__bit robot_iface__proxy__min_gap_width__last__bit))

;; robot_iface__proxy__min_gap_width__position_axiom
  (assert (<= 0 robot_iface__proxy__min_gap_width__position))

(declare-const robot_iface__proxy__obstacle_avoid_dist__first__bit Int)

(declare-const robot_iface__proxy__obstacle_avoid_dist__last__bit Int)

(declare-const robot_iface__proxy__obstacle_avoid_dist__position Int)

;; robot_iface__proxy__obstacle_avoid_dist__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__obstacle_avoid_dist__first__bit))

;; robot_iface__proxy__obstacle_avoid_dist__last__bit_axiom
  (assert
  (< robot_iface__proxy__obstacle_avoid_dist__first__bit robot_iface__proxy__obstacle_avoid_dist__last__bit))

;; robot_iface__proxy__obstacle_avoid_dist__position_axiom
  (assert (<= 0 robot_iface__proxy__obstacle_avoid_dist__position))

(declare-const robot_iface__proxy__max_speed__first__bit Int)

(declare-const robot_iface__proxy__max_speed__last__bit Int)

(declare-const robot_iface__proxy__max_speed__position Int)

;; robot_iface__proxy__max_speed__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__max_speed__first__bit))

;; robot_iface__proxy__max_speed__last__bit_axiom
  (assert
  (< robot_iface__proxy__max_speed__first__bit robot_iface__proxy__max_speed__last__bit))

;; robot_iface__proxy__max_speed__position_axiom
  (assert (<= 0 robot_iface__proxy__max_speed__position))

(declare-const robot_iface__proxy__max_turn_rate__first__bit Int)

(declare-const robot_iface__proxy__max_turn_rate__last__bit Int)

(declare-const robot_iface__proxy__max_turn_rate__position Int)

;; robot_iface__proxy__max_turn_rate__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__max_turn_rate__first__bit))

;; robot_iface__proxy__max_turn_rate__last__bit_axiom
  (assert
  (< robot_iface__proxy__max_turn_rate__first__bit robot_iface__proxy__max_turn_rate__last__bit))

;; robot_iface__proxy__max_turn_rate__position_axiom
  (assert (<= 0 robot_iface__proxy__max_turn_rate__position))

(declare-const robot_iface__proxy__goal_position_tol__first__bit Int)

(declare-const robot_iface__proxy__goal_position_tol__last__bit Int)

(declare-const robot_iface__proxy__goal_position_tol__position Int)

;; robot_iface__proxy__goal_position_tol__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__goal_position_tol__first__bit))

;; robot_iface__proxy__goal_position_tol__last__bit_axiom
  (assert
  (< robot_iface__proxy__goal_position_tol__first__bit robot_iface__proxy__goal_position_tol__last__bit))

;; robot_iface__proxy__goal_position_tol__position_axiom
  (assert (<= 0 robot_iface__proxy__goal_position_tol__position))

(declare-const robot_iface__proxy__goal_angle_tol__first__bit Int)

(declare-const robot_iface__proxy__goal_angle_tol__last__bit Int)

(declare-const robot_iface__proxy__goal_angle_tol__position Int)

;; robot_iface__proxy__goal_angle_tol__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__goal_angle_tol__first__bit))

;; robot_iface__proxy__goal_angle_tol__last__bit_axiom
  (assert
  (< robot_iface__proxy__goal_angle_tol__first__bit robot_iface__proxy__goal_angle_tol__last__bit))

;; robot_iface__proxy__goal_angle_tol__position_axiom
  (assert (<= 0 robot_iface__proxy__goal_angle_tol__position))

(declare-const robot_iface__proxy__goalx__first__bit Int)

(declare-const robot_iface__proxy__goalx__last__bit Int)

(declare-const robot_iface__proxy__goalx__position Int)

;; robot_iface__proxy__goalx__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__goalx__first__bit))

;; robot_iface__proxy__goalx__last__bit_axiom
  (assert
  (< robot_iface__proxy__goalx__first__bit robot_iface__proxy__goalx__last__bit))

;; robot_iface__proxy__goalx__position_axiom
  (assert (<= 0 robot_iface__proxy__goalx__position))

(declare-const robot_iface__proxy__goaly__first__bit Int)

(declare-const robot_iface__proxy__goaly__last__bit Int)

(declare-const robot_iface__proxy__goaly__position Int)

;; robot_iface__proxy__goaly__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__goaly__first__bit))

;; robot_iface__proxy__goaly__last__bit_axiom
  (assert
  (< robot_iface__proxy__goaly__first__bit robot_iface__proxy__goaly__last__bit))

;; robot_iface__proxy__goaly__position_axiom
  (assert (<= 0 robot_iface__proxy__goaly__position))

(declare-const robot_iface__proxy__goala__first__bit Int)

(declare-const robot_iface__proxy__goala__last__bit Int)

(declare-const robot_iface__proxy__goala__position Int)

;; robot_iface__proxy__goala__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__goala__first__bit))

;; robot_iface__proxy__goala__last__bit_axiom
  (assert
  (< robot_iface__proxy__goala__first__bit robot_iface__proxy__goala__last__bit))

;; robot_iface__proxy__goala__position_axiom
  (assert (<= 0 robot_iface__proxy__goala__position))

(declare-const robot_iface__proxy__scan_count__first__bit Int)

(declare-const robot_iface__proxy__scan_count__last__bit Int)

(declare-const robot_iface__proxy__scan_count__position Int)

;; robot_iface__proxy__scan_count__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__scan_count__first__bit))

;; robot_iface__proxy__scan_count__last__bit_axiom
  (assert
  (< robot_iface__proxy__scan_count__first__bit robot_iface__proxy__scan_count__last__bit))

;; robot_iface__proxy__scan_count__position_axiom
  (assert (<= 0 robot_iface__proxy__scan_count__position))

(declare-const robot_iface__proxy__scan_res__first__bit Int)

(declare-const robot_iface__proxy__scan_res__last__bit Int)

(declare-const robot_iface__proxy__scan_res__position Int)

;; robot_iface__proxy__scan_res__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__scan_res__first__bit))

;; robot_iface__proxy__scan_res__last__bit_axiom
  (assert
  (< robot_iface__proxy__scan_res__first__bit robot_iface__proxy__scan_res__last__bit))

;; robot_iface__proxy__scan_res__position_axiom
  (assert (<= 0 robot_iface__proxy__scan_res__position))

(declare-const robot_iface__proxy__max_range__first__bit Int)

(declare-const robot_iface__proxy__max_range__last__bit Int)

(declare-const robot_iface__proxy__max_range__position Int)

;; robot_iface__proxy__max_range__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__max_range__first__bit))

;; robot_iface__proxy__max_range__last__bit_axiom
  (assert
  (< robot_iface__proxy__max_range__first__bit robot_iface__proxy__max_range__last__bit))

;; robot_iface__proxy__max_range__position_axiom
  (assert (<= 0 robot_iface__proxy__max_range__position))

(declare-const robot_iface__proxy__scans__first__bit Int)

(declare-const robot_iface__proxy__scans__last__bit Int)

(declare-const robot_iface__proxy__scans__position Int)

;; robot_iface__proxy__scans__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__scans__first__bit))

;; robot_iface__proxy__scans__last__bit_axiom
  (assert
  (< robot_iface__proxy__scans__first__bit robot_iface__proxy__scans__last__bit))

;; robot_iface__proxy__scans__position_axiom
  (assert (<= 0 robot_iface__proxy__scans__position))

(declare-const robot_iface__proxy__x__first__bit Int)

(declare-const robot_iface__proxy__x__last__bit Int)

(declare-const robot_iface__proxy__x__position Int)

;; robot_iface__proxy__x__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__x__first__bit))

;; robot_iface__proxy__x__last__bit_axiom
  (assert
  (< robot_iface__proxy__x__first__bit robot_iface__proxy__x__last__bit))

;; robot_iface__proxy__x__position_axiom
  (assert (<= 0 robot_iface__proxy__x__position))

(declare-const robot_iface__proxy__y__first__bit Int)

(declare-const robot_iface__proxy__y__last__bit Int)

(declare-const robot_iface__proxy__y__position Int)

;; robot_iface__proxy__y__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__y__first__bit))

;; robot_iface__proxy__y__last__bit_axiom
  (assert
  (< robot_iface__proxy__y__first__bit robot_iface__proxy__y__last__bit))

;; robot_iface__proxy__y__position_axiom
  (assert (<= 0 robot_iface__proxy__y__position))

(declare-const robot_iface__proxy__yaw__first__bit Int)

(declare-const robot_iface__proxy__yaw__last__bit Int)

(declare-const robot_iface__proxy__yaw__position Int)

;; robot_iface__proxy__yaw__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__yaw__first__bit))

;; robot_iface__proxy__yaw__last__bit_axiom
  (assert
  (< robot_iface__proxy__yaw__first__bit robot_iface__proxy__yaw__last__bit))

;; robot_iface__proxy__yaw__position_axiom
  (assert (<= 0 robot_iface__proxy__yaw__position))

(declare-const robot_iface__proxy__speed__first__bit Int)

(declare-const robot_iface__proxy__speed__last__bit Int)

(declare-const robot_iface__proxy__speed__position Int)

;; robot_iface__proxy__speed__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__speed__first__bit))

;; robot_iface__proxy__speed__last__bit_axiom
  (assert
  (< robot_iface__proxy__speed__first__bit robot_iface__proxy__speed__last__bit))

;; robot_iface__proxy__speed__position_axiom
  (assert (<= 0 robot_iface__proxy__speed__position))

(declare-const robot_iface__proxy__goal_reached__first__bit Int)

(declare-const robot_iface__proxy__goal_reached__last__bit Int)

(declare-const robot_iface__proxy__goal_reached__position Int)

;; robot_iface__proxy__goal_reached__first__bit_axiom
  (assert (<= 0 robot_iface__proxy__goal_reached__first__bit))

;; robot_iface__proxy__goal_reached__last__bit_axiom
  (assert
  (< robot_iface__proxy__goal_reached__first__bit robot_iface__proxy__goal_reached__last__bit))

;; robot_iface__proxy__goal_reached__position_axiom
  (assert (<= 0 robot_iface__proxy__goal_reached__position))

(declare-fun user_eq16 (us_rep4 us_rep4) Bool)

(declare-const dummy16 us_rep4)

(declare-datatypes ()
((proxy__ref (mk_proxy__ref (proxy__content us_rep4)))))
(define-fun proxy__ref___projection ((a proxy__ref)) us_rep4 (proxy__content
                                                             a))

(declare-fun getscancount (us_rep4) Int)

(declare-fun getscancount__function_guard (Int us_rep4) Bool)

(declare-fun getrange (us_rep4 Int) t)

(declare-fun getrange__function_guard (t us_rep4 Int) Bool)

(define-fun dynamic_invariant3 ((temp___expr_170 t) (temp___is_init_166 Bool)
  (temp___skip_constant_167 Bool) (temp___do_toplevel_168 Bool)
  (temp___do_typ_inv_169 Bool)) Bool (=>
                                     (or (= temp___is_init_166 true) (le
                                     fliteral2 fliteral1)) (in_range8
                                     temp___expr_170)))

(declare-fun getxpos (us_rep4) t)

(declare-fun getxpos__function_guard (t us_rep4) Bool)

(declare-fun getypos (us_rep4) t)

(declare-fun getypos__function_guard (t us_rep4) Bool)

(declare-fun getyaw (us_rep4) t)

(declare-fun getyaw__function_guard (t us_rep4) Bool)

(define-fun dynamic_invariant4 ((temp___expr_272 us_rep4)
  (temp___is_init_268 Bool) (temp___skip_constant_269 Bool)
  (temp___do_toplevel_270 Bool)
  (temp___do_typ_inv_271 Bool)) Bool (= (attr__constrained
                                        (rec__robot_iface__proxy__speed
                                        (us_split_fields9 temp___expr_272))) false))

(define-fun default_initial_assumption ((temp___expr_275 us_rep4)
  (temp___skip_top_level_276 Bool)) Bool (and
                                         (= (attr__constrained
                                            (rec__robot_iface__proxy__speed
                                            (us_split_fields9
                                            temp___expr_275))) false)
                                         (= (to_rep8
                                            (rec__robot_iface__speed_option__opt
                                            (us_split_discrs1
                                            (rec__robot_iface__proxy__speed
                                            (us_split_fields9
                                            temp___expr_275))))) 0)))

(declare-sort idir_t 0)

(declare-fun idir_tqtint (idir_t) Int)

;; idir_t'axiom
  (assert
  (forall ((i idir_t))
  (and (<= (- 1) (idir_tqtint i)) (<= (idir_tqtint i) 1))))

(define-fun in_range10 ((x Int)) Bool (and (<= (- 1) x) (<= x 1)))

(declare-fun attr__ATTRIBUTE_IMAGE11 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check11 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE11 (us_image) Int)

(declare-fun user_eq17 (idir_t idir_t) Bool)

(declare-const dummy17 idir_t)

(declare-datatypes ()
((idir_t__ref (mk_idir_t__ref (idir_t__content idir_t)))))
(define-fun idir_t__ref___projection ((a idir_t__ref)) idir_t (idir_t__content
                                                              a))

(define-fun to_rep9 ((x idir_t)) Int (idir_tqtint x))

(declare-fun of_rep9 (Int) idir_t)

;; inversion_axiom
  (assert
  (forall ((x idir_t))
  (! (= (of_rep9 (to_rep9 x)) x) :pattern ((to_rep9 x)) )))

;; range_axiom
  (assert
  (forall ((x idir_t)) (! (in_range10 (to_rep9 x)) :pattern ((to_rep9 x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range10 x) (= (to_rep9 (of_rep9 x)) x)) :pattern ((to_rep9
                                                               (of_rep9 x))) )))

(declare-datatypes ()
((us_split_fields10
 (mk___split_fields5
 (rec__gaps__gap__bearing us_rep)(rec__gaps__gap__distance float)(rec__gaps__gap__idir idir_t)))))
(define-fun us_split_fields_bearing__projection ((a us_split_fields10)) us_rep
  (rec__gaps__gap__bearing a))

(define-fun us_split_fields_distance__projection ((a us_split_fields10)) float
  (rec__gaps__gap__distance a))

(define-fun us_split_fields_iDir__projection ((a us_split_fields10)) idir_t
  (rec__gaps__gap__idir a))

(declare-datatypes ()
((us_split_fields__ref5
 (mk___split_fields__ref5 (us_split_fields__content5 us_split_fields10)))))
(define-fun us_split_fields__ref___6__projection ((a us_split_fields__ref5)) us_split_fields10
  (us_split_fields__content5 a))

(declare-datatypes ()
((us_rep5 (mk___rep5 (us_split_fields11 us_split_fields10)))))
(define-fun us_rep___8__projection ((a us_rep5)) us_split_fields10 (us_split_fields11
                                                                   a))

(define-fun bool_eq14 ((a us_rep5)
  (b us_rep5)) Bool (ite (and
                         (and
                         (= (bool_eq5
                            (rec__gaps__gap__bearing (us_split_fields11 a))
                            (rec__gaps__gap__bearing (us_split_fields11 b))) true)
                         (= (to_rep2
                            (rec__gaps__gap__distance (us_split_fields11 a)))
                         (to_rep2
                         (rec__gaps__gap__distance (us_split_fields11 b)))))
                         (= (to_rep9
                            (rec__gaps__gap__idir (us_split_fields11 a)))
                         (to_rep9
                         (rec__gaps__gap__idir (us_split_fields11 b)))))
                    true false))

(declare-const value__size7 Int)

(declare-fun object__size7 (us_rep5) Int)

(declare-const value__alignment7 Int)

(declare-fun object__alignment7 (us_rep5) Int)

;; value__size_axiom
  (assert (<= 0 value__size7))

;; object__size_axiom
  (assert (forall ((a us_rep5)) (<= 0 (object__size7 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment7))

;; object__alignment_axiom
  (assert (forall ((a us_rep5)) (<= 0 (object__alignment7 a))))

(declare-const gaps__gap__bearing__first__bit Int)

(declare-const gaps__gap__bearing__last__bit Int)

(declare-const gaps__gap__bearing__position Int)

;; gaps__gap__bearing__first__bit_axiom
  (assert (<= 0 gaps__gap__bearing__first__bit))

;; gaps__gap__bearing__last__bit_axiom
  (assert (< gaps__gap__bearing__first__bit gaps__gap__bearing__last__bit))

;; gaps__gap__bearing__position_axiom
  (assert (<= 0 gaps__gap__bearing__position))

(declare-const gaps__gap__distance__first__bit Int)

(declare-const gaps__gap__distance__last__bit Int)

(declare-const gaps__gap__distance__position Int)

;; gaps__gap__distance__first__bit_axiom
  (assert (<= 0 gaps__gap__distance__first__bit))

;; gaps__gap__distance__last__bit_axiom
  (assert (< gaps__gap__distance__first__bit gaps__gap__distance__last__bit))

;; gaps__gap__distance__position_axiom
  (assert (<= 0 gaps__gap__distance__position))

(declare-const gaps__gap__idir__first__bit Int)

(declare-const gaps__gap__idir__last__bit Int)

(declare-const gaps__gap__idir__position Int)

;; gaps__gap__idir__first__bit_axiom
  (assert (<= 0 gaps__gap__idir__first__bit))

;; gaps__gap__idir__last__bit_axiom
  (assert (< gaps__gap__idir__first__bit gaps__gap__idir__last__bit))

;; gaps__gap__idir__position_axiom
  (assert (<= 0 gaps__gap__idir__position))

(declare-fun user_eq18 (us_rep5 us_rep5) Bool)

(declare-const dummy18 us_rep5)

(declare-datatypes () ((gap__ref (mk_gap__ref (gap__content us_rep5)))))
(define-fun gap__ref___projection ((a gap__ref)) us_rep5 (gap__content a))

(declare-datatypes ()
((us_split_fields12
 (mk___split_fields6
 (rec__valleys__valley__risinggap us_rep5)(rec__valleys__valley__othergap us_rep5)))))
(define-fun us_split_fields_risingGap__projection ((a us_split_fields12)) us_rep5
  (rec__valleys__valley__risinggap a))

(define-fun us_split_fields_otherGap__projection ((a us_split_fields12)) us_rep5
  (rec__valleys__valley__othergap a))

(declare-datatypes ()
((us_split_fields__ref6
 (mk___split_fields__ref6 (us_split_fields__content6 us_split_fields12)))))
(define-fun us_split_fields__ref___7__projection ((a us_split_fields__ref6)) us_split_fields12
  (us_split_fields__content6 a))

(declare-datatypes ()
((us_rep6 (mk___rep6 (us_split_fields13 us_split_fields12)))))
(define-fun us_rep___9__projection ((a us_rep6)) us_split_fields12 (us_split_fields13
                                                                   a))

(define-fun bool_eq15 ((a us_rep6)
  (b us_rep6)) Bool (ite (and
                         (= (bool_eq14
                            (rec__valleys__valley__risinggap
                            (us_split_fields13 a))
                            (rec__valleys__valley__risinggap
                            (us_split_fields13 b))) true)
                         (= (bool_eq14
                            (rec__valleys__valley__othergap
                            (us_split_fields13 a))
                            (rec__valleys__valley__othergap
                            (us_split_fields13 b))) true))
                    true false))

(declare-const value__size8 Int)

(declare-fun object__size8 (us_rep6) Int)

(declare-const value__alignment8 Int)

(declare-fun object__alignment8 (us_rep6) Int)

;; value__size_axiom
  (assert (<= 0 value__size8))

;; object__size_axiom
  (assert (forall ((a us_rep6)) (<= 0 (object__size8 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment8))

;; object__alignment_axiom
  (assert (forall ((a us_rep6)) (<= 0 (object__alignment8 a))))

(declare-const valleys__valley__risinggap__first__bit Int)

(declare-const valleys__valley__risinggap__last__bit Int)

(declare-const valleys__valley__risinggap__position Int)

;; valleys__valley__risinggap__first__bit_axiom
  (assert (<= 0 valleys__valley__risinggap__first__bit))

;; valleys__valley__risinggap__last__bit_axiom
  (assert
  (< valleys__valley__risinggap__first__bit valleys__valley__risinggap__last__bit))

;; valleys__valley__risinggap__position_axiom
  (assert (<= 0 valleys__valley__risinggap__position))

(declare-const valleys__valley__othergap__first__bit Int)

(declare-const valleys__valley__othergap__last__bit Int)

(declare-const valleys__valley__othergap__position Int)

;; valleys__valley__othergap__first__bit_axiom
  (assert (<= 0 valleys__valley__othergap__first__bit))

;; valleys__valley__othergap__last__bit_axiom
  (assert
  (< valleys__valley__othergap__first__bit valleys__valley__othergap__last__bit))

;; valleys__valley__othergap__position_axiom
  (assert (<= 0 valleys__valley__othergap__position))

(declare-fun user_eq19 (us_rep6 us_rep6) Bool)

(declare-const dummy19 us_rep6)

(declare-datatypes ()
((valley__ref (mk_valley__ref (valley__content us_rep6)))))
(define-fun valley__ref___projection ((a valley__ref)) us_rep6 (valley__content
                                                               a))

(declare-datatypes ()
((us_split_fields14
 (mk___split_fields7
 (rec__algorithm__laser_scan_data__first nonnegative_float)(rec__algorithm__laser_scan_data__second us_rep)))))
(define-fun us_split_fields_first__projection ((a us_split_fields14)) nonnegative_float
  (rec__algorithm__laser_scan_data__first a))

(define-fun us_split_fields_second__projection ((a us_split_fields14)) us_rep
  (rec__algorithm__laser_scan_data__second a))

(declare-datatypes ()
((us_split_fields__ref7
 (mk___split_fields__ref7 (us_split_fields__content7 us_split_fields14)))))
(define-fun us_split_fields__ref___11__projection ((a us_split_fields__ref7)) us_split_fields14
  (us_split_fields__content7 a))

(declare-datatypes ()
((us_rep7 (mk___rep7 (us_split_fields15 us_split_fields14)))))
(define-fun us_rep___16__projection ((a us_rep7)) us_split_fields14 (us_split_fields15
                                                                    a))

(define-fun bool_eq16 ((a us_rep7)
  (b us_rep7)) Bool (ite (and
                         (= (to_rep6
                            (rec__algorithm__laser_scan_data__first
                            (us_split_fields15 a))) (to_rep6
                                                    (rec__algorithm__laser_scan_data__first
                                                    (us_split_fields15 b))))
                         (= (bool_eq5
                            (rec__algorithm__laser_scan_data__second
                            (us_split_fields15 a))
                            (rec__algorithm__laser_scan_data__second
                            (us_split_fields15 b))) true))
                    true false))

(declare-const value__size9 Int)

(declare-fun object__size9 (us_rep7) Int)

(declare-const value__alignment9 Int)

(declare-fun object__alignment9 (us_rep7) Int)

;; value__size_axiom
  (assert (<= 0 value__size9))

;; object__size_axiom
  (assert (forall ((a us_rep7)) (<= 0 (object__size9 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment9))

;; object__alignment_axiom
  (assert (forall ((a us_rep7)) (<= 0 (object__alignment9 a))))

(declare-const algorithm__laser_scan_data__first__first__bit Int)

(declare-const algorithm__laser_scan_data__first__last__bit Int)

(declare-const algorithm__laser_scan_data__first__position Int)

;; algorithm__laser_scan_data__first__first__bit_axiom
  (assert (<= 0 algorithm__laser_scan_data__first__first__bit))

;; algorithm__laser_scan_data__first__last__bit_axiom
  (assert
  (< algorithm__laser_scan_data__first__first__bit algorithm__laser_scan_data__first__last__bit))

;; algorithm__laser_scan_data__first__position_axiom
  (assert (<= 0 algorithm__laser_scan_data__first__position))

(declare-const algorithm__laser_scan_data__second__first__bit Int)

(declare-const algorithm__laser_scan_data__second__last__bit Int)

(declare-const algorithm__laser_scan_data__second__position Int)

;; algorithm__laser_scan_data__second__first__bit_axiom
  (assert (<= 0 algorithm__laser_scan_data__second__first__bit))

;; algorithm__laser_scan_data__second__last__bit_axiom
  (assert
  (< algorithm__laser_scan_data__second__first__bit algorithm__laser_scan_data__second__last__bit))

;; algorithm__laser_scan_data__second__position_axiom
  (assert (<= 0 algorithm__laser_scan_data__second__position))

(declare-fun user_eq20 (us_rep7 us_rep7) Bool)

(declare-const dummy20 us_rep7)

(declare-datatypes ()
((laser_scan_data__ref
 (mk_laser_scan_data__ref (laser_scan_data__content us_rep7)))))
(define-fun laser_scan_data__ref___projection ((a laser_scan_data__ref)) us_rep7
  (laser_scan_data__content a))

(declare-datatypes ()
((map__ref2 (mk_map__ref2 (map__content2 (Array Int us_rep7))))))
(declare-fun slide2 ((Array Int us_rep7) Int Int) (Array Int us_rep7))

;; slide_eq
  (assert
  (forall ((a (Array Int us_rep7)))
  (forall ((first2 Int))
  (! (= (slide2 a first2 first2) a) :pattern ((slide2 a first2 first2)) ))))

;; slide_def
  (assert
  (forall ((a (Array Int us_rep7)))
  (forall ((old_first Int))
  (forall ((new_first Int))
  (forall ((i Int))
  (! (= (select (slide2 a old_first new_first) i) (select a (- i (- new_first old_first)))) :pattern ((select
  (slide2 a old_first new_first) i)) ))))))

(define-fun bool_eq17 ((a (Array Int us_rep7)) (a__first Int) (a__last Int)
  (b (Array Int us_rep7)) (b__first Int)
  (b__last Int)) Bool (ite (and
                           (ite (<= a__first a__last)
                           (and (<= b__first b__last)
                           (= (- a__last a__first) (- b__last b__first)))
                           (< b__last b__first))
                           (forall ((temp___idx_155 Int))
                           (=>
                           (and (<= a__first temp___idx_155)
                           (<= temp___idx_155 a__last))
                           (= (bool_eq16 (select a temp___idx_155)
                              (select b (+ (- b__first a__first) temp___idx_155))) true))))
                      true false))

;; bool_eq_rev
  (assert
  (forall ((a (Array Int us_rep7)) (b (Array Int us_rep7)))
  (forall ((a__first Int) (a__last Int) (b__first Int) (b__last Int))
  (=> (= (bool_eq17 b b__first b__last a a__first a__last) true)
  (and
  (ite (<= a__first a__last)
  (and (<= b__first b__last) (= (- a__last a__first) (- b__last b__first)))
  (< b__last b__first))
  (forall ((temp___idx_155 Int))
  (=> (and (<= a__first temp___idx_155) (<= temp___idx_155 a__last))
  (= (bool_eq16 (select a temp___idx_155)
     (select b (+ (- b__first a__first) temp___idx_155))) true))))))))

(declare-fun isfilterclear ((Array Int us_rep7) us_rep t t Bool) Bool)

(declare-fun isfilterclear__function_guard (Bool (Array Int us_rep7) us_rep t
  t Bool) Bool)

(declare-sort count_type 0)

(declare-fun count_typeqtint (count_type) Int)

;; count_type'axiom
  (assert
  (forall ((i count_type))
  (and (<= 0 (count_typeqtint i)) (<= (count_typeqtint i) 2147483647))))

(define-fun in_range11 ((x Int)) Bool (and (<= 0 x) (<= x 2147483647)))

(declare-fun attr__ATTRIBUTE_IMAGE12 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check12 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE12 (us_image) Int)

(declare-fun user_eq21 (count_type count_type) Bool)

(declare-const dummy21 count_type)

(declare-datatypes ()
((count_type__ref (mk_count_type__ref (count_type__content count_type)))))
(define-fun count_type__ref___projection ((a count_type__ref)) count_type
  (count_type__content a))

(define-fun to_rep10 ((x count_type)) Int (count_typeqtint x))

(declare-fun of_rep10 (Int) count_type)

;; inversion_axiom
  (assert
  (forall ((x count_type))
  (! (= (of_rep10 (to_rep10 x)) x) :pattern ((to_rep10 x)) )))

;; range_axiom
  (assert
  (forall ((x count_type)) (! (in_range11
  (to_rep10 x)) :pattern ((to_rep10 x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range11 x) (= (to_rep10 (of_rep10 x)) x)) :pattern ((to_rep10
                                                                 (of_rep10 x))) )))

(declare-sort us_main_type 0)

(declare-fun us_main_eq (us_main_type us_main_type) Bool)

(declare-datatypes ()
((us_split_discrs2
 (mk___split_discrs1
 (rec__algorithm__gap_vectors__list__capacity count_type)))))
(define-fun us_split_discrs___3__projection ((a us_split_discrs2)) count_type
  (rec__algorithm__gap_vectors__list__capacity a))

(declare-datatypes ()
((us_split_discrs__ref1
 (mk___split_discrs__ref1 (us_split_discrs__content1 us_split_discrs2)))))
(define-fun us_split_discrs__ref___3__projection ((a us_split_discrs__ref1)) us_split_discrs2
  (us_split_discrs__content1 a))

(declare-datatypes ()
((us_split_fields16
 (mk___split_fields8 (rec__algorithm__gap_vectors__list us_main_type)))))
(define-fun us_split_fields_List__projection ((a us_split_fields16)) us_main_type
  (rec__algorithm__gap_vectors__list a))

(declare-datatypes ()
((us_split_fields__ref8
 (mk___split_fields__ref8 (us_split_fields__content8 us_split_fields16)))))
(define-fun us_split_fields__ref___9__projection ((a us_split_fields__ref8)) us_split_fields16
  (us_split_fields__content8 a))

(declare-datatypes ()
((us_rep8
 (mk___rep8
 (us_split_discrs3 us_split_discrs2)(us_split_fields17 us_split_fields16)))))
(define-fun us_rep___13__projection ((a us_rep8)) us_split_discrs2 (us_split_discrs3
                                                                   a))

(define-fun us_rep___14__projection ((a us_rep8)) us_split_fields16 (us_split_fields17
                                                                    a))

(define-fun bool_eq18 ((a us_rep8)
  (b us_rep8)) Bool (ite (and
                         (= (to_rep10
                            (rec__algorithm__gap_vectors__list__capacity
                            (us_split_discrs3 a))) (to_rep10
                                                   (rec__algorithm__gap_vectors__list__capacity
                                                   (us_split_discrs3 b))))
                         (= (us_main_eq
                            (rec__algorithm__gap_vectors__list
                            (us_split_fields17 a))
                            (rec__algorithm__gap_vectors__list
                            (us_split_fields17 b))) true))
                    true false))

(declare-const value__size10 Int)

(declare-fun object__size10 (us_rep8) Int)

(declare-const value__alignment10 Int)

(declare-fun object__alignment10 (us_rep8) Int)

;; value__size_axiom
  (assert (<= 0 value__size10))

;; object__size_axiom
  (assert (forall ((a us_rep8)) (<= 0 (object__size10 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment10))

;; object__alignment_axiom
  (assert (forall ((a us_rep8)) (<= 0 (object__alignment10 a))))

(declare-const algorithm__gap_vectors__list__capacity__first__bit Int)

(declare-const algorithm__gap_vectors__list__capacity__last__bit Int)

(declare-const algorithm__gap_vectors__list__capacity__position Int)

;; algorithm__gap_vectors__list__capacity__first__bit_axiom
  (assert (<= 0 algorithm__gap_vectors__list__capacity__first__bit))

;; algorithm__gap_vectors__list__capacity__last__bit_axiom
  (assert
  (< algorithm__gap_vectors__list__capacity__first__bit algorithm__gap_vectors__list__capacity__last__bit))

;; algorithm__gap_vectors__list__capacity__position_axiom
  (assert (<= 0 algorithm__gap_vectors__list__capacity__position))

(declare-fun user_eq22 (us_rep8 us_rep8) Bool)

(declare-const dummy22 us_rep8)

(declare-datatypes () ((list__ref (mk_list__ref (list__content us_rep8)))))
(define-fun list__ref___projection ((a list__ref)) us_rep8 (list__content a))

(define-fun in_range12 ((rec__algorithm__gap_vectors__list__capacity1 Int)
  (a us_rep8)) Bool (= rec__algorithm__gap_vectors__list__capacity1 (to_rep10
                                                                    (rec__algorithm__gap_vectors__list__capacity
                                                                    (us_split_discrs3
                                                                    a)))))

(declare-const value__size11 Int)

(declare-fun object__size11 (us_rep8) Int)

(declare-const value__alignment11 Int)

(declare-fun object__alignment11 (us_rep8) Int)

;; value__size_axiom
  (assert (<= 0 value__size11))

;; object__size_axiom
  (assert (forall ((a us_rep8)) (<= 0 (object__size11 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment11))

;; object__alignment_axiom
  (assert (forall ((a us_rep8)) (<= 0 (object__alignment11 a))))

(declare-const algorithm__gap_vectors__list__capacity__first__bit1 Int)

(declare-const algorithm__gap_vectors__list__capacity__last__bit1 Int)

(declare-const algorithm__gap_vectors__list__capacity__position1 Int)

;; algorithm__gap_vectors__list__capacity__first__bit_axiom
  (assert (<= 0 algorithm__gap_vectors__list__capacity__first__bit1))

;; algorithm__gap_vectors__list__capacity__last__bit_axiom
  (assert
  (< algorithm__gap_vectors__list__capacity__first__bit1 algorithm__gap_vectors__list__capacity__last__bit1))

;; algorithm__gap_vectors__list__capacity__position_axiom
  (assert (<= 0 algorithm__gap_vectors__list__capacity__position1))

(declare-fun user_eq23 (us_rep8 us_rep8) Bool)

(declare-const dummy23 us_rep8)

(declare-datatypes ()
((list__ref1 (mk_list__ref1 (list__content1 us_rep8)))))
(define-fun list__ref___2__projection ((a list__ref1)) us_rep8 (list__content1
                                                               a))

(declare-fun is_empty (us_rep8) Bool)

(declare-fun is_empty__function_guard (Bool us_rep8) Bool)

(define-fun dynamic_invariant5 ((temp___expr_640 us_rep8)
  (temp___is_init_636 Bool) (temp___skip_constant_637 Bool)
  (temp___do_toplevel_638 Bool)
  (temp___do_typ_inv_639 Bool)) Bool (=>
                                     (not (= temp___skip_constant_637 true))
                                     (in_range12 1000 temp___expr_640)))

(define-fun default_initial_assumption1 ((temp___expr_642 us_rep8)
  (temp___skip_top_level_643 Bool)) Bool (and
                                         (= (to_rep10
                                            (rec__algorithm__gap_vectors__list__capacity
                                            (us_split_discrs3
                                            temp___expr_642))) 1000)
                                         (=>
                                         (not
                                         (= temp___skip_top_level_643 true))
                                         (= (is_empty temp___expr_642) true))))

(declare-const dummy24 (Array Int us_rep7))

(declare-const value__size12 Int)

(declare-fun object__size12 ((Array Int us_rep7)) Int)

(declare-const value__component__size2 Int)

(declare-fun object__component__size2 ((Array Int us_rep7)) Int)

(declare-const value__alignment12 Int)

(declare-fun object__alignment12 ((Array Int us_rep7)) Int)

;; value__size_axiom
  (assert (<= 0 value__size12))

;; object__size_axiom
  (assert (forall ((a (Array Int us_rep7))) (<= 0 (object__size12 a))))

;; value__component__size_axiom
  (assert (<= 0 value__component__size2))

;; object__component__size_axiom
  (assert
  (forall ((a (Array Int us_rep7))) (<= 0 (object__component__size2 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment12))

;; object__alignment_axiom
  (assert (forall ((a (Array Int us_rep7))) (<= 0 (object__alignment12 a))))

(declare-fun user_eq24 ((Array Int us_rep7) (Array Int us_rep7)) Bool)

(declare-datatypes ()
((us_split_fields18
 (mk___split_fields9
 (rec__algorithm__controller__robot us_rep4)(rec__algorithm__controller__laserscan (Array Int us_rep7))(rec__algorithm__controller__gapvec us_rep8)(rec__algorithm__controller__obsavoiddelta float)(rec__algorithm__controller__driveangle us_rep)))))
(define-fun us_split_fields_robot__projection ((a us_split_fields18)) us_rep4
  (rec__algorithm__controller__robot a))

(define-fun us_split_fields_laserScan__projection ((a us_split_fields18)) (Array Int us_rep7)
  (rec__algorithm__controller__laserscan a))

(define-fun us_split_fields_gapVec__projection ((a us_split_fields18)) us_rep8
  (rec__algorithm__controller__gapvec a))

(define-fun us_split_fields_obsAvoidDelta__projection ((a us_split_fields18)) float
  (rec__algorithm__controller__obsavoiddelta a))

(define-fun us_split_fields_driveAngle__projection ((a us_split_fields18)) us_rep
  (rec__algorithm__controller__driveangle a))

(declare-datatypes ()
((us_split_fields__ref9
 (mk___split_fields__ref9 (us_split_fields__content9 us_split_fields18)))))
(define-fun us_split_fields__ref___12__projection ((a us_split_fields__ref9)) us_split_fields18
  (us_split_fields__content9 a))

(declare-datatypes ()
((us_rep9 (mk___rep9 (us_split_fields19 us_split_fields18)))))
(define-fun us_rep___17__projection ((a us_rep9)) us_split_fields18 (us_split_fields19
                                                                    a))

(define-fun bool_eq19 ((a us_rep9)
  (b us_rep9)) Bool (ite (and
                         (and
                         (and
                         (and
                         (= (bool_eq13
                            (rec__algorithm__controller__robot
                            (us_split_fields19 a))
                            (rec__algorithm__controller__robot
                            (us_split_fields19 b))) true)
                         (= (bool_eq17
                            (rec__algorithm__controller__laserscan
                            (us_split_fields19 a)) 1 1000
                            (rec__algorithm__controller__laserscan
                            (us_split_fields19 b)) 1 1000) true))
                         (= (bool_eq18
                            (rec__algorithm__controller__gapvec
                            (us_split_fields19 a))
                            (rec__algorithm__controller__gapvec
                            (us_split_fields19 b))) true))
                         (= (to_rep2
                            (rec__algorithm__controller__obsavoiddelta
                            (us_split_fields19 a))) (to_rep2
                                                    (rec__algorithm__controller__obsavoiddelta
                                                    (us_split_fields19 b)))))
                         (= (bool_eq5
                            (rec__algorithm__controller__driveangle
                            (us_split_fields19 a))
                            (rec__algorithm__controller__driveangle
                            (us_split_fields19 b))) true))
                    true false))

(declare-const value__size13 Int)

(declare-fun object__size13 (us_rep9) Int)

(declare-const value__alignment13 Int)

(declare-fun object__alignment13 (us_rep9) Int)

;; value__size_axiom
  (assert (<= 0 value__size13))

;; object__size_axiom
  (assert (forall ((a us_rep9)) (<= 0 (object__size13 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment13))

;; object__alignment_axiom
  (assert (forall ((a us_rep9)) (<= 0 (object__alignment13 a))))

(declare-const algorithm__controller__robot__first__bit Int)

(declare-const algorithm__controller__robot__last__bit Int)

(declare-const algorithm__controller__robot__position Int)

;; algorithm__controller__robot__first__bit_axiom
  (assert (<= 0 algorithm__controller__robot__first__bit))

;; algorithm__controller__robot__last__bit_axiom
  (assert
  (< algorithm__controller__robot__first__bit algorithm__controller__robot__last__bit))

;; algorithm__controller__robot__position_axiom
  (assert (<= 0 algorithm__controller__robot__position))

(declare-const algorithm__controller__laserscan__first__bit Int)

(declare-const algorithm__controller__laserscan__last__bit Int)

(declare-const algorithm__controller__laserscan__position Int)

;; algorithm__controller__laserscan__first__bit_axiom
  (assert (<= 0 algorithm__controller__laserscan__first__bit))

;; algorithm__controller__laserscan__last__bit_axiom
  (assert
  (< algorithm__controller__laserscan__first__bit algorithm__controller__laserscan__last__bit))

;; algorithm__controller__laserscan__position_axiom
  (assert (<= 0 algorithm__controller__laserscan__position))

(declare-const algorithm__controller__gapvec__first__bit Int)

(declare-const algorithm__controller__gapvec__last__bit Int)

(declare-const algorithm__controller__gapvec__position Int)

;; algorithm__controller__gapvec__first__bit_axiom
  (assert (<= 0 algorithm__controller__gapvec__first__bit))

;; algorithm__controller__gapvec__last__bit_axiom
  (assert
  (< algorithm__controller__gapvec__first__bit algorithm__controller__gapvec__last__bit))

;; algorithm__controller__gapvec__position_axiom
  (assert (<= 0 algorithm__controller__gapvec__position))

(declare-const algorithm__controller__obsavoiddelta__first__bit Int)

(declare-const algorithm__controller__obsavoiddelta__last__bit Int)

(declare-const algorithm__controller__obsavoiddelta__position Int)

;; algorithm__controller__obsavoiddelta__first__bit_axiom
  (assert (<= 0 algorithm__controller__obsavoiddelta__first__bit))

;; algorithm__controller__obsavoiddelta__last__bit_axiom
  (assert
  (< algorithm__controller__obsavoiddelta__first__bit algorithm__controller__obsavoiddelta__last__bit))

;; algorithm__controller__obsavoiddelta__position_axiom
  (assert (<= 0 algorithm__controller__obsavoiddelta__position))

(declare-const algorithm__controller__driveangle__first__bit Int)

(declare-const algorithm__controller__driveangle__last__bit Int)

(declare-const algorithm__controller__driveangle__position Int)

;; algorithm__controller__driveangle__first__bit_axiom
  (assert (<= 0 algorithm__controller__driveangle__first__bit))

;; algorithm__controller__driveangle__last__bit_axiom
  (assert
  (< algorithm__controller__driveangle__first__bit algorithm__controller__driveangle__last__bit))

;; algorithm__controller__driveangle__position_axiom
  (assert (<= 0 algorithm__controller__driveangle__position))

(declare-fun user_eq25 (us_rep9 us_rep9) Bool)

(declare-const dummy25 us_rep9)

(declare-datatypes ()
((controller__ref (mk_controller__ref (controller__content us_rep9)))))
(define-fun controller__ref___projection ((a controller__ref)) us_rep9
  (controller__content a))

(declare-const null_angle us_rep)

(declare-const attr__ATTRIBUTE_ADDRESS1 Int)

(define-fun in_range13 ((rec__robot_iface__speed_option__opt1 Int)
  (a us_rep3)) Bool (= rec__robot_iface__speed_option__opt1 (to_rep8
                                                            (rec__robot_iface__speed_option__opt
                                                            (us_split_discrs1
                                                            a)))))

(declare-const value__size14 Int)

(declare-fun object__size14 (us_rep3) Int)

(declare-const value__alignment14 Int)

(declare-fun object__alignment14 (us_rep3) Int)

;; value__size_axiom
  (assert (<= 0 value__size14))

;; object__size_axiom
  (assert (forall ((a us_rep3)) (<= 0 (object__size14 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment14))

;; object__alignment_axiom
  (assert (forall ((a us_rep3)) (<= 0 (object__alignment14 a))))

(declare-const robot_iface__speed_option__opt__first__bit1 Int)

(declare-const robot_iface__speed_option__opt__last__bit1 Int)

(declare-const robot_iface__speed_option__opt__position1 Int)

;; robot_iface__speed_option__opt__first__bit_axiom
  (assert (<= 0 robot_iface__speed_option__opt__first__bit1))

;; robot_iface__speed_option__opt__last__bit_axiom
  (assert
  (< robot_iface__speed_option__opt__first__bit1 robot_iface__speed_option__opt__last__bit1))

;; robot_iface__speed_option__opt__position_axiom
  (assert (<= 0 robot_iface__speed_option__opt__position1))

(declare-const robot_iface__speed_option__modulus__first__bit1 Int)

(declare-const robot_iface__speed_option__modulus__last__bit1 Int)

(declare-const robot_iface__speed_option__modulus__position1 Int)

;; robot_iface__speed_option__modulus__first__bit_axiom
  (assert (<= 0 robot_iface__speed_option__modulus__first__bit1))

;; robot_iface__speed_option__modulus__last__bit_axiom
  (assert
  (< robot_iface__speed_option__modulus__first__bit1 robot_iface__speed_option__modulus__last__bit1))

;; robot_iface__speed_option__modulus__position_axiom
  (assert (<= 0 robot_iface__speed_option__modulus__position1))

(declare-const robot_iface__speed_option__angle__first__bit1 Int)

(declare-const robot_iface__speed_option__angle__last__bit1 Int)

(declare-const robot_iface__speed_option__angle__position1 Int)

;; robot_iface__speed_option__angle__first__bit_axiom
  (assert (<= 0 robot_iface__speed_option__angle__first__bit1))

;; robot_iface__speed_option__angle__last__bit_axiom
  (assert
  (< robot_iface__speed_option__angle__first__bit1 robot_iface__speed_option__angle__last__bit1))

;; robot_iface__speed_option__angle__position_axiom
  (assert (<= 0 robot_iface__speed_option__angle__position1))

(declare-fun user_eq26 (us_rep3 us_rep3) Bool)

(declare-const dummy26 us_rep3)

(declare-datatypes ()
((t252s__ref (mk_t252s__ref (t252s__content us_rep3)))))
(define-fun t252s__ref___projection ((a t252s__ref)) us_rep3 (t252s__content
                                                             a))

(declare-fun temp_____aggregate_def_680 (t) (Array Int nonnegative_float))

(declare-fun temp_____aggregate_def_684 (us_rep7) (Array Int us_rep7))

(define-fun dynamic_invariant6 ((temp___expr_673 us_rep9)
  (temp___is_init_669 Bool) (temp___skip_constant_670 Bool)
  (temp___do_toplevel_671 Bool)
  (temp___do_typ_inv_672 Bool)) Bool (and
                                     (= (attr__constrained
                                        (rec__robot_iface__proxy__speed
                                        (us_split_fields9
                                        (rec__algorithm__controller__robot
                                        (us_split_fields19 temp___expr_673))))) false)
                                     (in_range12 1000
                                     (rec__algorithm__controller__gapvec
                                     (us_split_fields19 temp___expr_673)))))

(declare-const rliteral natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral) 0))

(define-fun default_initial_assumption2 ((temp___expr_678 us_rep9)
  (temp___skip_top_level_679 Bool)) Bool (and
                                         (and
                                         (and
                                         (and
                                         (= (rec__algorithm__controller__robot
                                            (us_split_fields19
                                            temp___expr_678)) (mk___rep4
                                                              (mk___split_fields4
                                                              (of_rep5
                                                              fliteral2)
                                                              (of_rep5
                                                              fliteral2)
                                                              (of_rep5
                                                              fliteral2)
                                                              (of_rep5
                                                              fliteral2)
                                                              (of_rep5
                                                              fliteral2)
                                                              (of_rep6
                                                              fliteral2)
                                                              (of_rep6
                                                              fliteral2)
                                                              (of_rep2
                                                              fliteral2)
                                                              (of_rep2
                                                              fliteral2)
                                                              (of_rep2
                                                              fliteral2)
                                                              rliteral
                                                              (of_rep5
                                                              fliteral2)
                                                              (of_rep5
                                                              fliteral2)
                                                              (temp_____aggregate_def_680
                                                              fliteral2)
                                                              (of_rep7
                                                              fliteral2)
                                                              (of_rep7
                                                              fliteral2)
                                                              (of_rep7
                                                              fliteral2)
                                                              (let ((usq_
                                                              (mk___rep3
                                                              (mk___split_discrs
                                                              (of_rep8 0))
                                                              (mk___split_fields3
                                                              dummy5
                                                              dummy5) true)))
                                                              (mk___rep3
                                                              (us_split_discrs1
                                                              usq_)
                                                              (us_split_fields7
                                                              usq_) false))
                                                              (distinct 0 0))))
                                         (= (rec__algorithm__controller__laserscan
                                            (us_split_fields19
                                            temp___expr_678)) (temp_____aggregate_def_684
                                                              (mk___rep7
                                                              (mk___split_fields7
                                                              (of_rep6
                                                              fliteral2)
                                                              null_angle)))))
                                         (and
                                         (= (to_rep10
                                            (rec__algorithm__gap_vectors__list__capacity
                                            (us_split_discrs3
                                            (rec__algorithm__controller__gapvec
                                            (us_split_fields19
                                            temp___expr_678))))) 1000)
                                         (= (is_empty
                                            (rec__algorithm__controller__gapvec
                                            (us_split_fields19
                                            temp___expr_678))) true)))
                                         (= (to_rep2
                                            (rec__algorithm__controller__obsavoiddelta
                                            (us_split_fields19
                                            temp___expr_678))) fliteral2))
                                         (= (rec__algorithm__controller__driveangle
                                            (us_split_fields19
                                            temp___expr_678)) null_angle)))

(declare-sort option1 0)

(define-fun in_range14 ((x Int)) Bool (and (<= 0 x) (<= x 1)))

(declare-fun attr__ATTRIBUTE_IMAGE13 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check13 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE13 (us_image) Int)

(declare-fun user_eq27 (option1 option1) Bool)

(declare-const dummy27 option1)

(declare-datatypes ()
((option__ref1 (mk_option__ref1 (option__content1 option1)))))
(define-fun option__ref___2__projection ((a option__ref1)) option1 (option__content1
                                                                   a))

(declare-fun to_rep11 (option1) Int)

(declare-fun of_rep11 (Int) option1)

;; inversion_axiom
  (assert
  (forall ((x option1))
  (! (= (of_rep11 (to_rep11 x)) x) :pattern ((to_rep11 x)) )))

;; range_axiom
  (assert
  (forall ((x option1)) (! (in_range14
  (to_rep11 x)) :pattern ((to_rep11 x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range14 x) (= (to_rep11 (of_rep11 x)) x)) :pattern ((to_rep11
                                                                 (of_rep11 x))) )))

(declare-datatypes ()
((us_split_discrs4
 (mk___split_discrs2 (rec__algorithm__valley_option__opt option1)))))
(define-fun us_split_discrs___2__projection ((a us_split_discrs4)) option1
  (rec__algorithm__valley_option__opt a))

(declare-datatypes ()
((us_split_discrs__ref2
 (mk___split_discrs__ref2 (us_split_discrs__content2 us_split_discrs4)))))
(define-fun us_split_discrs__ref___2__projection ((a us_split_discrs__ref2)) us_split_discrs4
  (us_split_discrs__content2 a))

(declare-datatypes ()
((us_split_fields20
 (mk___split_fields10 (rec__algorithm__valley_option__value us_rep6)))))
(define-fun us_split_fields_value__projection ((a us_split_fields20)) us_rep6
  (rec__algorithm__valley_option__value a))

(declare-datatypes ()
((us_split_fields__ref10
 (mk___split_fields__ref10 (us_split_fields__content10 us_split_fields20)))))
(define-fun us_split_fields__ref___8__projection ((a us_split_fields__ref10)) us_split_fields20
  (us_split_fields__content10 a))

(declare-datatypes ()
((us_rep10
 (mk___rep10
 (us_split_discrs5 us_split_discrs4)(us_split_fields21 us_split_fields20)(attr__constrained1 Bool)))))
(define-fun us_rep___10__projection ((a us_rep10)) us_split_discrs4 (us_split_discrs5
                                                                    a))

(define-fun us_rep___11__projection ((a us_rep10)) us_split_fields20
  (us_split_fields21 a))

(define-fun us_rep___12__projection ((a us_rep10)) Bool (attr__constrained1
                                                        a))

(define-fun algorithm__valley_option__value__pred ((a us_rep10)) Bool (=
  (to_rep11 (rec__algorithm__valley_option__opt (us_split_discrs5 a))) 1))

(define-fun bool_eq20 ((a us_rep10)
  (b us_rep10)) Bool (ite (and
                          (= (to_rep11
                             (rec__algorithm__valley_option__opt
                             (us_split_discrs5 a))) (to_rep11
                                                    (rec__algorithm__valley_option__opt
                                                    (us_split_discrs5 b))))
                          (=> (algorithm__valley_option__value__pred a)
                          (= (bool_eq15
                             (rec__algorithm__valley_option__value
                             (us_split_fields21 a))
                             (rec__algorithm__valley_option__value
                             (us_split_fields21 b))) true)))
                     true false))

(declare-const value__size15 Int)

(declare-fun object__size15 (us_rep10) Int)

(declare-const value__alignment15 Int)

(declare-fun object__alignment15 (us_rep10) Int)

;; value__size_axiom
  (assert (<= 0 value__size15))

;; object__size_axiom
  (assert (forall ((a us_rep10)) (<= 0 (object__size15 a))))

;; value__alignment_axiom
  (assert (<= 0 value__alignment15))

;; object__alignment_axiom
  (assert (forall ((a us_rep10)) (<= 0 (object__alignment15 a))))

(declare-const algorithm__valley_option__opt__first__bit Int)

(declare-const algorithm__valley_option__opt__last__bit Int)

(declare-const algorithm__valley_option__opt__position Int)

;; algorithm__valley_option__opt__first__bit_axiom
  (assert (<= 0 algorithm__valley_option__opt__first__bit))

;; algorithm__valley_option__opt__last__bit_axiom
  (assert
  (< algorithm__valley_option__opt__first__bit algorithm__valley_option__opt__last__bit))

;; algorithm__valley_option__opt__position_axiom
  (assert (<= 0 algorithm__valley_option__opt__position))

(declare-const algorithm__valley_option__value__first__bit Int)

(declare-const algorithm__valley_option__value__last__bit Int)

(declare-const algorithm__valley_option__value__position Int)

;; algorithm__valley_option__value__first__bit_axiom
  (assert (<= 0 algorithm__valley_option__value__first__bit))

;; algorithm__valley_option__value__last__bit_axiom
  (assert
  (< algorithm__valley_option__value__first__bit algorithm__valley_option__value__last__bit))

;; algorithm__valley_option__value__position_axiom
  (assert (<= 0 algorithm__valley_option__value__position))

(declare-fun user_eq28 (us_rep10 us_rep10) Bool)

(declare-const dummy28 us_rep10)

(declare-datatypes ()
((valley_option__ref
 (mk_valley_option__ref (valley_option__content us_rep10)))))
(define-fun valley_option__ref___projection ((a valley_option__ref)) us_rep10
  (valley_option__content a))

(declare-fun findbestvalley (us_rep9 us_rep1) us_rep10)

(declare-fun findbestvalley__function_guard (us_rep10 us_rep9 us_rep1) Bool)

(define-fun default_initial_assumption3 ((temp___expr_423 us_rep10)
  (temp___skip_top_level_424 Bool)) Bool (and
                                         (= (attr__constrained1
                                            temp___expr_423) false)
                                         (= (to_rep11
                                            (rec__algorithm__valley_option__opt
                                            (us_split_discrs5
                                            temp___expr_423))) 0)))

(declare-fun obsavoiddelta (us_rep9 t) t)

(declare-fun obsavoiddelta__function_guard (t us_rep9 t) Bool)

(declare-fun limit (t t t) t)

(declare-fun limit__function_guard (t t t t) Bool)

(define-fun dynamic_invariant7 ((temp___expr_163 t) (temp___is_init_159 Bool)
  (temp___skip_constant_160 Bool) (temp___do_toplevel_161 Bool)
  (temp___do_typ_inv_162 Bool)) Bool (=>
                                     (or (= temp___is_init_159 true) (le
                                     fliteral2 fliteral1)) (in_range7
                                     temp___expr_163)))

(declare-sort laser_scan_id 0)

(declare-fun laser_scan_idqtint (laser_scan_id) Int)

;; laser_scan_id'axiom
  (assert
  (forall ((i laser_scan_id))
  (and (<= 1 (laser_scan_idqtint i)) (<= (laser_scan_idqtint i) 1000))))

(define-fun in_range15 ((x Int)) Bool (and (<= 1 x) (<= x 1000)))

(declare-fun attr__ATTRIBUTE_IMAGE14 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check14 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE14 (us_image) Int)

(declare-fun user_eq29 (laser_scan_id laser_scan_id) Bool)

(declare-const dummy29 laser_scan_id)

(declare-datatypes ()
((laser_scan_id__ref
 (mk_laser_scan_id__ref (laser_scan_id__content laser_scan_id)))))
(define-fun laser_scan_id__ref___projection ((a laser_scan_id__ref)) laser_scan_id
  (laser_scan_id__content a))

(declare-const attr__ATTRIBUTE_ADDRESS2 Int)

(declare-const attr__ATTRIBUTE_ADDRESS3 Int)

(declare-const attr__ATTRIBUTE_ADDRESS4 Int)

(declare-const attr__ATTRIBUTE_ADDRESS5 Int)

(declare-const attr__ATTRIBUTE_ADDRESS6 Int)

(declare-const attr__ATTRIBUTE_ADDRESS7 Int)

(declare-const attr__ATTRIBUTE_ADDRESS8 Int)

(declare-const attr__ATTRIBUTE_ADDRESS9 Int)

(declare-const attr__ATTRIBUTE_ADDRESS10 Int)

(declare-const attr__ATTRIBUTE_ADDRESS11 Int)

(declare-const attr__ATTRIBUTE_ADDRESS12 Int)

(declare-const attr__ATTRIBUTE_ADDRESS13 Int)

(declare-const pbestvalley__attr__constrained Bool)

(declare-const attr__ATTRIBUTE_ADDRESS14 Int)

(declare-const attr__ATTRIBUTE_ADDRESS15 Int)

(declare-const attr__ATTRIBUTE_ADDRESS16 Int)

(define-fun dynamic_property1 ((first_int Int) (last_int Int)
  (x Int)) Bool (and (<= first_int x) (<= x last_int)))

(declare-fun attr__ATTRIBUTE_IMAGE15 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check15 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE15 (us_image) Int)

(declare-fun user_eq30 (integer integer) Bool)

(declare-const dummy30 integer)

(declare-datatypes () ((t75b__ref (mk_t75b__ref (t75b__content integer)))))
(define-fun t75b__ref___projection ((a t75b__ref)) integer (t75b__content a))

(declare-const attr__ATTRIBUTE_ADDRESS17 Int)

(declare-const safetydeltaangle us_rep)

(declare-const attr__ATTRIBUTE_ADDRESS18 Int)

(declare-fun temp___String_Literal_979 (tuple0) (Array Int character))

;; temp___String_Literal_979__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_979 us_void_param) 1)) 112)
     (= (to_rep (select (temp___String_Literal_979 us_void_param) 2)) 111))
     (= (to_rep (select (temp___String_Literal_979 us_void_param) 3)) 115))
     (= (to_rep (select (temp___String_Literal_979 us_void_param) 4)) 101))
     (= (to_rep (select (temp___String_Literal_979 us_void_param) 5)) 32)) :pattern (
  (temp___String_Literal_979 us_void_param)) )))

(declare-fun temp___String_Literal_981 (tuple0) (Array Int character))

;; temp___String_Literal_981__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_981 us_void_param) 1)) 103)
     (= (to_rep (select (temp___String_Literal_981 us_void_param) 2)) 111))
     (= (to_rep (select (temp___String_Literal_981 us_void_param) 3)) 97))
     (= (to_rep (select (temp___String_Literal_981 us_void_param) 4)) 108))
     (= (to_rep (select (temp___String_Literal_981 us_void_param) 5)) 32)) :pattern (
  (temp___String_Literal_981 us_void_param)) )))

(declare-fun temp___String_Literal_1004 (tuple0) (Array Int character))

;; temp___String_Literal_1004__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 2)) 32))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 3)) 82))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 4)) 101))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 5)) 108))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 6)) 32))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 7)) 103))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 8)) 111))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 9)) 97))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 10)) 108))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 11)) 32))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 12)) 112))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 13)) 111))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 14)) 115))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 15)) 101))
     (= (to_rep (select (temp___String_Literal_1004 us_void_param) 16)) 32)) :pattern (
  (temp___String_Literal_1004 us_void_param)) )))

(declare-fun temp___String_Literal_1007 (tuple0) (Array Int character))

;; temp___String_Literal_1007__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 1)) 82)
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 2)) 101))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 3)) 97))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 4)) 99))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 5)) 104))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 6)) 101))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 7)) 100))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 8)) 32))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 9)) 103))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 10)) 111))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 11)) 97))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 12)) 108))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 13)) 32))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 14)) 108))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 15)) 111))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 16)) 99))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 17)) 97))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 18)) 116))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 19)) 105))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 20)) 111))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 21)) 110))
     (= (to_rep (select (temp___String_Literal_1007 us_void_param) 22)) 32)) :pattern (
  (temp___String_Literal_1007 us_void_param)) )))

(declare-fun temp___String_Literal_1013 (tuple0) (Array Int character))

;; temp___String_Literal_1013__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 2)) 32))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 3)) 68))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 4)) 105))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 5)) 115))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 6)) 116))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 7)) 32))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 8)) 116))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 9)) 111))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 10)) 32))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 11)) 103))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 12)) 111))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 13)) 97))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 14)) 108))
     (= (to_rep (select (temp___String_Literal_1013 us_void_param) 15)) 32)) :pattern (
  (temp___String_Literal_1013 us_void_param)) )))

(declare-fun temp___String_Literal_1017 (tuple0) (Array Int character))

;; temp___String_Literal_1017__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 2)) 79))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 3)) 98))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 4)) 115))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 5)) 116))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 6)) 97))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 7)) 99))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 8)) 108))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 9)) 101))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 10)) 32))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 11)) 105))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 12)) 110))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 13)) 115))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 14)) 105))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 15)) 100))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 16)) 101))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 17)) 32))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 18)) 111))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 19)) 102))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 20)) 32))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 21)) 114))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 22)) 111))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 23)) 98))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 24)) 111))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 25)) 116))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 26)) 39))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 27)) 115))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 28)) 32))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 29)) 98))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 30)) 111))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 31)) 117))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 32)) 110))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 33)) 100))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 34)) 97))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 35)) 114))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 36)) 121))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 37)) 33))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 38)) 32))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 39)) 32))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 40)) 83))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 41)) 116))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 42)) 111))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 43)) 112))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 44)) 112))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 45)) 105))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 46)) 110))
     (= (to_rep (select (temp___String_Literal_1017 us_void_param) 47)) 103)) :pattern (
  (temp___String_Literal_1017 us_void_param)) )))

(declare-fun temp___String_Literal_1032 (tuple0) (Array Int character))

;; temp___String_Literal_1032__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 2)) 32))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 3)) 32))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 4)) 32))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 5)) 66))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 6)) 101))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 7)) 115))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 8)) 116))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 9)) 32))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 10)) 118))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 11)) 97))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 12)) 108))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 13)) 108))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 14)) 101))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 15)) 121))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 16)) 32))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 17)) 104))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 18)) 97))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 19)) 115))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 20)) 32))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 21)) 114))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 22)) 105))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 23)) 115))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 24)) 105))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 25)) 110))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 26)) 103))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 27)) 32))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 28)) 97))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 29)) 116))
     (= (to_rep (select (temp___String_Literal_1032 us_void_param) 30)) 32)) :pattern (
  (temp___String_Literal_1032 us_void_param)) )))

(declare-fun temp___String_Literal_1033 (tuple0) (Array Int character))

;; temp___String_Literal_1033__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 2)) 32))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 3)) 32))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 4)) 32))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 5)) 32))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 6)) 32))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 7)) 115))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 8)) 97))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 9)) 102))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 10)) 101))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 11)) 116))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 12)) 121))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 13)) 32))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 14)) 100))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 15)) 101))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 16)) 108))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 17)) 116))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 18)) 97))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 19)) 32))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 20)) 61))
     (= (to_rep (select (temp___String_Literal_1033 us_void_param) 21)) 32)) :pattern (
  (temp___String_Literal_1033 us_void_param)) )))

(declare-fun temp___String_Literal_1041 (tuple0) (Array Int character))

;; temp___String_Literal_1041__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 2)) 32))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 3)) 78))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 4)) 111))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 5)) 32))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 6)) 119))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 7)) 104))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 8)) 101))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 9)) 114))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 10)) 101))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 11)) 32))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 12)) 116))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 13)) 111))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 14)) 32))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 15)) 103))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 16)) 111))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 17)) 44))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 18)) 32))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 19)) 116))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 20)) 117))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 21)) 114))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 22)) 110))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 23)) 105))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 24)) 110))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 25)) 103))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 26)) 32))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 27)) 105))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 28)) 110))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 29)) 32))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 30)) 112))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 31)) 108))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 32)) 97))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 33)) 99))
     (= (to_rep (select (temp___String_Literal_1041 us_void_param) 34)) 101)) :pattern (
  (temp___String_Literal_1041 us_void_param)) )))

(declare-fun temp___String_Literal_1046 (tuple0) (Array Int character))

;; temp___String_Literal_1046__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 2)) 32))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 3)) 72))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 4)) 101))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 5)) 97))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 6)) 100))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 7)) 105))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 8)) 110))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 9)) 103))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 10)) 32))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 11)) 115))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 12)) 116))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 13)) 114))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 14)) 97))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 15)) 105))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 16)) 103))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 17)) 104))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 18)) 116))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 19)) 32))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 20)) 102))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 21)) 111))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 22)) 114))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 23)) 32))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 24)) 103))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 25)) 111))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 26)) 97))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 27)) 108))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 28)) 44))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 29)) 32))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 30)) 112))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 31)) 97))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 32)) 116))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 33)) 104))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 34)) 32))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 35)) 105))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 36)) 115))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 37)) 32))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 38)) 99))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 39)) 108))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 40)) 101))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 41)) 97))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 42)) 114))
     (= (to_rep (select (temp___String_Literal_1046 us_void_param) 43)) 33)) :pattern (
  (temp___String_Literal_1046 us_void_param)) )))

(declare-fun temp___String_Literal_1047 (tuple0) (Array Int character))

;; temp___String_Literal_1047__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 2)) 32))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 3)) 32))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 4)) 68))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 5)) 105))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 6)) 115))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 7)) 116))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 8)) 32))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 9)) 116))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 10)) 111))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 11)) 32))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 12)) 103))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 13)) 111))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 14)) 97))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 15)) 108))
     (= (to_rep (select (temp___String_Literal_1047 us_void_param) 16)) 32)) :pattern (
  (temp___String_Literal_1047 us_void_param)) )))

(declare-fun temp___String_Literal_1048 (tuple0) (Array Int character))

;; temp___String_Literal_1048__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1048 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1048 us_void_param) 2)) 97))
     (= (to_rep (select (temp___String_Literal_1048 us_void_param) 3)) 110))
     (= (to_rep (select (temp___String_Literal_1048 us_void_param) 4)) 103))
     (= (to_rep (select (temp___String_Literal_1048 us_void_param) 5)) 108))
     (= (to_rep (select (temp___String_Literal_1048 us_void_param) 6)) 101))
     (= (to_rep (select (temp___String_Literal_1048 us_void_param) 7)) 32)) :pattern (
  (temp___String_Literal_1048 us_void_param)) )))

(declare-fun temp___String_Literal_1053 (tuple0) (Array Int character))

;; temp___String_Literal_1053__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 2)) 83))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 3)) 116))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 4)) 97))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 5)) 114))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 6)) 116))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 7)) 105))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 8)) 110))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 9)) 103))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 10)) 32))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 11)) 100))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 12)) 114))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 13)) 105))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 14)) 118))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 15)) 101))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 16)) 32))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 17)) 97))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 18)) 110))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 19)) 103))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 20)) 108))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 21)) 101))
     (= (to_rep (select (temp___String_Literal_1053 us_void_param) 22)) 32)) :pattern (
  (temp___String_Literal_1053 us_void_param)) )))

(declare-fun temp___String_Literal_1064 (tuple0) (Array Int character))

;; temp___String_Literal_1064__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 2)) 68))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 3)) 114))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 4)) 105))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 5)) 118))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 6)) 101))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 7)) 32))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 8)) 97))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 9)) 110))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 10)) 103))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 11)) 108))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 12)) 101))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 13)) 32))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 14)) 58))
     (= (to_rep (select (temp___String_Literal_1064 us_void_param) 15)) 32)) :pattern (
  (temp___String_Literal_1064 us_void_param)) )))

(declare-fun temp___String_Literal_1065 (tuple0) (Array Int character))

;; temp___String_Literal_1065__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1065 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1065 us_void_param) 2)) 102))
     (= (to_rep (select (temp___String_Literal_1065 us_void_param) 3)) 114))
     (= (to_rep (select (temp___String_Literal_1065 us_void_param) 4)) 111))
     (= (to_rep (select (temp___String_Literal_1065 us_void_param) 5)) 109))
     (= (to_rep (select (temp___String_Literal_1065 us_void_param) 6)) 32))
     (= (to_rep (select (temp___String_Literal_1065 us_void_param) 7)) 109))
     (= (to_rep (select (temp___String_Literal_1065 us_void_param) 8)) 105))
     (= (to_rep (select (temp___String_Literal_1065 us_void_param) 9)) 100))
     (= (to_rep (select (temp___String_Literal_1065 us_void_param) 10)) 32)) :pattern (
  (temp___String_Literal_1065 us_void_param)) )))

(declare-fun temp___String_Literal_1066 (tuple0) (Array Int character))

;; temp___String_Literal_1066__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 1)) 44)
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 2)) 32))
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 3)) 115))
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 4)) 97))
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 5)) 102))
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 6)) 101))
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 7)) 32))
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 8)) 114))
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 9)) 105))
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 10)) 115))
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 11)) 105))
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 12)) 110))
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 13)) 103))
     (= (to_rep (select (temp___String_Literal_1066 us_void_param) 14)) 32)) :pattern (
  (temp___String_Literal_1066 us_void_param)) )))

(declare-fun temp___String_Literal_1067 (tuple0) (Array Int character))

;; temp___String_Literal_1067__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1067 us_void_param) 1)) 44)
     (= (to_rep (select (temp___String_Literal_1067 us_void_param) 2)) 32))
     (= (to_rep (select (temp___String_Literal_1067 us_void_param) 3)) 97))
     (= (to_rep (select (temp___String_Literal_1067 us_void_param) 4)) 110))
     (= (to_rep (select (temp___String_Literal_1067 us_void_param) 5)) 100))
     (= (to_rep (select (temp___String_Literal_1067 us_void_param) 6)) 32)) :pattern (
  (temp___String_Literal_1067 us_void_param)) )))

(declare-fun temp___String_Literal_1068 (tuple0) (Array Int character))

;; temp___String_Literal_1068__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1068 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1068 us_void_param) 2)) 111))
     (= (to_rep (select (temp___String_Literal_1068 us_void_param) 3)) 98))
     (= (to_rep (select (temp___String_Literal_1068 us_void_param) 4)) 115))
     (= (to_rep (select (temp___String_Literal_1068 us_void_param) 5)) 32))
     (= (to_rep (select (temp___String_Literal_1068 us_void_param) 6)) 100))
     (= (to_rep (select (temp___String_Literal_1068 us_void_param) 7)) 101))
     (= (to_rep (select (temp___String_Literal_1068 us_void_param) 8)) 108))
     (= (to_rep (select (temp___String_Literal_1068 us_void_param) 9)) 116))
     (= (to_rep (select (temp___String_Literal_1068 us_void_param) 10)) 97)) :pattern (
  (temp___String_Literal_1068 us_void_param)) )))

(declare-fun temp___String_Literal_1069 (tuple0) (Array Int character))

;; temp___String_Literal_1069__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1069 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1069 us_void_param) 2)) 84))
     (= (to_rep (select (temp___String_Literal_1069 us_void_param) 3)) 104))
     (= (to_rep (select (temp___String_Literal_1069 us_void_param) 4)) 101))
     (= (to_rep (select (temp___String_Literal_1069 us_void_param) 5)) 116))
     (= (to_rep (select (temp___String_Literal_1069 us_void_param) 6)) 97))
     (= (to_rep (select (temp___String_Literal_1069 us_void_param) 7)) 32)) :pattern (
  (temp___String_Literal_1069 us_void_param)) )))

(declare-fun temp___String_Literal_1070 (tuple0) (Array Int character))

;; temp___String_Literal_1070__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (= (to_rep (select (temp___String_Literal_1070 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1070 us_void_param) 2)) 44))
     (= (to_rep (select (temp___String_Literal_1070 us_void_param) 3)) 32)) :pattern (
  (temp___String_Literal_1070 us_void_param)) )))

(declare-fun temp___String_Literal_1073 (tuple0) (Array Int character))

;; temp___String_Literal_1073__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (and
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 1)) 32)
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 2)) 68))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 3)) 114))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 4)) 105))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 5)) 118))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 6)) 101))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 7)) 32))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 8)) 99))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 9)) 111))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 10)) 109))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 11)) 109))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 12)) 97))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 13)) 110))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 14)) 100))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 15)) 115))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 16)) 58))
     (= (to_rep (select (temp___String_Literal_1073 us_void_param) 17)) 32)) :pattern (
  (temp___String_Literal_1073 us_void_param)) )))

(declare-fun temp___String_Literal_1074 (tuple0) (Array Int character))

;; temp___String_Literal_1074__def_axiom
  (assert
  (forall ((us_void_param tuple0))
  (! (and
     (= (to_rep (select (temp___String_Literal_1074 us_void_param) 1)) 44)
     (= (to_rep (select (temp___String_Literal_1074 us_void_param) 2)) 32)) :pattern (
  (temp___String_Literal_1074 us_void_param)) )))

(define-fun dynamic_invariant8 ((temp___expr_46 Int) (temp___is_init_42 Bool)
  (temp___skip_constant_43 Bool) (temp___do_toplevel_44 Bool)
  (temp___do_typ_inv_45 Bool)) Bool (=>
                                    (or (= temp___is_init_42 true)
                                    (<= 1 2147483647)) (in_range3
                                    temp___expr_46)))

(define-fun dynamic_invariant9 ((temp___expr_74 Int) (temp___is_init_70 Bool)
  (temp___skip_constant_71 Bool) (temp___do_toplevel_72 Bool)
  (temp___do_typ_inv_73 Bool)) Bool (=>
                                    (or (= temp___is_init_70 true)
                                    (<= 0 255)) (in_range4 temp___expr_74)))

(define-fun dynamic_invariant10 ((temp___expr_18 Int)
  (temp___is_init_14 Bool) (temp___skip_constant_15 Bool)
  (temp___do_toplevel_16 Bool)
  (temp___do_typ_inv_17 Bool)) Bool (=>
                                    (or (= temp___is_init_14 true)
                                    (<= (- 2147483648) 2147483647))
                                    (in_range2 temp___expr_18)))

(define-fun dynamic_invariant11 ((temp___expr_414 Int)
  (temp___is_init_410 Bool) (temp___skip_constant_411 Bool)
  (temp___do_toplevel_412 Bool)
  (temp___do_typ_inv_413 Bool)) Bool (=>
                                     (or (= temp___is_init_410 true)
                                     (<= 0 1)) (in_range14 temp___expr_414)))

;; def_axiom
  (assert
  (forall ((temp___686 us_rep7))
  (forall ((temp___687 Int))
  (= (select (temp_____aggregate_def_684 temp___686) temp___687) temp___686))))

(define-fun dynamic_invariant12 ((temp___expr_237 Int)
  (temp___is_init_233 Bool) (temp___skip_constant_234 Bool)
  (temp___do_toplevel_235 Bool)
  (temp___do_typ_inv_236 Bool)) Bool (=>
                                     (or (= temp___is_init_233 true)
                                     (<= 1 1000)) (in_range15
                                     temp___expr_237)))

(define-fun dynamic_invariant13 ((temp___expr_254 Int)
  (temp___is_init_250 Bool) (temp___skip_constant_251 Bool)
  (temp___do_toplevel_252 Bool)
  (temp___do_typ_inv_253 Bool)) Bool (=>
                                     (or (= temp___is_init_250 true)
                                     (<= 0 1)) (in_range9 temp___expr_254)))

(define-fun default_initial_assumption4 ((temp___expr_263 us_rep3)
  (temp___skip_top_level_264 Bool)) Bool (and
                                         (= (attr__constrained
                                            temp___expr_263) false)
                                         (= (to_rep8
                                            (rec__robot_iface__speed_option__opt
                                            (us_split_discrs1
                                            temp___expr_263))) 0)))

(define-fun dynamic_invariant14 ((temp___expr_184 t)
  (temp___is_init_180 Bool) (temp___skip_constant_181 Bool)
  (temp___do_toplevel_182 Bool)
  (temp___do_typ_inv_183 Bool)) Bool (=>
                                     (or (= temp___is_init_180 true) (le
                                     (neg fliteral1) fliteral1)) (tqtisFinite
                                     temp___expr_184)))

;; null_angle__def_axiom
  (assert (= null_angle (mk___rep (mk___split_fields (of_rep3 fliteral2)))))

(define-fun dynamic_invariant15 ((temp___expr_198 t)
  (temp___is_init_194 Bool) (temp___skip_constant_195 Bool)
  (temp___do_toplevel_196 Bool)
  (temp___do_typ_inv_197 Bool)) Bool (=>
                                     (or (= temp___is_init_194 true) (le
                                     fliteral2 fliteral3)) (in_range6
                                     temp___expr_198)))

;; zero_position__def_axiom
  (assert
  (= zero_position (mk___rep1
                   (mk___split_fields1 (of_rep2 fliteral2)
                   (of_rep2 fliteral2)))))

(define-fun dynamic_invariant16 ((temp___expr_323 Int)
  (temp___is_init_319 Bool) (temp___skip_constant_320 Bool)
  (temp___do_toplevel_321 Bool)
  (temp___do_typ_inv_322 Bool)) Bool (=>
                                     (or (= temp___is_init_319 true)
                                     (<= (- 1) 1)) (in_range10
                                     temp___expr_323)))

(define-fun dynamic_invariant17 ((temp___expr_365 Int)
  (temp___is_init_361 Bool) (temp___skip_constant_362 Bool)
  (temp___do_toplevel_363 Bool)
  (temp___do_typ_inv_364 Bool)) Bool (=>
                                     (or (= temp___is_init_361 true)
                                     (<= 0 2147483647)) (in_range11
                                     temp___expr_365)))

(declare-fun length1 (us_rep8) Int)

(declare-fun length__function_guard (Int us_rep8) Bool)

;; length__post_axiom
  (assert
  (forall ((container us_rep8))
  (! (let ((result (length1 container)))
     (and
     (<= result (to_rep10
                (rec__algorithm__gap_vectors__list__capacity
                (us_split_discrs3 container))))
     (dynamic_invariant17 result true false true true))) :pattern ((length1
                                                                   container)) )))

;; is_empty__post_axiom
  (assert
  (forall ((container us_rep8))
  (! (= (= (is_empty container) true) (= (length1 container) 0)) :pattern (
  (is_empty container)) )))

;; def_axiom
  (assert
  (forall ((temp___682 t))
  (=> (dynamic_invariant3 temp___682 true true true true)
  (forall ((temp___683 Int))
  (= (to_rep6 (select (temp_____aggregate_def_680 temp___682) temp___683)) temp___682)))))

(declare-const fliteral4 t)

;; fliteral_axiom
  (assert
  (and (tqtisFinite fliteral4)
  (= (tqtreal fliteral4) (/ 157079637050628662109375.0 100000000000000000000000.0))))

(declare-const this__split_fields us_split_fields__ref9)

(declare-const drivespeed t)

(declare-const driveturnrate t)

(declare-const disttoclosestobstacle t)

(declare-const safetydist t)

(declare-const saferisinggapangle__split_fields normalized2pi)

(declare-const midvalleyangle__split_fields normalized2pi)

(declare-const theta t)

(declare-const pbestvalley__split_discrs us_split_discrs__ref2)

(declare-const inumlps int__ref)

(declare-const o float)

(declare-const o1 float)

(declare-const o2 us_split_fields2)

(declare-const temp___1083 us_rep1)

(declare-const algorithm__step__saferisinggapangle__assume us_rep)

(declare-const algorithm__step__midvalleyangle__assume us_rep)

(declare-const result us_split_fields__ref)

(declare-const saferisinggapangle__split_fields1 us_split_fields)

(declare-const result1 us_split_fields__ref)

(declare-const midvalleyangle__split_fields1 us_split_fields)

(declare-const disttoclosestobstacle1 t__ref)

(declare-const this__split_fields1 us_split_fields__ref9)

;; H
  (assert (= (to_rep2 o) fliteral2))

;; H
  (assert (= (to_rep2 o1) fliteral2))

;; H
  (assert (= o2 (mk___split_fields1 o1 o)))

;; H
  (assert (= temp___1083 (mk___rep1 o2)))

;; H
  (assert (= temp___1083 zero_position))

;; H
  (assert
  (and
  (= (attr__constrained
     (rec__robot_iface__proxy__speed
     (us_split_fields9
     (rec__algorithm__controller__robot
     (us_split_fields__content9 this__split_fields))))) false)
  (= 1000 (to_rep10
          (rec__algorithm__gap_vectors__list__capacity
          (us_split_discrs3
          (rec__algorithm__controller__gapvec
          (us_split_fields__content9 this__split_fields))))))))

;; H
  (assert (=> (le (neg fliteral1) fliteral1) (tqtisFinite drivespeed)))

;; H
  (assert (=> (le (neg fliteral1) fliteral1) (tqtisFinite driveturnrate)))

;; H
  (assert (=> (le fliteral2 fliteral1) (in_range8 disttoclosestobstacle)))

;; H
  (assert (=> (le fliteral2 fliteral1) (in_range7 safetydist)))

;; H
  (assert (= algorithm__step__saferisinggapangle__assume (create Tuple0)))

;; H
  (assert
  (= result (mk___split_fields__ref
            (mk___split_fields saferisinggapangle__split_fields))))

;; H
  (assert
  (= saferisinggapangle__split_fields1 (us_split_fields1
                                       algorithm__step__saferisinggapangle__assume)))

;; H
  (assert (= algorithm__step__midvalleyangle__assume (create Tuple0)))

;; H
  (assert
  (= result1 (mk___split_fields__ref
             (mk___split_fields midvalleyangle__split_fields))))

;; H
  (assert
  (= midvalleyangle__split_fields1 (us_split_fields1
                                   algorithm__step__midvalleyangle__assume)))

;; H
  (assert (=> (le (neg fliteral1) fliteral1) (tqtisFinite theta)))

;; H
  (assert
  (and (= pbestvalley__attr__constrained false)
  (= (to_rep11
     (rec__algorithm__valley_option__opt
     (us_split_discrs__content2 pbestvalley__split_discrs))) 0)))

;; H
  (assert (=> (<= 0 2147483647) (in_range5 (int__content inumlps))))

;; H
  (assert (lt
  (to_rep5
  (rec__robot_iface__proxy__robot_radius
  (us_split_fields9
  (rec__algorithm__controller__robot
  (us_split_fields__content9 this__split_fields1)))))
  (t__content disttoclosestobstacle1)))

;; H
  (assert
  (=> (le fliteral2 fliteral1) (in_range8
  (t__content disttoclosestobstacle1))))

;; H
  (assert
  (and
  (= (attr__constrained
     (rec__robot_iface__proxy__speed
     (us_split_fields9
     (rec__algorithm__controller__robot
     (us_split_fields__content9 this__split_fields1))))) false)
  (= 1000 (to_rep10
          (rec__algorithm__gap_vectors__list__capacity
          (us_split_discrs3
          (rec__algorithm__controller__gapvec
          (us_split_fields__content9 this__split_fields1))))))))

(assert
;; WP_parameter_def
 ;; File "algorithm.ads", line 107, characters 0-0
  (not (le (neg fliteral4) fliteral4)))
(check-sat)
(exit)
