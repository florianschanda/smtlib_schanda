;; produced by cvc4_14.drv ;;
(set-info :smt-lib-version 2.5)
(set-logic AUFBVDTNIRA)
(set-info :source |VC generated by SPARK 2014|)
(set-info :category industrial)
(set-info :status unknown)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
(declare-datatypes () ((tuple0 (Tuple0))))
(declare-sort us_private 0)

(declare-fun private__bool_eq (us_private us_private) Bool)

(declare-const us_null_ext__ us_private)

(declare-sort us_type_of_heap 0)

(declare-datatypes ()
((us_type_of_heap__ref
 (mk___type_of_heap__ref (us_type_of_heap__content us_type_of_heap)))))
(declare-sort us_image 0)

(declare-datatypes () ((int__ref (mk_int__ref (int__content Int)))))
(declare-datatypes () ((bool__ref (mk_bool__ref (bool__content Bool)))))
(declare-datatypes () ((real__ref (mk_real__ref (real__content Real)))))
(declare-datatypes ()
((us_private__ref (mk___private__ref (us_private__content us_private)))))
(define-fun int__ref___projection ((a int__ref)) Int (int__content a))

(define-fun bool__ref___projection ((a bool__ref)) Bool (bool__content a))

(define-fun real__ref___projection ((a real__ref)) Real (real__content a))

(define-fun us_private__ref___projection ((a us_private__ref)) us_private
  (us_private__content a))

(declare-sort natural 0)

(declare-fun naturalqtint (natural) Int)

;; natural'axiom
  (assert
  (forall ((i natural))
  (and (<= 0 (naturalqtint i)) (<= (naturalqtint i) 2147483647))))

(define-fun in_range ((x Int)) Bool (and (<= 0 x) (<= x 2147483647)))

(declare-fun attr__ATTRIBUTE_IMAGE (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE (us_image) Int)

(declare-fun user_eq (natural natural) Bool)

(declare-const dummy natural)

(declare-datatypes ()
((natural__ref (mk_natural__ref (natural__content natural)))))
(define-fun natural__ref___projection ((a natural__ref)) natural (natural__content
                                                                 a))

(define-fun to_rep ((x natural)) Int (naturalqtint x))

(declare-fun of_rep (Int) natural)

;; inversion_axiom
  (assert
  (forall ((x natural)) (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; range_axiom
  (assert
  (forall ((x natural)) (! (in_range (to_rep x)) :pattern ((to_rep x)) )))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep
                                                           (of_rep x))) )))

(declare-fun fib (Int) Int)

(declare-fun fib__function_guard (Int Int) Bool)

(declare-sort t 0)

(declare-fun tqtreal (t) Real)

(declare-fun tqtisFinite (t) Bool)

;; t'axiom
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (and (<= (- (* 16777215.0 20282409603651670423947251286016.0)) (tqtreal x))
  (<= (tqtreal x) (* 16777215.0 20282409603651670423947251286016.0))))))

(declare-fun pow2 (Int) Int)

(declare-datatypes () ((mode (RNE1) (RNA1) (RTP1) (RTN1) (RTZ1))))
(define-fun to_nearest ((m mode)) Bool (or (= m RNE1) (= m RNA1)))

(declare-const zeroF t)

(declare-fun add (mode t t) t)

(declare-fun sub (mode t t) t)

(declare-fun mul (mode t t) t)

(declare-fun div1 (mode t t) t)

(declare-fun abs1 (t) t)

(declare-fun neg (t) t)

(declare-fun fma (mode t t t) t)

(declare-fun sqrt1 (mode t) t)

(declare-fun roundToIntegral (mode t) t)

(declare-fun min (t t) t)

(declare-fun max (t t) t)

(declare-fun le (t t) Bool)

(declare-fun lt (t t) Bool)

(declare-fun eq (t t) Bool)

(declare-fun is_normal (t) Bool)

(declare-fun is_subnormal (t) Bool)

(declare-fun is_zero (t) Bool)

(declare-fun is_infinite (t) Bool)

(declare-fun is_nan (t) Bool)

(declare-fun is_positive (t) Bool)

(declare-fun is_negative (t) Bool)

(define-fun is_plus_infinity ((x t)) Bool (and (is_infinite x) (is_positive
                                          x)))

(define-fun is_minus_infinity ((x t)) Bool (and (is_infinite x) (is_negative
                                           x)))

(define-fun is_plus_zero ((x t)) Bool (and (is_zero x) (is_positive x)))

(define-fun is_minus_zero ((x t)) Bool (and (is_zero x) (is_negative x)))

(define-fun is_not_nan ((x t)) Bool (or (tqtisFinite x) (is_infinite x)))

;; is_not_nan
  (assert (forall ((x t)) (= (is_not_nan x) (not (is_nan x)))))

;; is_not_finite
  (assert
  (forall ((x t)) (= (not (tqtisFinite x)) (or (is_infinite x) (is_nan x)))))

;; zeroF_is_positive
  (assert (is_positive zeroF))

;; zeroF_is_zero
  (assert (is_zero zeroF))

;; zero_to_real
  (assert
  (forall ((x t))
  (! (= (is_zero x) (and (tqtisFinite x) (= (tqtreal x) 0.0))) :pattern ((is_zero
  x)) )))

(declare-fun of_int (mode Int) t)

(declare-fun to_int1 (mode t) Int)

;; zero_of_int
  (assert (forall ((m mode)) (= zeroF (of_int m 0))))

(declare-fun round (mode Real) Real)

(declare-const max_int Int)

;; max_real_int
  (assert
  (= (* 33554430.0 10141204801825835211973625643008.0) (to_real max_int)))

(define-fun in_range1 ((x Real)) Bool (and
                                      (<= (- (* 33554430.0 10141204801825835211973625643008.0)) x)
                                      (<= x (* 33554430.0 10141204801825835211973625643008.0))))

(define-fun in_int_range ((i Int)) Bool (and (<= (- max_int) i)
                                        (<= i max_int)))

;; is_finite
  (assert (forall ((x t)) (=> (tqtisFinite x) (in_range1 (tqtreal x)))))

(define-fun no_overflow ((m mode) (x Real)) Bool (in_range1 (round m x)))

;; Bounded_real_no_overflow
  (assert (forall ((m mode) (x Real)) (=> (in_range1 x) (no_overflow m x))))

;; Round_monotonic
  (assert
  (forall ((m mode) (x Real) (y Real))
  (=> (<= x y) (<= (round m x) (round m y)))))

;; Round_idempotent
  (assert
  (forall ((m1 mode) (m2 mode) (x Real))
  (= (round m1 (round m2 x)) (round m2 x))))

;; Round_to_real
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x) (= (round m (tqtreal x)) (tqtreal x)))))

;; Round_down_le
  (assert (forall ((x Real)) (<= (round RTN1 x) x)))

;; Round_up_ge
  (assert (forall ((x Real)) (<= x (round RTP1 x))))

;; Round_down_neg
  (assert (forall ((x Real)) (= (round RTN1 (- x)) (- (round RTP1 x)))))

;; Round_up_neg
  (assert (forall ((x Real)) (= (round RTP1 (- x)) (- (round RTN1 x)))))

(define-fun in_safe_int_range ((i Int)) Bool (and (<= (- 16777216) i)
                                             (<= i 16777216)))

;; Exact_rounding_for_integers
  (assert
  (forall ((m mode) (i Int))
  (=> (in_safe_int_range i) (= (round m (to_real i)) (to_real i)))))

(define-fun same_sign ((x t)
  (y t)) Bool (or (and (is_positive x) (is_positive y))
              (and (is_negative x) (is_negative y))))

(define-fun diff_sign ((x t)
  (y t)) Bool (or (and (is_positive x) (is_negative y))
              (and (is_negative x) (is_positive y))))

;; feq_eq
  (assert
  (forall ((x t) (y t))
  (=> (tqtisFinite x)
  (=> (tqtisFinite y) (=> (not (is_zero x)) (=> (eq x y) (= x y)))))))

;; eq_feq
  (assert
  (forall ((x t) (y t))
  (=> (tqtisFinite x) (=> (tqtisFinite y) (=> (= x y) (eq x y))))))

;; eq_refl
  (assert (forall ((x t)) (=> (tqtisFinite x) (eq x x))))

;; eq_sym
  (assert (forall ((x t) (y t)) (=> (eq x y) (eq y x))))

;; eq_trans
  (assert (forall ((x t) (y t) (z t)) (=> (eq x y) (=> (eq y z) (eq x z)))))

;; eq_zero
  (assert (eq zeroF (neg zeroF)))

;; eq_to_real_finite
  (assert
  (forall ((x t) (y t))
  (=> (and (tqtisFinite x) (tqtisFinite y))
  (= (eq x y) (= (tqtreal x) (tqtreal y))))))

;; eq_special
  (assert
  (forall ((x t) (y t))
  (=> (eq x y)
  (and (is_not_nan x)
  (and (is_not_nan y)
  (or (and (tqtisFinite x) (tqtisFinite y))
  (and (is_infinite x) (and (is_infinite y) (same_sign x y)))))))))

;; lt_finite
  (assert
  (forall ((x t) (y t))
  (! (=> (and (tqtisFinite x) (tqtisFinite y))
     (= (lt x y) (< (tqtreal x) (tqtreal y)))) :pattern ((lt
  x y)) )))

;; le_finite
  (assert
  (forall ((x t) (y t))
  (! (=> (and (tqtisFinite x) (tqtisFinite y))
     (= (le x y) (<= (tqtreal x) (tqtreal y)))) :pattern ((le
  x y)) )))

;; le_lt_trans
  (assert (forall ((x t) (y t) (z t)) (=> (and (le x y) (lt y z)) (lt x z))))

;; lt_le_trans
  (assert (forall ((x t) (y t) (z t)) (=> (and (lt x y) (le y z)) (lt x z))))

;; le_ge_asym
  (assert (forall ((x t) (y t)) (=> (and (le x y) (le y x)) (eq x y))))

;; not_lt_ge
  (assert
  (forall ((x t) (y t))
  (=> (and (not (lt x y)) (and (is_not_nan x) (is_not_nan y))) (le y x))))

;; not_gt_le
  (assert
  (forall ((x t) (y t))
  (=> (and (not (lt y x)) (and (is_not_nan x) (is_not_nan y))) (le x y))))

;; le_special
  (assert
  (forall ((x t) (y t))
  (! (=> (le x y)
     (or (and (tqtisFinite x) (tqtisFinite y))
     (or (and (is_minus_infinity x) (is_not_nan y))
     (and (is_not_nan x) (is_plus_infinity y))))) :pattern ((le
  x y)) )))

;; lt_special
  (assert
  (forall ((x t) (y t))
  (! (=> (lt x y)
     (or (and (tqtisFinite x) (tqtisFinite y))
     (or
     (and (is_minus_infinity x)
     (and (is_not_nan y) (not (is_minus_infinity y))))
     (and (is_not_nan x)
     (and (not (is_plus_infinity x)) (is_plus_infinity y)))))) :pattern ((lt
  x y)) )))

;; lt_lt_finite
  (assert
  (forall ((x t) (y t) (z t)) (=> (lt x y) (=> (lt y z) (tqtisFinite y)))))

;; positive_to_real
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (=> (is_positive x) (<= 0.0 (tqtreal x)))) :pattern ((is_positive
  x)) :pattern ((<= 0.0 (tqtreal x))) )))

;; to_real_positive
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (=> (< 0.0 (tqtreal x)) (is_positive x))) :pattern ((is_positive
  x)) )))

;; negative_to_real
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (=> (is_negative x) (<= (tqtreal x) 0.0))) :pattern ((is_negative
  x)) :pattern ((<= (tqtreal x) 0.0)) )))

;; to_real_negative
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x) (=> (< (tqtreal x) 0.0) (is_negative x))) :pattern ((is_negative
  x)) )))

;; negative_xor_positive
  (assert (forall ((x t)) (not (and (is_positive x) (is_negative x)))))

;; negative_or_positive
  (assert
  (forall ((x t)) (=> (is_not_nan x) (or (is_positive x) (is_negative x)))))

;; diff_sign_trans
  (assert
  (forall ((x t) (y t) (z t))
  (=> (and (diff_sign x y) (diff_sign y z)) (same_sign x z))))

;; diff_sign_product
  (assert
  (forall ((x t) (y t))
  (=>
  (and (tqtisFinite x)
  (and (tqtisFinite y) (< (* (tqtreal x) (tqtreal y)) 0.0))) (diff_sign x y))))

;; same_sign_product
  (assert
  (forall ((x t) (y t))
  (=> (and (tqtisFinite x) (and (tqtisFinite y) (same_sign x y)))
  (<= 0.0 (* (tqtreal x) (tqtreal y))))))

(define-fun product_sign ((z t) (x t)
  (y t)) Bool (and (=> (same_sign x y) (is_positive z))
              (=> (diff_sign x y) (is_negative z))))

(define-fun overflow_value ((m mode)
  (x t)) Bool (ite (is-RTN1 m) (ite (is_positive x)
                               (and (tqtisFinite x)
                               (= (tqtreal x) (* 33554430.0 10141204801825835211973625643008.0)))
                               (is_infinite x)) (ite (is-RTP1 m) (ite (is_positive
                                                                 x)
                                                                 (is_infinite
                                                                 x)
                                                                 (and
                                                                 (tqtisFinite
                                                                 x)
                                                                 (= (tqtreal
                                                                    x) (- (* 33554430.0 10141204801825835211973625643008.0)))))
                                                (ite (is-RTZ1 m) (ite (is_positive
                                                                 x)
                                                                 (and
                                                                 (tqtisFinite
                                                                 x)
                                                                 (= (tqtreal
                                                                    x) (* 33554430.0 10141204801825835211973625643008.0)))
                                                                 (and
                                                                 (tqtisFinite
                                                                 x)
                                                                 (= (tqtreal
                                                                    x) (- (* 33554430.0 10141204801825835211973625643008.0)))))
                                                (ite (is-RNA1 m) (is_infinite
                                                x) (is_infinite x))))))

(define-fun sign_zero_result ((m mode)
  (x t)) Bool (=> (is_zero x)
              (ite (is-RTN1 m) (is_negative x) (is_positive x))))

;; add_finite
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (no_overflow m (+ (tqtreal x) (tqtreal y)))
     (and (tqtisFinite (add m x y))
     (= (tqtreal (add m x y)) (round m (+ (tqtreal x) (tqtreal y)))))))) :pattern (
  (add m x y)) )))

;; add_finite_rev
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite (add m x y)) (and (tqtisFinite x) (tqtisFinite y))) :pattern (
  (add m x y)) )))

;; add_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (add m x y))
     (and (no_overflow m (+ (tqtreal x) (tqtreal y)))
     (= (tqtreal (add m x y)) (round m (+ (tqtreal x) (tqtreal y))))))) :pattern (
  (add m x y)) )))

;; sub_finite
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (no_overflow m (- (tqtreal x) (tqtreal y)))
     (and (tqtisFinite (sub m x y))
     (= (tqtreal (sub m x y)) (round m (- (tqtreal x) (tqtreal y)))))))) :pattern (
  (sub m x y)) )))

;; sub_finite_rev
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite (sub m x y)) (and (tqtisFinite x) (tqtisFinite y))) :pattern (
  (sub m x y)) )))

;; sub_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (sub m x y))
     (and (no_overflow m (- (tqtreal x) (tqtreal y)))
     (= (tqtreal (sub m x y)) (round m (- (tqtreal x) (tqtreal y))))))) :pattern (
  (sub m x y)) )))

;; mul_finite
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (no_overflow m (* (tqtreal x) (tqtreal y)))
     (and (tqtisFinite (mul m x y))
     (= (tqtreal (mul m x y)) (round m (* (tqtreal x) (tqtreal y)))))))) :pattern (
  (mul m x y)) )))

;; mul_finite_rev
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite (mul m x y)) (and (tqtisFinite x) (tqtisFinite y))) :pattern (
  (mul m x y)) )))

;; mul_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (mul m x y))
     (and (no_overflow m (* (tqtreal x) (tqtreal y)))
     (= (tqtreal (mul m x y)) (round m (* (tqtreal x) (tqtreal y))))))) :pattern (
  (mul m x y)) )))

;; div_finite
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (not (is_zero y))
     (=> (no_overflow m (/ (tqtreal x) (tqtreal y)))
     (and (tqtisFinite (div1 m x y))
     (= (tqtreal (div1 m x y)) (round m (/ (tqtreal x) (tqtreal y))))))))) :pattern (
  (div1 m x y)) )))

;; div_finite_rev
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (tqtisFinite (div1 m x y))
     (or (and (tqtisFinite x) (and (tqtisFinite y) (not (is_zero y))))
     (and (tqtisFinite x)
     (and (is_infinite y) (= (tqtreal (div1 m x y)) 0.0))))) :pattern (
  (div1 m x y)) )))

;; div_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (div1 m x y))
     (=> (tqtisFinite y)
     (and (no_overflow m (/ (tqtreal x) (tqtreal y)))
     (= (tqtreal (div1 m x y)) (round m (/ (tqtreal x) (tqtreal y)))))))) :pattern (
  (div1 m x y)) )))

;; neg_finite
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x)
     (and (tqtisFinite (neg x)) (= (tqtreal (neg x)) (- (tqtreal x))))) :pattern (
  (neg x)) )))

;; neg_finite_rev
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite (neg x))
     (and (tqtisFinite x) (= (tqtreal (neg x)) (- (tqtreal x))))) :pattern (
  (neg x)) )))

;; abs_finite
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite x)
     (and (tqtisFinite (abs1 x))
     (and
     (= (tqtreal (abs1 x)) (ite (>= (tqtreal x) 0.0) (tqtreal x) (- (tqtreal
                                                                    x))))
     (is_positive (abs1 x))))) :pattern ((abs1 x)) )))

;; abs_finite_rev
  (assert
  (forall ((x t))
  (! (=> (tqtisFinite (abs1 x))
     (and (tqtisFinite x)
     (= (tqtreal (abs1 x)) (ite (>= (tqtreal x) 0.0) (tqtreal x) (- (tqtreal
                                                                    x)))))) :pattern (
  (abs1 x)) )))

;; abs_universal
  (assert
  (forall ((x t)) (! (not (is_negative (abs1 x))) :pattern ((abs1 x)) )))

;; fma_finite
  (assert
  (forall ((m mode) (x t) (y t) (z t))
  (! (=> (tqtisFinite x)
     (=> (tqtisFinite y)
     (=> (tqtisFinite z)
     (=> (no_overflow m (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)))
     (and (tqtisFinite (fma m x y z))
     (= (tqtreal (fma m x y z)) (round m
                                (+ (* (tqtreal x) (tqtreal y)) (tqtreal z))))))))) :pattern (
  (fma m x y z)) )))

;; fma_finite_rev
  (assert
  (forall ((m mode) (x t) (y t) (z t))
  (! (=> (tqtisFinite (fma m x y z))
     (and (tqtisFinite x) (and (tqtisFinite y) (tqtisFinite z)))) :pattern (
  (fma m x y z)) )))

;; fma_finite_rev_n
  (assert
  (forall ((m mode) (x t) (y t) (z t))
  (! (=> (to_nearest m)
     (=> (tqtisFinite (fma m x y z))
     (and (no_overflow m (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)))
     (= (tqtreal (fma m x y z)) (round m
                                (+ (* (tqtreal x) (tqtreal y)) (tqtreal z))))))) :pattern (
  (fma m x y z)) )))

(define-fun sqr ((x Real)) Real (* x x))

(declare-fun sqrt2 (Real) Real)

;; Sqrt_positive
  (assert (forall ((x Real)) (=> (<= 0.0 x) (<= 0.0 (sqrt2 x)))))

;; Sqrt_square
  (assert (forall ((x Real)) (=> (<= 0.0 x) (= (sqr (sqrt2 x)) x))))

;; Square_sqrt
  (assert (forall ((x Real)) (=> (<= 0.0 x) (= (sqrt2 (* x x)) x))))

;; Sqrt_mul
  (assert
  (forall ((x Real) (y Real))
  (=> (and (<= 0.0 x) (<= 0.0 y))
  (= (sqrt2 (* x y)) (* (sqrt2 x) (sqrt2 y))))))

;; Sqrt_le
  (assert
  (forall ((x Real) (y Real))
  (=> (and (<= 0.0 x) (<= x y)) (<= (sqrt2 x) (sqrt2 y)))))

;; sqrt_finite
  (assert
  (forall ((m mode) (x t))
  (! (=> (tqtisFinite x)
     (=> (<= 0.0 (tqtreal x))
     (and (tqtisFinite (sqrt1 m x))
     (= (tqtreal (sqrt1 m x)) (round m (sqrt2 (tqtreal x))))))) :pattern (
  (sqrt1 m x)) )))

;; sqrt_finite_rev
  (assert
  (forall ((m mode) (x t))
  (! (=> (tqtisFinite (sqrt1 m x))
     (and (tqtisFinite x)
     (and (<= 0.0 (tqtreal x))
     (= (tqtreal (sqrt1 m x)) (round m (sqrt2 (tqtreal x))))))) :pattern (
  (sqrt1 m x)) )))

(define-fun same_sign_real ((x t)
  (r Real)) Bool (or (and (is_positive x) (< 0.0 r))
                 (and (is_negative x) (< r 0.0))))

;; add_special
  (assert
  (forall ((m mode) (x t) (y t))
  (! (let ((r (add m x y)))
     (and (=> (or (is_nan x) (is_nan y)) (is_nan r))
     (and
     (=> (and (tqtisFinite x) (is_infinite y))
     (and (is_infinite r) (same_sign r y)))
     (and
     (=> (and (is_infinite x) (tqtisFinite y))
     (and (is_infinite r) (same_sign r x)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (same_sign x y)))
     (and (is_infinite r) (same_sign r x)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (diff_sign x y))) (is_nan
     r))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y) (not (no_overflow m (+ (tqtreal x) (tqtreal y))))))
     (and (same_sign_real r (+ (tqtreal x) (tqtreal y))) (overflow_value m
     r)))
     (=> (and (tqtisFinite x) (tqtisFinite y))
     (ite (same_sign x y) (same_sign r x) (sign_zero_result m r)))))))))) :pattern (
  (add m x y)) )))

;; sub_special
  (assert
  (forall ((m mode) (x t) (y t))
  (! (let ((r (sub m x y)))
     (and (=> (or (is_nan x) (is_nan y)) (is_nan r))
     (and
     (=> (and (tqtisFinite x) (is_infinite y))
     (and (is_infinite r) (diff_sign r y)))
     (and
     (=> (and (is_infinite x) (tqtisFinite y))
     (and (is_infinite r) (same_sign r x)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (same_sign x y))) (is_nan
     r))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (diff_sign x y)))
     (and (is_infinite r) (same_sign r x)))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y) (not (no_overflow m (- (tqtreal x) (tqtreal y))))))
     (and (same_sign_real r (- (tqtreal x) (tqtreal y))) (overflow_value m
     r)))
     (=> (and (tqtisFinite x) (tqtisFinite y))
     (ite (diff_sign x y) (same_sign r x) (sign_zero_result m r)))))))))) :pattern (
  (sub m x y)) )))

;; mul_special
  (assert
  (forall ((m mode) (x t) (y t))
  (! (let ((r (mul m x y)))
     (and (=> (or (is_nan x) (is_nan y)) (is_nan r))
     (and (=> (and (is_zero x) (is_infinite y)) (is_nan r))
     (and
     (=> (and (tqtisFinite x) (and (is_infinite y) (not (is_zero x))))
     (is_infinite r))
     (and (=> (and (is_infinite x) (is_zero y)) (is_nan r))
     (and
     (=> (and (is_infinite x) (and (tqtisFinite y) (not (is_zero y))))
     (is_infinite r))
     (and (=> (and (is_infinite x) (is_infinite y)) (is_infinite r))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y) (not (no_overflow m (* (tqtreal x) (tqtreal y))))))
     (overflow_value m r)) (=> (not (is_nan r)) (product_sign r x y)))))))))) :pattern (
  (mul m x y)) )))

;; div_special
  (assert
  (forall ((m mode) (x t) (y t))
  (! (let ((r (div1 m x y)))
     (and (=> (or (is_nan x) (is_nan y)) (is_nan r))
     (and (=> (and (tqtisFinite x) (is_infinite y)) (is_zero r))
     (and (=> (and (is_infinite x) (tqtisFinite y)) (is_infinite r))
     (and (=> (and (is_infinite x) (is_infinite y)) (is_nan r))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y)
     (and (not (is_zero y))
     (not (no_overflow m (/ (tqtreal x) (tqtreal y))))))) (overflow_value m
     r))
     (and
     (=> (and (tqtisFinite x) (and (is_zero y) (not (is_zero x))))
     (is_infinite r))
     (and (=> (and (is_zero x) (is_zero y)) (is_nan r))
     (=> (not (is_nan r)) (product_sign r x y)))))))))) :pattern ((div1 m x
                                                                  y)) )))

;; neg_special
  (assert
  (forall ((x t))
  (! (and (=> (is_nan x) (is_nan (neg x)))
     (and (=> (is_infinite x) (is_infinite (neg x)))
     (=> (not (is_nan x)) (diff_sign x (neg x))))) :pattern ((neg x)) )))

;; abs_special
  (assert
  (forall ((x t))
  (! (and (=> (is_nan x) (is_nan (abs1 x)))
     (and (=> (is_infinite x) (is_infinite (abs1 x)))
     (=> (not (is_nan x)) (is_positive (abs1 x))))) :pattern ((abs1 x)) )))

;; fma_special
  (assert
  (forall ((m mode) (x t) (y t) (z t))
  (! (let ((r (fma m x y z)))
     (and (=> (or (is_nan x) (or (is_nan y) (is_nan z))) (is_nan r))
     (and (=> (and (is_zero x) (is_infinite y)) (is_nan r))
     (and (=> (and (is_infinite x) (is_zero y)) (is_nan r))
     (and
     (=>
     (and (tqtisFinite x)
     (and (not (is_zero x)) (and (is_infinite y) (tqtisFinite z))))
     (and (is_infinite r) (product_sign r x y)))
     (and
     (=>
     (and (tqtisFinite x)
     (and (not (is_zero x)) (and (is_infinite y) (is_infinite z))))
     (ite (product_sign z x y) (and (is_infinite r) (same_sign r z)) (is_nan
     r)))
     (and
     (=>
     (and (is_infinite x)
     (and (tqtisFinite y) (and (not (is_zero y)) (tqtisFinite z))))
     (and (is_infinite r) (product_sign r x y)))
     (and
     (=>
     (and (is_infinite x)
     (and (tqtisFinite y) (and (not (is_zero y)) (is_infinite z))))
     (ite (product_sign z x y) (and (is_infinite r) (same_sign r z)) (is_nan
     r)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (tqtisFinite z)))
     (and (is_infinite r) (product_sign r x y)))
     (and
     (=> (and (tqtisFinite x) (and (tqtisFinite y) (is_infinite z)))
     (and (is_infinite r) (same_sign r z)))
     (and
     (=> (and (is_infinite x) (and (is_infinite y) (is_infinite z)))
     (ite (product_sign z x y) (and (is_infinite r) (same_sign r z)) (is_nan
     r)))
     (and
     (=>
     (and (tqtisFinite x)
     (and (tqtisFinite y)
     (and (tqtisFinite z)
     (not (no_overflow m (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)))))))
     (and (same_sign_real r (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)))
     (overflow_value m r)))
     (=> (and (tqtisFinite x) (and (tqtisFinite y) (tqtisFinite z)))
     (ite (product_sign z x y) (same_sign r z)
     (=> (= (+ (* (tqtreal x) (tqtreal y)) (tqtreal z)) 0.0)
     (ite (= m RTN1) (is_negative r) (is_positive r))))))))))))))))) :pattern (
  (fma m x y z)) )))

;; sqrt_special
  (assert
  (forall ((m mode) (x t))
  (! (let ((r (sqrt1 m x)))
     (and (=> (is_nan x) (is_nan r))
     (and (=> (is_plus_infinity x) (is_plus_infinity r))
     (and (=> (is_minus_infinity x) (is_nan r))
     (and (=> (and (tqtisFinite x) (< (tqtreal x) 0.0)) (is_nan r))
     (and (=> (is_zero x) (same_sign r x))
     (=> (and (tqtisFinite x) (< 0.0 (tqtreal x))) (is_positive r)))))))) :pattern (
  (sqrt1 m x)) )))

;; of_int_add_exact
  (assert
  (forall ((m mode) (n mode) (i Int) (j Int))
  (=> (in_safe_int_range i)
  (=> (in_safe_int_range j)
  (=> (in_safe_int_range (+ i j)) (eq (of_int m (+ i j))
  (add n (of_int m i) (of_int m j))))))))

;; of_int_sub_exact
  (assert
  (forall ((m mode) (n mode) (i Int) (j Int))
  (=> (in_safe_int_range i)
  (=> (in_safe_int_range j)
  (=> (in_safe_int_range (- i j)) (eq (of_int m (- i j))
  (sub n (of_int m i) (of_int m j))))))))

;; of_int_mul_exact
  (assert
  (forall ((m mode) (n mode) (i Int) (j Int))
  (=> (in_safe_int_range i)
  (=> (in_safe_int_range j)
  (=> (in_safe_int_range (* i j)) (eq (of_int m (* i j))
  (mul n (of_int m i) (of_int m j))))))))

;; Min_r
  (assert (forall ((x t) (y t)) (=> (le y x) (eq (min x y) y))))

;; Min_l
  (assert (forall ((x t) (y t)) (=> (le x y) (eq (min x y) x))))

;; Max_r
  (assert (forall ((x t) (y t)) (=> (le y x) (eq (max x y) x))))

;; Max_l
  (assert (forall ((x t) (y t)) (=> (le x y) (eq (max x y) y))))

(declare-fun is_int1 (t) Bool)

;; zeroF_is_int
  (assert (is_int1 zeroF))

;; of_int_is_int
  (assert
  (forall ((m mode) (x Int)) (=> (in_int_range x) (is_int1 (of_int m x)))))

;; big_float_is_int
  (assert
  (forall ((m mode) (i t))
  (=> (tqtisFinite i)
  (=> (or (le i (neg (of_int m 16777216))) (le (of_int m 16777216) i))
  (is_int1 i)))))

;; roundToIntegral_is_int
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x) (is_int1 (roundToIntegral m x)))))

;; eq_is_int
  (assert (forall ((x t) (y t)) (=> (eq x y) (=> (is_int1 x) (is_int1 y)))))

;; add_int
  (assert
  (forall ((x t) (y t) (m mode))
  (=> (is_int1 x)
  (=> (is_int1 y) (=> (tqtisFinite (add m x y)) (is_int1 (add m x y)))))))

;; sub_int
  (assert
  (forall ((x t) (y t) (m mode))
  (=> (is_int1 x)
  (=> (is_int1 y) (=> (tqtisFinite (sub m x y)) (is_int1 (sub m x y)))))))

;; mul_int
  (assert
  (forall ((x t) (y t) (m mode))
  (=> (is_int1 x)
  (=> (is_int1 y) (=> (tqtisFinite (mul m x y)) (is_int1 (mul m x y)))))))

;; fma_int
  (assert
  (forall ((x t) (y t) (z t) (m mode))
  (=> (is_int1 x)
  (=> (is_int1 y)
  (=> (is_int1 z) (=> (tqtisFinite (fma m x y z)) (is_int1 (fma m x y z))))))))

;; neg_int
  (assert (forall ((x t)) (=> (is_int1 x) (is_int1 (neg x)))))

;; abs_int
  (assert (forall ((x t)) (=> (is_int1 x) (is_int1 (abs1 x)))))

;; is_int_of_int
  (assert
  (forall ((x t) (m mode) (mqt mode))
  (=> (is_int1 x) (eq x (of_int mqt (to_int1 m x))))))

;; is_int_to_int
  (assert
  (forall ((m mode) (x t)) (=> (is_int1 x) (in_int_range (to_int1 m x)))))

;; is_int_is_finite
  (assert (forall ((x t)) (=> (is_int1 x) (tqtisFinite x))))

;; int_to_real
  (assert
  (forall ((m mode) (x t))
  (=> (is_int1 x) (= (tqtreal x) (to_real (to_int1 m x))))))

;; truncate_int
  (assert
  (forall ((m mode) (i t)) (=> (is_int1 i) (eq (roundToIntegral m i) i))))

;; truncate_neg
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (=> (is_negative x) (= (roundToIntegral RTZ1 x) (roundToIntegral RTP1 x))))))

;; truncate_pos
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (=> (is_positive x) (= (roundToIntegral RTZ1 x) (roundToIntegral RTN1 x))))))

;; ceil_le
  (assert
  (forall ((x t)) (=> (tqtisFinite x) (le x (roundToIntegral RTP1 x)))))

;; ceil_lest
  (assert
  (forall ((x t) (y t))
  (=> (and (le x y) (is_int1 y)) (le (roundToIntegral RTP1 x) y))))

;; ceil_to_real
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (= (tqtreal (roundToIntegral RTP1 x)) (to_real (- 1 (to_int (- 1.0
  (tqtreal x)))))))))

;; ceil_to_int
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x)
  (= (to_int1 m (roundToIntegral RTP1 x)) (- 1 (to_int (- 1.0 (tqtreal x))))))))

;; floor_le
  (assert
  (forall ((x t)) (=> (tqtisFinite x) (le (roundToIntegral RTN1 x) x))))

;; floor_lest
  (assert
  (forall ((x t) (y t))
  (=> (and (le y x) (is_int1 y)) (le y (roundToIntegral RTN1 x)))))

;; floor_to_real
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (= (tqtreal (roundToIntegral RTN1 x)) (to_real (to_int (tqtreal x)))))))

;; floor_to_int
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x)
  (= (to_int1 m (roundToIntegral RTN1 x)) (to_int (tqtreal x))))))

;; RNA_down
  (assert
  (forall ((x t))
  (=> (lt (sub RNE1 x (roundToIntegral RTN1 x))
  (sub RNE1 (roundToIntegral RTP1 x) x))
  (= (roundToIntegral RNA1 x) (roundToIntegral RTN1 x)))))

;; RNA_up
  (assert
  (forall ((x t))
  (=> (lt (sub RNE1 (roundToIntegral RTP1 x) x)
  (sub RNE1 x (roundToIntegral RTN1 x)))
  (= (roundToIntegral RNA1 x) (roundToIntegral RTP1 x)))))

;; RNA_down_tie
  (assert
  (forall ((x t))
  (=> (eq (sub RNE1 x (roundToIntegral RTN1 x))
  (sub RNE1 (roundToIntegral RTP1 x) x))
  (=> (is_negative x) (= (roundToIntegral RNA1 x) (roundToIntegral RTN1 x))))))

;; RNA_up_tie
  (assert
  (forall ((x t))
  (=> (eq (sub RNE1 (roundToIntegral RTP1 x) x)
  (sub RNE1 x (roundToIntegral RTN1 x)))
  (=> (is_positive x) (= (roundToIntegral RNA1 x) (roundToIntegral RTP1 x))))))

;; to_int_roundToIntegral
  (assert
  (forall ((m mode) (x t))
  (= (to_int1 m x) (to_int1 m (roundToIntegral m x)))))

;; to_int_monotonic
  (assert
  (forall ((m mode) (x t) (y t))
  (=> (tqtisFinite x)
  (=> (tqtisFinite y) (=> (le x y) (<= (to_int1 m x) (to_int1 m y)))))))

;; to_int_of_int
  (assert
  (forall ((m mode) (i Int))
  (=> (in_safe_int_range i) (= (to_int1 m (of_int m i)) i))))

;; eq_to_int
  (assert
  (forall ((m mode) (x t) (y t))
  (=> (tqtisFinite x) (=> (eq x y) (= (to_int1 m x) (to_int1 m y))))))

;; neg_to_int
  (assert
  (forall ((m mode) (x t))
  (=> (is_int1 x) (= (to_int1 m (neg x)) (- (to_int1 m x))))))

;; roundToIntegral_is_finite
  (assert
  (forall ((m mode) (x t))
  (=> (tqtisFinite x) (tqtisFinite (roundToIntegral m x)))))

;; round_bound_ne
  (assert
  (forall ((x Real))
  (! (=> (no_overflow RNE1 x)
     (and
     (<= (- (- x (* (/ 1.0 16777216.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 1427247692705959881058285969449495136382746624.0))
     (round RNE1 x))
     (<= (round RNE1 x) (+ (+ x (* (/ 1.0 16777216.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 1427247692705959881058285969449495136382746624.0))))) :pattern (
  (round RNE1 x)) )))

;; round_bound
  (assert
  (forall ((m mode) (x Real))
  (! (=> (no_overflow m x)
     (and
     (<= (- (- x (* (/ 1.0 8388608.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 713623846352979940529142984724747568191373312.0))
     (round m x))
     (<= (round m x) (+ (+ x (* (/ 1.0 8388608.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 713623846352979940529142984724747568191373312.0))))) :pattern (
  (round m x)) )))

(define-fun neq ((x t) (y t)) Bool (not (eq x y)))

(define-fun bool_lt ((x t) (y t)) Bool (ite (lt x y) true false))

(define-fun bool_le ((x t) (y t)) Bool (ite (le x y) true false))

(define-fun bool_gt ((x t) (y t)) Bool (ite (lt y x) true false))

(define-fun bool_ge ((x t) (y t)) Bool (ite (le y x) true false))

(define-fun bool_eq ((x t) (y t)) Bool (ite (eq x y) true false))

(define-fun bool_neq ((x t) (y t)) Bool (ite (not (eq x y)) true false))

(declare-fun rem1 (t t) t)

(declare-const fliteral t)

;; fliteral_axiom
  (assert (and (tqtisFinite fliteral) (= (tqtreal fliteral) 1.0)))

;; one_is_int
  (assert (is_int1 fliteral))

;; one_of_int
  (assert (= fliteral (of_int RNA1 1)))

(declare-datatypes () ((t__ref (mk_t__ref (t__content t)))))
(declare-fun power (t Int) t)

;; Power_0
  (assert
  (forall ((x t)) (=> (tqtisFinite x) (eq (power x 0) (of_int RNE1 1)))))

;; Power_1
  (assert (forall ((x t)) (=> (tqtisFinite x) (eq (power x 1) x))))

;; Power_2
  (assert
  (forall ((x t)) (=> (tqtisFinite x) (eq (power x 2) (mul RNE1 x x)))))

;; Power_3
  (assert
  (forall ((x t))
  (=> (tqtisFinite x) (eq (power x 3) (mul RNE1 x (mul RNE1 x x))))))

;; Power_neg1
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (=> (not (is_zero x)) (eq (power x (- 1)) (div1 RNE1 (of_int RNE1 1) x))))))

;; Power_neg2
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (=> (not (is_zero x)) (eq (power x (- 2))
  (div1 RNE1 (of_int RNE1 1) (power x 2)))))))

;; Power_neg3
  (assert
  (forall ((x t))
  (=> (tqtisFinite x)
  (=> (not (is_zero x)) (eq (power x (- 2))
  (div1 RNE1 (of_int RNE1 1) (power x 3)))))))

(define-fun dynamic_invariant ((temp___expr_39 Int) (temp___is_init_35 Bool)
  (temp___skip_constant_36 Bool) (temp___do_toplevel_37 Bool)
  (temp___do_typ_inv_38 Bool)) Bool (=>
                                    (or (= temp___is_init_35 true)
                                    (<= 0 2147483647)) (in_range
                                    temp___expr_39)))

(declare-sort fibonacci_argument_type 0)

(declare-fun fibonacci_argument_typeqtint (fibonacci_argument_type) Int)

;; fibonacci_argument_type'axiom
  (assert
  (forall ((i fibonacci_argument_type))
  (and (<= 0 (fibonacci_argument_typeqtint i))
  (<= (fibonacci_argument_typeqtint i) 46))))

(define-fun in_range2 ((x Int)) Bool (and (<= 0 x) (<= x 46)))

(declare-fun attr__ATTRIBUTE_IMAGE1 (Int) us_image)

(declare-fun attr__ATTRIBUTE_VALUE__pre_check1 (us_image) Bool)

(declare-fun attr__ATTRIBUTE_VALUE1 (us_image) Int)

(declare-fun user_eq1 (fibonacci_argument_type fibonacci_argument_type) Bool)

(declare-const dummy1 fibonacci_argument_type)

(declare-datatypes ()
((fibonacci_argument_type__ref
 (mk_fibonacci_argument_type__ref
 (fibonacci_argument_type__content fibonacci_argument_type)))))
(define-fun fibonacci_argument_type__ref___projection ((a fibonacci_argument_type__ref)) fibonacci_argument_type
  (fibonacci_argument_type__content a))

(define-fun dynamic_invariant1 ((temp___expr_208 Int)
  (temp___is_init_204 Bool) (temp___skip_constant_205 Bool)
  (temp___do_toplevel_206 Bool)
  (temp___do_typ_inv_207 Bool)) Bool (=>
                                     (or (= temp___is_init_204 true)
                                     (<= 0 46)) (in_range2 temp___expr_208)))

;; fib__def_axiom
  (assert
  (forall ((n Int))
  (! (=> (dynamic_invariant1 n true true true true)
     (= (fib n) (ite (or (= n 0) (= n 1)) n (+ (fib (- n 1)) (fib (- n 2)))))) :pattern (
  (fib n)) )))

(declare-const n Int)

(declare-const attr__ATTRIBUTE_ADDRESS Int)

(declare-datatypes ()
((map__ref (mk_map__ref (map__content (Array Int natural))))))
(declare-fun slide ((Array Int natural) Int Int) (Array Int natural))

;; slide_eq
  (assert
  (forall ((a (Array Int natural)))
  (forall ((first Int))
  (! (= (slide a first first) a) :pattern ((slide a first first)) ))))

;; slide_def
  (assert
  (forall ((a (Array Int natural)))
  (forall ((old_first Int))
  (forall ((new_first Int))
  (forall ((i Int))
  (! (= (select (slide a old_first new_first) i) (select a (- i (- new_first old_first)))) :pattern ((select
  (slide a old_first new_first) i)) ))))))

(define-fun bool_eq1 ((a (Array Int natural)) (a__first Int) (a__last Int)
  (b (Array Int natural)) (b__first Int)
  (b__last Int)) Bool (ite (and
                           (ite (<= a__first a__last)
                           (and (<= b__first b__last)
                           (= (- a__last a__first) (- b__last b__first)))
                           (< b__last b__first))
                           (forall ((temp___idx_154 Int))
                           (=>
                           (and (<= a__first temp___idx_154)
                           (<= temp___idx_154 a__last))
                           (= (to_rep (select a temp___idx_154)) (to_rep
                                                                 (select b (+ (- b__first a__first) temp___idx_154)))))))
                      true false))

;; bool_eq_rev
  (assert
  (forall ((a (Array Int natural)) (b (Array Int natural)))
  (forall ((a__first Int) (a__last Int) (b__first Int) (b__last Int))
  (=> (= (bool_eq1 b b__first b__last a a__first a__last) true)
  (and
  (ite (<= a__first a__last)
  (and (<= b__first b__last) (= (- a__last a__first) (- b__last b__first)))
  (< b__last b__first))
  (forall ((temp___idx_154 Int))
  (=> (and (<= a__first temp___idx_154) (<= temp___idx_154 a__last))
  (= (to_rep (select a temp___idx_154)) (to_rep
                                        (select b (+ (- b__first a__first) temp___idx_154)))))))))))

(declare-const lookup_table (Array Int natural))

(declare-const attr__ATTRIBUTE_ADDRESS1 Int)

(declare-fun number_theory__fibonacci2__lookup_table__aggregate_def (Int Int
  Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int
  Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int Int
  Int Int Int Int Int Int Int) (Array Int natural))

;; lookup_table__def_axiom
  (assert
  (= lookup_table (number_theory__fibonacci2__lookup_table__aggregate_def 0 1
                  1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
                  6765 10946 17711 28657 46368 75025 121393 196418 317811
                  514229 832040 1346269 2178309 3524578 5702887 9227465
                  14930352 24157817 39088169 63245986 102334155 165580141
                  267914296 433494437 701408733 1134903170 1836311903)))

(declare-const rliteral natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral) 0))

(declare-const rliteral1 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral1) 1))

(declare-const rliteral2 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral2) 2))

(declare-const rliteral3 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral3) 3))

(declare-const rliteral4 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral4) 5))

(declare-const rliteral5 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral5) 8))

(declare-const rliteral6 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral6) 13))

(declare-const rliteral7 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral7) 21))

(declare-const rliteral8 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral8) 34))

(declare-const rliteral9 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral9) 55))

(declare-const rliteral10 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral10) 89))

(declare-const rliteral11 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral11) 144))

(declare-const rliteral12 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral12) 233))

(declare-const rliteral13 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral13) 377))

(declare-const rliteral14 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral14) 610))

(declare-const rliteral15 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral15) 987))

(declare-const rliteral16 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral16) 1597))

(declare-const rliteral17 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral17) 2584))

(declare-const rliteral18 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral18) 4181))

(declare-const rliteral19 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral19) 6765))

(declare-const rliteral20 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral20) 10946))

(declare-const rliteral21 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral21) 17711))

(declare-const rliteral22 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral22) 28657))

(declare-const rliteral23 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral23) 46368))

(declare-const rliteral24 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral24) 75025))

(declare-const rliteral25 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral25) 121393))

(declare-const rliteral26 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral26) 196418))

(declare-const rliteral27 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral27) 317811))

(declare-const rliteral28 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral28) 514229))

(declare-const rliteral29 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral29) 832040))

(declare-const rliteral30 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral30) 1346269))

(declare-const rliteral31 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral31) 2178309))

(declare-const rliteral32 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral32) 3524578))

(declare-const rliteral33 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral33) 5702887))

(declare-const rliteral34 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral34) 9227465))

(declare-const rliteral35 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral35) 14930352))

(declare-const rliteral36 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral36) 24157817))

(declare-const rliteral37 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral37) 39088169))

(declare-const rliteral38 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral38) 63245986))

(declare-const rliteral39 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral39) 102334155))

(declare-const rliteral40 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral40) 165580141))

(declare-const rliteral41 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral41) 267914296))

(declare-const rliteral42 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral42) 433494437))

(declare-const rliteral43 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral43) 701408733))

(declare-const rliteral44 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral44) 1134903170))

(declare-const rliteral45 natural)

;; rliteral_axiom
  (assert (= (naturalqtint rliteral45) 1836311903))

;; def_axiom
  (assert
  (forall ((temp___156 Int) (temp___157 Int) (temp___158 Int)
  (temp___159 Int) (temp___160 Int) (temp___161 Int) (temp___162 Int)
  (temp___163 Int) (temp___164 Int) (temp___165 Int) (temp___166 Int)
  (temp___167 Int) (temp___168 Int) (temp___169 Int) (temp___170 Int)
  (temp___171 Int) (temp___172 Int) (temp___173 Int) (temp___174 Int)
  (temp___175 Int) (temp___176 Int) (temp___177 Int) (temp___178 Int)
  (temp___179 Int) (temp___180 Int) (temp___181 Int) (temp___182 Int)
  (temp___183 Int) (temp___184 Int) (temp___185 Int) (temp___186 Int)
  (temp___187 Int) (temp___188 Int) (temp___189 Int) (temp___190 Int)
  (temp___191 Int) (temp___192 Int) (temp___193 Int) (temp___194 Int)
  (temp___195 Int) (temp___196 Int) (temp___197 Int) (temp___198 Int)
  (temp___199 Int) (temp___200 Int) (temp___201 Int) (temp___202 Int))
  (let ((temp___155 (number_theory__fibonacci2__lookup_table__aggregate_def
                    temp___156 temp___157 temp___158 temp___159 temp___160
                    temp___161 temp___162 temp___163 temp___164 temp___165
                    temp___166 temp___167 temp___168 temp___169 temp___170
                    temp___171 temp___172 temp___173 temp___174 temp___175
                    temp___176 temp___177 temp___178 temp___179 temp___180
                    temp___181 temp___182 temp___183 temp___184 temp___185
                    temp___186 temp___187 temp___188 temp___189 temp___190
                    temp___191 temp___192 temp___193 temp___194 temp___195
                    temp___196 temp___197 temp___198 temp___199 temp___200
                    temp___201 temp___202)))
  (=>
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and (dynamic_invariant temp___156 true true true true) (dynamic_invariant
  temp___157 true true true true)) (dynamic_invariant temp___158 true true
  true true)) (dynamic_invariant temp___159 true true true true))
  (dynamic_invariant temp___160 true true true true)) (dynamic_invariant
  temp___161 true true true true)) (dynamic_invariant temp___162 true true
  true true)) (dynamic_invariant temp___163 true true true true))
  (dynamic_invariant temp___164 true true true true)) (dynamic_invariant
  temp___165 true true true true)) (dynamic_invariant temp___166 true true
  true true)) (dynamic_invariant temp___167 true true true true))
  (dynamic_invariant temp___168 true true true true)) (dynamic_invariant
  temp___169 true true true true)) (dynamic_invariant temp___170 true true
  true true)) (dynamic_invariant temp___171 true true true true))
  (dynamic_invariant temp___172 true true true true)) (dynamic_invariant
  temp___173 true true true true)) (dynamic_invariant temp___174 true true
  true true)) (dynamic_invariant temp___175 true true true true))
  (dynamic_invariant temp___176 true true true true)) (dynamic_invariant
  temp___177 true true true true)) (dynamic_invariant temp___178 true true
  true true)) (dynamic_invariant temp___179 true true true true))
  (dynamic_invariant temp___180 true true true true)) (dynamic_invariant
  temp___181 true true true true)) (dynamic_invariant temp___182 true true
  true true)) (dynamic_invariant temp___183 true true true true))
  (dynamic_invariant temp___184 true true true true)) (dynamic_invariant
  temp___185 true true true true)) (dynamic_invariant temp___186 true true
  true true)) (dynamic_invariant temp___187 true true true true))
  (dynamic_invariant temp___188 true true true true)) (dynamic_invariant
  temp___189 true true true true)) (dynamic_invariant temp___190 true true
  true true)) (dynamic_invariant temp___191 true true true true))
  (dynamic_invariant temp___192 true true true true)) (dynamic_invariant
  temp___193 true true true true)) (dynamic_invariant temp___194 true true
  true true)) (dynamic_invariant temp___195 true true true true))
  (dynamic_invariant temp___196 true true true true)) (dynamic_invariant
  temp___197 true true true true)) (dynamic_invariant temp___198 true true
  true true)) (dynamic_invariant temp___199 true true true true))
  (dynamic_invariant temp___200 true true true true)) (dynamic_invariant
  temp___201 true true true true)) (dynamic_invariant temp___202 true true
  true true))
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and
  (and (= (select temp___155 0) rliteral)
  (= (select temp___155 1) rliteral1)) (= (select temp___155 2) rliteral1))
  (= (select temp___155 3) rliteral2)) (= (select temp___155 4) rliteral3))
  (= (select temp___155 5) rliteral4)) (= (select temp___155 6) rliteral5))
  (= (select temp___155 7) rliteral6)) (= (select temp___155 8) rliteral7))
  (= (select temp___155 9) rliteral8)) (= (select temp___155 10) rliteral9))
  (= (select temp___155 11) rliteral10))
  (= (select temp___155 12) rliteral11))
  (= (select temp___155 13) rliteral12))
  (= (select temp___155 14) rliteral13))
  (= (select temp___155 15) rliteral14))
  (= (select temp___155 16) rliteral15))
  (= (select temp___155 17) rliteral16))
  (= (select temp___155 18) rliteral17))
  (= (select temp___155 19) rliteral18))
  (= (select temp___155 20) rliteral19))
  (= (select temp___155 21) rliteral20))
  (= (select temp___155 22) rliteral21))
  (= (select temp___155 23) rliteral22))
  (= (select temp___155 24) rliteral23))
  (= (select temp___155 25) rliteral24))
  (= (select temp___155 26) rliteral25))
  (= (select temp___155 27) rliteral26))
  (= (select temp___155 28) rliteral27))
  (= (select temp___155 29) rliteral28))
  (= (select temp___155 30) rliteral29))
  (= (select temp___155 31) rliteral30))
  (= (select temp___155 32) rliteral31))
  (= (select temp___155 33) rliteral32))
  (= (select temp___155 34) rliteral33))
  (= (select temp___155 35) rliteral34))
  (= (select temp___155 36) rliteral35))
  (= (select temp___155 37) rliteral36))
  (= (select temp___155 38) rliteral37))
  (= (select temp___155 39) rliteral38))
  (= (select temp___155 40) rliteral39))
  (= (select temp___155 41) rliteral40))
  (= (select temp___155 42) rliteral41))
  (= (select temp___155 43) rliteral42))
  (= (select temp___155 44) rliteral43))
  (= (select temp___155 45) rliteral44))
  (= (select temp___155 46) rliteral45))))))

(declare-const number_theory__fibonacci2__result Int)

(declare-const result Int)

(declare-const number_theory__fibonacci2__result1 Int)

(declare-const number_theory__fibonacci2__result2 Int)

(declare-const number_theory__fibonacci2__result3 Int)

(declare-const number_theory__fibonacci2__result4 Int)

(declare-const number_theory__fibonacci2__result5 Int)

(declare-const result1 Int)

;; H
  (assert (in_range2 n))

;; H
  (assert
  (= (number_theory__fibonacci2__lookup_table__aggregate_def 0 1 1 2 3 5 8 13
     21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657
     46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578
     5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141
     267914296 433494437 701408733 1134903170 1836311903) lookup_table))

;; H
  (assert
  (= number_theory__fibonacci2__result1 number_theory__fibonacci2__result2))

;; H
  (assert
  (= number_theory__fibonacci2__result3 number_theory__fibonacci2__result1))

;; H
  (assert (= result number_theory__fibonacci2__result))

;; H
  (assert
  (= number_theory__fibonacci2__result1 (to_rep (select lookup_table n))))

;; H
  (assert
  (= (mk_int__ref number_theory__fibonacci2__result4) (mk_int__ref
                                                      number_theory__fibonacci2__result2)))

;; H
  (assert
  (= number_theory__fibonacci2__result5 number_theory__fibonacci2__result3))

;; H
  (assert (= result1 number_theory__fibonacci2__result4))

(assert
;; WP_parameter_def
 ;; File "/home/florian/adacore/spark2014/testsuite/gnatprove/tests/O512-022__number_theory/gnatprove/number_theory.mlw", line 3028, characters 5-8
  (not (= number_theory__fibonacci2__result4 (fib n))))
(check-sat)
(exit)
